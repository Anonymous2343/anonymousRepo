{"compilable":1,"function":"int foo(int *a) {\n    *a = 42;\n    return 0;\n}\n","function_prediction":"int foo_name_conflict(int *a) {\n  *a = 42;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f2101/main_2101.c"}
{"compilable":0,"function":"static inline char *ntos(int num, char *str, size_t *len) {\n    int onum = num, d;\n    size_t olen = *len;\n    int i = 0, j;\n    do {\n        d = num - (num / 10) * 10;\n        str[i++] = ((d) + 48);\n    } while (num /= 10);\n    str[i] = 0;\n    *len = i;\n    for (j = i - 1 , i = 0; i < j; ++i , --j) {\n        str[i] += str[j];\n        str[j] = str[i] - str[j];\n        str[i] = str[i] - str[j];\n    }\n    return str;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1984/main_1984.c"}
{"compilable":0,"function":"static int xxhash_init_hash(unsigned int *ret_digest_len) {\n    *ret_digest_len = 32;\n    return 0;\n}\n","function_prediction":"int xxhash_init_hash_name_conflict(xxhash_t *xxh) {\n  xxh->hash = 32;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f543/main_543.c"}
{"compilable":1,"function":"static unsigned long namegen_rand32(unsigned long *s) {\n    unsigned long x = *s;\n    x ^= x << 13;\n    x ^= (x & 4294967295UL) >> 17;\n    x ^= x << 5;\n    return (*s = x) & 4294967295UL;\n}\n","function_prediction":"uint32_t namegen_rand32_name_conflict(uint32_t *seed) {\n  *seed ^= *seed << 13;\n  *seed ^= *seed >> 17;\n  *seed ^= *seed << 5;\n  return *seed;\n}","pass":1,"source_file":"C_COMPILE/f287/main_287.c"}
{"compilable":0,"function":"inline int secure_storage_read_a_key(unsigned char *name, unsigned int namelen, unsigned char *out, unsigned int outlen, unsigned int *datalen) {\n    return -1;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1161/main_1161.c"}
{"compilable":1,"function":"int max(int a, int b, int c, int *p) {\n    if (a > b) {\n        *p = 0;\n        return a;\n    } else {\n        *p = c;\n        return b;\n    }\n}\n","function_prediction":"int max_name_conflict(int a, int b, int c, int *d) {\n  if (a > b) {\n    *d = 0;\n    return a;\n  }\n  *d = c;\n  return b;\n}","pass":1,"source_file":"C_COMPILE/f317/main_317.c"}
{"compilable":1,"function":"int *intersect_lists(int *A, int *Ae, int *B, int *Be, int *D, int *De) {\n    int x, *C = B;\n    while (A < Ae)\n        {\n            x = *A++;\n            if (x > 0) {\n                while (B < Be && (unsigned int)*B > (unsigned int)x)\n                    B++;\n                if (B == Be)\n                    continue;\n                if (*B == x) {\n                    if (D < De)\n                        *D++ = x;\n                }\n            } else {\n                while (C < Be && (unsigned int)*C < (unsigned int)x)\n                    C++;\n                if (C == Be)\n                    continue;\n                if (*C == x) {\n                    if (D < De)\n                        *D++ = x;\n                }\n            }\n        }\n    return D;\n}\n","function_prediction":"int *intersect_lists_name_conflict(int *a, int *a_end, int *b, int *b_end, int *c,\n                     int *c_end) {\n  int *p, *q, *r;\n\n  for (p = a, q = b, r = b; p < a_end; p++) {\n    int x = *p;\n    if (x > 0) {\n      while (q < b_end && *q < x)\n        q++;\n      if (q != b_end && *q == x && r < c_end)\n        *r++ = x;\n    } else {\n      while (r < b_end && *r < x)\n        r++;\n      if (r != b_end && *r == x && r < c_end)\n        *r++ = x;\n    }\n  }\n  return r;\n}","pass":0,"source_file":"C_COMPILE/f321/main_321.c"}
{"compilable":1,"function":"static char *yystpcpy(char *yydest, const char *yysrc) {\n    register char *yyd = yydest;\n    register const char *yys = yysrc;\n    while ((*yyd++ = *yys++) != '\\x00')\n        continue;\n    return yyd - 1;\n}\n","function_prediction":"char *yystpcpy_name_conflict(char *d, const char *s)\n\n{\n  char *dst = d;\n\n  do {\n    *dst++ = *s;\n  } while (*s++);\n\n  return dst;\n}","pass":0,"source_file":"C_COMPILE/f540/main_540.c"}
{"compilable":0,"function":"static inline int xchg(volatile int *ptr, int x) {\n    asm (\"xchgl %0,%1\" : \"=r\" (x) : \"m\" (*(ptr)), \"0\" (x) : \"memory\");\n    return x;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f835/main_835.c"}
{"compilable":1,"function":"char *num2string(long num, int nfrac, int *strlength, char *str17) {\n    char *bufptr;\n    int neg = num < 0;\n    long unum = neg ? -num : num;\n    bufptr = (str17 + 16);\n    *bufptr = 0;\n    *strlength = 0;\n    do {\n        *--bufptr = (unum % 10) + '0';\n        (*strlength)++;\n        if (*strlength == nfrac) {\n            *--bufptr = '.';\n            (*strlength)++;\n            nfrac = 0;\n        }\n    } while ((unum /= 10) || nfrac);\n    if (neg) {\n        *--bufptr = '-';\n        (*strlength)++;\n    }\n    return bufptr;\n}\n","function_prediction":"char *num2string_name_conflict(long num, int precision, int *len, char *buf) {\n  char *p = buf + 16;\n  int i;\n\n  if (num < 0)\n    num = -num;\n\n  *p = '\\0';\n  *len = 0;\n  i = precision;\n  do {\n    *--p = '0' + num % 10;\n    (*len)++;\n    if (i == *len) {\n      *--p = '.';\n      (*len)++;\n      i = 0;\n    }\n    num /= 10;\n  } while (num || i);\n\n  if (num < 0) {\n    *--p = '-';\n    (*len)++;\n  }\n\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f1099/main_1099.c"}
{"compilable":1,"function":"static int computesizes(int nums[], int *narray) {\n    int i;\n    int twotoi;\n    int a = 0;\n    int na = 0;\n    int n = 0;\n    for (i = 0 , twotoi = 1; twotoi / 2 < *narray; i++ , twotoi *= 2) {\n        if (nums[i] > 0) {\n            a += nums[i];\n            if (a > twotoi / 2) {\n                n = twotoi;\n                na = a;\n            }\n        }\n        if (a == *narray)\n            break;\n    }\n    *narray = n;\n    return na;\n}\n","function_prediction":"int computesizes_name_conflict(int *sizes, int *maxsize) {\n  int i, max, sum, maxi;\n\n  max = sum = maxi = 0;\n  for (i = 1; i / 2 < *maxsize; i *= 2) {\n    if (sizes[maxi] > 0) {\n      sum += sizes[maxi];\n      if (sum > i / 2) {\n        max = sum;\n        *maxsize = i;\n      }\n    }\n    if (sum == *maxsize)\n      break;\n    maxi++;\n  }\n  return max;\n}","pass":0,"source_file":"C_COMPILE/f864/main_864.c"}
{"compilable":1,"function":"int writeVariableLengthQuantity(char *outputPtr, int input) {\n    if (input == 0) {\n        *outputPtr = 0;\n        return 1;\n    }\n    int length = 5;\n    for (int i = 4; i >= 0; i--) {\n        if (input >> i * 7) {\n            break;\n        } else {\n            length--;\n        }\n    }\n    for (int i = length - 1; i >= 0; i--) {\n        if (i != 0) {\n            *(outputPtr + length - i - 1) = ((input >> i * 7) & 127) + 128;\n        } else {\n            *(outputPtr + length - i - 1) = (input >> i * 7) & 127;\n        }\n    }\n    return length;\n}\n","function_prediction":"int writeVariableLengthQuantity_name_conflict(unsigned char *buffer, uint32_t value) {\n  int i, j;\n\n  if (value == 0) {\n    buffer[0] = 0;\n    return 1;\n  }\n\n  i = 5;\n  for (j = 4; j >= 0; j--) {\n    if ((value >> (j * 7)) != 0) {\n      break;\n    }\n    i--;\n  }\n\n  while (i-- > 0) {\n    if (i == 0) {\n      buffer[i] = value & 0x7F;\n    } else {\n      buffer[i] = ((value >> (i * 7)) & 0x7F) | 0x80;\n    }\n  }\n\n  return 5;\n}","pass":0,"source_file":"C_COMPILE/f869/main_869.c"}
{"compilable":1,"function":"int decToBinRev(int n, int binary[]) {\n    unsigned int i = 1;\n    unsigned int x = 0;\n    int y = 0;\n    while (i <= n)\n        {\n            i *= 2;\n            x++;\n        }\n    i /= 2;\n    x--;\n    for (y = (int)x; y >= 0; y--) {\n        if ((n - (int)i) >= 0) {\n            n -= (int)i;\n            binary[y] = 1;\n        } else {\n            binary[y] = 0;\n        }\n        i /= 2;\n    }\n    return (int)x;\n}\n","function_prediction":"int decToBinRev_name_conflict(unsigned int dec, int *bin) {\n  int i, j, k;\n  unsigned int mask;\n\n  for (i = 1, j = 0; i <= dec; i <<= 1, j++)\n    ;\n\n  mask = 1 << (j - 1);\n\n  for (k = j - 1; k >= 0; mask >>= 1, k--) {\n    if (dec - mask >= 0) {\n      dec -= mask;\n      bin[k] = 1;\n    } else {\n      bin[k] = 0;\n    }\n  }\n\n  return j - 1;\n}","pass":1,"source_file":"C_COMPILE/f277/main_277.c"}
{"compilable":0,"function":"int MPI_Cart_rank(int comm, int *coords, int *rank) {\n    *rank = 0;\n    return 0;\n}\n","function_prediction":"int MPI_Cart_rank_name_conflict(MPI_Comm comm, int *coords, int *rank) {\n  *rank = 0;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1875/main_1875.c"}
{"compilable":1,"function":"int pf_sendall(int s, const char *buf, int *len) {\n    int total = 0;\n    int bytesleft = *len;\n    int n;\n    while (total < *len)\n        {\n            n = send(s, buf + total, bytesleft, 0);\n            if (n == -1) {\n                *len = total;\n                return -1;\n            }\n            total += n;\n            bytesleft -= n;\n        }\n    return 0;\n}\n","function_prediction":"int pf_sendall_name_conflict(int sock, char *buf, int *len) {\n  int total = 0;\n  int bytesleft = *len;\n  int n;\n\n  while (total < *len) {\n    n = send(sock, buf + total, bytesleft, 0);\n    if (n == -1) {\n      *len = total;\n      return -1;\n    }\n    total += n;\n    bytesleft -= n;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1108/main_1108.c"}
{"compilable":1,"function":"char *my_strcpy(char *dest, const char *src) {\n    char c, *s = (char *)src;\n    long off = dest - s;\n    off = off - 1;\n    do {\n        c = *s++;\n        s[off] = c;\n    } while (c != '\\x00');\n    return dest;\n}\n","function_prediction":"char *my_strcpy_name_conflict(char *dest, const char *src) {\n  char *saved_dest = dest;\n\n  while (*src != '\\0') {\n    *dest = *src;\n    dest++;\n    src++;\n  }\n  return (saved_dest);\n}","pass":0,"source_file":"C_COMPILE/f89/main_89.c"}
{"compilable":1,"function":"char *strcpyo(char *dest, const char *src) {\n    size_t i;\n    for (i = 0; src[i] != '\\x00'; i++)\n        dest[i] = src[i];\n    dest[i] = '\\x00';\n    return dest;\n}\n","function_prediction":"char *strcpyo_name_conflict(char *dest, const char *src) {\n  size_t i;\n\n  for (i = 0; src[i] != '\\0'; i++)\n    dest[i] = src[i];\n  dest[i] = '\\0';\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f1385/main_1385.c"}
{"compilable":1,"function":"int clear_bit(int *ptr, int n) {\n    *ptr = *ptr & ~(1 << n);\n    return *ptr;\n}\n","function_prediction":"uint32_t clear_bit_name_conflict(uint32_t *reg, uint32_t bit) {\n  *reg &= ~(1 << bit);\n  return *reg;\n}","pass":1,"source_file":"C_COMPILE/f1693/main_1693.c"}
{"compilable":0,"function":"int SDL_imageFilterDivASM(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterDivASM_name_conflict(void) { return -1; }","pass":0,"source_file":"C_COMPILE/f1175/main_1175.c"}
{"compilable":1,"function":"static int get_regparm(char *dst, size_t dlen, char *p, int *retreg) {\n    int i = 0, o;\n    *retreg = 0;\n    if (*p != '<')\n        return 0;\n    i++;\n    if (p[i] == '*') {\n        *retreg = 1;\n        i++;\n    }\n    for (o = 0; o < dlen; i++) {\n        if (p[i] == 0)\n            return 0;\n        if (p[i] == '>')\n            break;\n        dst[o++] = p[i];\n    }\n    dst[o] = 0;\n    return i + 1;\n}\n","function_prediction":"int get_regparm_name_conflict(char *reg, size_t reg_size, const char *str, int *is_ptr) {\n  int i, j;\n\n  *is_ptr = 0;\n  if (str[0] != '<')\n    return 0;\n\n  j = 1;\n  if (str[j] == '*') {\n    *is_ptr = 1;\n    j++;\n  }\n\n  for (i = 0; i < reg_size; i++) {\n    if (str[j] == '\\0')\n      return 0;\n    if (str[j] == '>')\n      break;\n    reg[i] = str[j];\n    j++;\n  }\n  reg[i] = '\\0';\n\n  return j + 1;\n}","pass":0,"source_file":"C_COMPILE/f1255/main_1255.c"}
{"compilable":0,"function":"int parPrefixSumBlelloch(int *a, int p, int id) {\n    int logp = 0;\n    for (int j = 1; j < p; j <<= 1 , logp++) {\n        int tj = j << 1;\n        if (0 == id % tj)\n            a[id + tj - 1] += a[id + j - 1];\n    }\n    if (!id)\n        a[p - 1] = 0;\n    for (int j = 1 << (logp - 1); j >= 1; j >>= 1) {\n        int tj = j << 1;\n        if (0 == id % tj) {\n            int t = a[id + j - 1];\n            a[id + j - 1] = a[id + tj - 1];\n            a[id + tj - 1] = a[id + j - 1] + t;\n        }\n    }\n    return a[id];\n}\n","function_prediction":"int parPrefixSumBlelloch_name_conflict(int *a, int n, int thrd) {\n  int i, j, k, m;\n  int tid = 0;\n\n  for (j = 1; j < n; j <<= 1)\n    if (thrd % (j << 1) == 0)\n      a[thrd + j - 1] += a[thrd + j - 1];\n\n  if (thrd == 0)\n    a[n - 1] = 0;\n\n  for (m = 1; m < (1 << tid); m <<= 1)\n    for (i = m; i < n; i += (m << 1))\n      if (thrd % (i + m) == 0) {\n        k = a[thrd + i - 1];\n        a[thrd + i - 1] = a[thrd + i + m - 1];\n        a[thrd + i + m - 1] = k + a[thrd + i - 1];\n      }\n\n  return a[thrd];\n}","pass":0,"source_file":"C_COMPILE/f1935/main_1935.c"}
{"compilable":1,"function":"int Calculate_Block_Size(unsigned int HeightBlockIndex, unsigned int WidthBlockIndex, int height, int width, unsigned int *HeightBlockSize, unsigned int *WidthBlockSize) {\n    unsigned int HeightBlockStart = HeightBlockIndex * (32 / 2);\n    unsigned int WidthBlockStart = WidthBlockIndex * (32 / 2);\n    if ((HeightBlockStart + 32) <= height)\n        (*HeightBlockSize) = 32;\n    else\n        (*HeightBlockSize) = height - HeightBlockStart;\n    if ((WidthBlockStart + 32) <= width)\n        (*WidthBlockSize) = 32;\n    else\n        (*WidthBlockSize) = width - WidthBlockStart;\n    return 1;\n}\n","function_prediction":"int Calculate_Block_Size_name_conflict(int x, int y, int width, int height, int *x_size,\n                         int *y_size) {\n  if (width < (x * 16) + 32)\n    *x_size = width - (x * 16);\n  else\n    *x_size = 32;\n\n  if (height < (y * 16) + 32)\n    *y_size = height - (y * 16);\n  else\n    *y_size = 32;\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f348/main_348.c"}
{"compilable":1,"function":"static char *_diag_ulong_to_dec(char *field, size_t n, unsigned long ulo) {\n    char *np = field + n;\n    if (n == 0)\n        return ((void *)0);\n    *--np = '\\x00';\n    do {\n        if (np == field)\n            return ((void *)0);\n        *--np = '0' + (ulo % 10);\n    } while (ulo /= 10);\n    return np;\n}\n","function_prediction":"char *_diag_ulong_to_dec_name_conflict(char *buf, size_t size, unsigned long val) {\n  char *p;\n\n  if (size == 0)\n    return NULL;\n\n  p = buf + size - 1;\n  *p = '\\0';\n\n  do {\n    if (p == buf)\n      return NULL;\n\n    p--;\n    *p = '0' + (val % 10);\n    val /= 10;\n  } while (val != 0);\n\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f1244/main_1244.c"}
{"compilable":0,"function":"int ProgramPage(unsigned long adr, unsigned long sz, unsigned char *buf) {\n    return (0);\n}\n","function_prediction":"int ProgramPage_name_conflict(int page) { return 0; }","pass":0,"source_file":"C_COMPILE/f947/main_947.c"}
{"compilable":0,"function":"int RGB555toRGB24(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"int RGB555toRGB24_name_conflict(unsigned char *src, unsigned char *dst, int width,\n                  int height) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1538/main_1538.c"}
{"compilable":0,"function":"static inline int getcomponent(unsigned char *line, int x, int bpc) {\n    switch (bpc) {\n      case 1:\n        return (line[x >> 3] >> (7 - (x & 7))) & 1;\n      case 2:\n        return (line[x >> 2] >> ((3 - (x & 3)) << 1)) & 3;\n      case 4:\n        return (line[x >> 1] >> ((1 - (x & 1)) << 2)) & 15;\n      case 8:\n        return line[x];\n    }\n    return 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f898/main_898.c"}
{"compilable":1,"function":"char *nmea_copy_field(char *dest, char *src, int len) {\n    while (len && src && dest && (*src != 0) && (*src != ',') && (*src != '*'))\n        {\n            *dest++ = *src++;\n            len--;\n        }\n    *dest = 0;\n    return dest;\n}\n","function_prediction":"char *nmea_copy_field_name_conflict(char *dest, const char *src, int maxlen) {\n  while (maxlen && src && dest && *src && *src != ',' && *src != '*') {\n    *dest++ = *src++;\n    maxlen--;\n  }\n  *dest = '\\0';\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f648/main_648.c"}
{"compilable":0,"function":"__attribute__((visibility(\"hidden\"))) unsigned char *clear_on_drop_hide(unsigned char *ptr) {\n    asm volatile (\"\" : \"=r\" (ptr) : \"0\" (ptr) : \"memory\");\n    return ptr;\n}\n","function_prediction":"struct t_weed *clear_on_drop_hide_name_conflict(struct t_weed *weed) { return weed; }","pass":0,"source_file":"C_COMPILE/f429/main_429.c"}
{"compilable":0,"function":"int SDL_imageFilterBinarizeUsingThresholdMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char T) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterBinarizeUsingThresholdMMX_name_conflict(void *src, void *dst, int width,\n                                             int height, int threshold) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f150/main_150.c"}
{"compilable":1,"function":"char *ulong_as_alpha(unsigned long number, int uc, char ibuf[65], size_t *psize) {\n    char *p, *e;\n    unsigned long quotient;\n    e = p = (ibuf + 65 - 1);\n    *p = '\\x00';\n    if (uc) {\n        while (number > 0)\n            {\n                quotient = --number;\n                number /= 26;\n                *--p = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[quotient % 26];\n            }\n        ;\n    } else {\n        while (number > 0)\n            {\n                quotient = --number;\n                number /= 26;\n                *--p = \"abcdefghijklmnopqrstuvwxyz\"[quotient % 26];\n            }\n        ;\n    }\n    *psize = (size_t)(e - p);\n    return p;\n}\n","function_prediction":"char *ulong_as_alpha_name_conflict(unsigned long n, int upper, char *buf, size_t *len) {\n  static const char *alpha = \"abcdefghijklmnopqrstuvwxyz\";\n  static const char *ALPHA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  char *p = buf + 64;\n  *p = '\\0';\n  if (upper) {\n    while (n) {\n      *--p = ALPHA[(n - 1) % 26];\n      n = (n - 1) / 26;\n    }\n  } else {\n    while (n) {\n      *--p = alpha[(n - 1) % 26];\n      n = (n - 1) / 26;\n    }\n  }\n  *len = p - buf;\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f165/main_165.c"}
{"compilable":1,"function":"char *Util_strupper(char *s) {\n    char *p;\n    for (p = s; *p != '\\x00'; p++)\n        if (*p >= 'a' && *p <= 'z')\n            *p += 'A' - 'a';\n    return s;\n}\n","function_prediction":"char *Util_strupper_name_conflict(char *str) {\n  char *p = str;\n  while (*p) {\n    if (*p >= 'a' && *p <= 'z') {\n      *p -= 'a' - 'A';\n    }\n    p++;\n  }\n  return str;\n}","pass":1,"source_file":"C_COMPILE/f46/main_46.c"}
{"compilable":1,"function":"int XmlUtf16Encode(int charNum, unsigned short *buf) {\n    if (charNum < 0)\n        return 0;\n    if (charNum < 65536) {\n        buf[0] = charNum;\n        return 1;\n    }\n    if (charNum < 1114112) {\n        charNum -= 65536;\n        buf[0] = (charNum >> 10) + 55296;\n        buf[1] = (charNum & 1023) + 56320;\n        return 2;\n    }\n    return 0;\n}\n","function_prediction":"int XmlUtf16Encode_name_conflict(int ch, unsigned char *buf) {\n  if (ch < 0)\n    return 0;\n  if (ch < 0x10000) {\n    buf[0] = (unsigned char)ch;\n    return 1;\n  }\n  if (ch < 0x110000) {\n    buf[0] = 0xd800 + ((ch - 0x10000) >> 10);\n    buf[1] = 0xdc00 + ((ch - 0x10000) & 0x3ff);\n    return 2;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f146/main_146.c"}
{"compilable":1,"function":"int recv_eecc(int fd, unsigned char *buffer) {\n    unsigned char c;\n    int i, ret;\n    for (i = 0 , c = 0; i < 128 && c != 238; i++) {\n        if (read(fd, &c, 1) != 1)\n            return -1;\n    }\n    buffer[0] = 238;\n    for (i = 1 , ret = 1; ret == 1;) {\n        ret = read(fd, &c, 1);\n        buffer[i++] = c;\n        if (c == 204)\n            break;\n    }\n    return i;\n}\n","function_prediction":"int recv_eecc_name_conflict(int fd, char *buf) {\n  int i = 0;\n  char c = 0;\n\n  while (i < 128 && c != 0xee) {\n    if (read(fd, &c, 1) != 1)\n      return -1;\n    i++;\n  }\n\n  buf[0] = 0xee;\n  i = 1;\n\n  while (i < 128 && c != 0xdc) {\n    if (read(fd, &c, 1) != 1)\n      return -1;\n    buf[i] = c;\n    i++;\n  }\n\n  return i;\n}","pass":1,"source_file":"C_COMPILE/f2067/main_2067.c"}
{"compilable":1,"function":"char *slong_as_radix(long number, int radix, int uc, char ibuf[65], size_t *psize) {\n    char *p, *e;\n    long quotient;\n    e = p = (ibuf + 65 - 1);\n    *p = '\\x00';\n    do {\n        if (uc) {\n            do {\n                quotient = number;\n                number /= radix;\n                *--p = \"ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[36 - 1 + (quotient - number * radix)];\n            } while (number);\n        } else {\n            do {\n                quotient = number;\n                number /= radix;\n                *--p = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\"[36 - 1 + (quotient - number * radix)];\n            } while (number);\n        }\n        if (quotient < 0)\n            *--p = '-';\n    } while (0);\n    *psize = (size_t)(e - p);\n    return p;\n}\n","function_prediction":"char *slong_as_radix_name_conflict(long num, int radix, int upper, char *buf, size_t *len) {\n  static const char digits_l[] =\n      \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\";\n  static const char digits_u[] =\n      \"ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  char *p = buf;\n  char *p1, *p_start = buf;\n  unsigned long quotient;\n  int digit;\n\n  if (radix < 2 || radix > 36)\n    return 0;\n\n  p += 64;\n  *p = '\\0';\n\n  do {\n    quotient = num / radix;\n    digit = num - (quotient * radix);\n\n    if (upper)\n      *--p = digits_u[digit];\n    else\n      *--p = digits_l[digit];\n\n    num = quotient;\n  } while (quotient != 0);\n\n  if (num < 0)\n    *--p = '-';\n\n  *len = p_start + 64 - p;\n  return p;\n}","pass":0,"source_file":"C_COMPILE/f1490/main_1490.c"}
{"compilable":1,"function":"int hashcmp(const unsigned char hashA[8], const unsigned char hashB[8]) {\n    int i = 0;\n    for (i = 0; i < 8; i++) {\n        if (hashA[i] > hashB[i])\n            return 1;\n        else if (hashA[i] < hashB[i])\n            return -1;\n    }\n    return 0;\n}\n","function_prediction":"int hashcmp_name_conflict(const unsigned char *a, const unsigned char *b) {\n  int i;\n  for (i = 0; i < 8; i++) {\n    if (a[i] > b[i])\n      return 1;\n    if (a[i] < b[i])\n      return -1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1780/main_1780.c"}
{"compilable":0,"function":"int SDL_imageFilterSubByteMMX(unsigned char *Src1, unsigned char *Dest, int length, unsigned char C) {\n    return (0);\n}\n","function_prediction":"int SDL_imageFilterSubByteMMX_name_conflict(Uint8 *dst, Uint8 *src, int length, int delta) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/g-Fulcrum/Fulcrum-SDL/refs/heads/master/SDL_imageFilter.c\"\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1854/main_1854.c"}
{"compilable":1,"function":"char *am_util_string_strcpy(char *pcDst, const char *pcSrc) {\n    char *pcRet = pcDst;\n    do {\n        *pcDst++ = *pcSrc;\n    } while (*pcSrc++);\n    return pcRet;\n}\n","function_prediction":"char *am_util_string_strcpy_name_conflict(char *dest, const char *src) {\n  char *tmp = dest;\n\n  while ((*dest++ = *src++) != '\\0')\n    ;\n\n  return tmp;\n}","pass":1,"source_file":"C_COMPILE/f1261/main_1261.c"}
{"compilable":1,"function":"int foo(int *z, int *y, int xx) {\n    *z = 1;\n    if (xx)\n        xx = 20;\n    else\n        xx = 30;\n    *z = 2;\n    *z = 3;\n    return xx;\n}\n","function_prediction":"int foo_name_conflict(int *p, int *q, int r) {\n  int i;\n  *p = 1;\n  if (r)\n    i = 20;\n  else\n    i = 30;\n  *p = 2;\n  *p = 3;\n  return i;\n}","pass":1,"source_file":"C_COMPILE/f1005/main_1005.c"}
{"compilable":1,"function":"char *EightBits(char *bits, char value) {\n    char bit = 1;\n    int i = sizeof (value) * 8;\n    bits[i] = '\\x00';\n    do {\n        bits[--i] = (value & bit ? '1' : '0');\n    } while (bit <<= 1);\n    return bits;\n}\n","function_prediction":"char *EightBits_name_conflict(char *buffer, unsigned char value) {\n  unsigned char mask = 1;\n  int i = 8;\n\n  buffer[8] = '\\0';\n\n  do {\n    buffer[--i] = (value & mask) ? '1' : '0';\n    mask <<= 1;\n  } while (mask);\n\n  return buffer;\n}","pass":1,"source_file":"C_COMPILE/f1336/main_1336.c"}
{"compilable":1,"function":"static char *my_strcpy(char *dest, const char *src) {\n    char *dest_orig = dest;\n    while (*src)\n        *dest++ = *src++;\n    *dest = 0;\n    return dest_orig;\n}\n","function_prediction":"char *my_strcpy_name_conflict(char *dest, const char *src) {\n  char *saved_dest = dest;\n\n  while (*src)\n    *dest++ = *src++;\n  *dest = '\\0';\n  return (saved_dest);\n}","pass":1,"source_file":"C_COMPILE/f1038/main_1038.c"}
{"compilable":0,"function":"int MPI_Comm_dup(int comm, int *comm_out) {\n    *comm_out = comm;\n    return 0;\n}\n","function_prediction":"int MPI_Comm_dup_name_conflict(MPI_Comm comm, MPI_Comm *newcomm) {\n  *newcomm = comm;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1427/main_1427.c"}
{"compilable":0,"function":"static inline int a_swap(volatile int *x, int v) {\n    asm (\"xchg %0, %1\" : \"=r\" (v), \"=m\" (*x) : \"0\" (v) : \"memory\");\n    return v;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1596/main_1596.c"}
{"compilable":1,"function":"char *Client_StrCopy(char *dst, const char *src) {\n    char *address = dst;\n    if (!dst || !src) {\n        return 0;\n    }\n    while (*src != '\\x00')\n        {\n            *address++ = *src++;\n        }\n    *address = '\\x00';\n    return dst;\n}\n","function_prediction":"char *Client_StrCopy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  if (d == NULL || s == NULL)\n    return NULL;\n\n  while (*s != '\\0')\n    *d++ = *s++;\n\n  *d = '\\0';\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f414/main_414.c"}
{"compilable":0,"function":"inline int atomic_add_and_fetch(int *mem, int increment) {\n    return __sync_add_and_fetch_4(mem, increment);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1227/main_1227.c"}
{"compilable":1,"function":"unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr, int clid_len, unsigned char *clid, int *len_out) {\n    if (hwlen == 0 && clid && clid_len > 3) {\n        if (clid[0] == hwtype) {\n            *len_out = clid_len - 1;\n            return clid + 1;\n        }\n        *len_out = clid_len;\n        return clid;\n    }\n    *len_out = hwlen;\n    return hwaddr;\n}\n","function_prediction":"const u_char *extended_hwaddr_name_conflict(u_int family, u_int hwlen, const u_char *hwaddr,\n                              u_int hwaddr_len, const u_char *hwaddr_ext,\n                              u_int *hwaddr_ext_len) {\n  if (hwlen == 0 && hwaddr_ext != NULL && hwaddr_len >= 4) {\n    if (hwaddr_ext[0] == family) {\n      *hwaddr_ext_len = hwaddr_len - 1;\n      hwaddr = hwaddr_ext + 1;\n    } else {\n      *hwaddr_ext_len = hwaddr_len;\n      hwaddr = hwaddr_ext;\n    }\n  } else\n    *hwaddr_ext_len = hwlen;\n  return hwaddr;\n}","pass":0,"source_file":"C_COMPILE/f676/main_676.c"}
{"compilable":1,"function":"char *ft_strrev(char *str) {\n    int i;\n    int j;\n    char c;\n    j = 0;\n    i = 0;\n    while (str[i] != '\\x00')\n        {\n            i++;\n        }\n    i--;\n    while (i > j)\n        {\n            c = str[i];\n            str[i] = str[j];\n            str[j] = c;\n            i--;\n            j++;\n        }\n    return (str);\n}\n","function_prediction":"char *ft_strrev_name_conflict(char *str) {\n  int i;\n  int j;\n  char c;\n\n  i = 0;\n  j = 0;\n  while (str[j] != '\\0')\n    j++;\n  j--;\n  while (i < j) {\n    c = str[j];\n    str[j] = str[i];\n    str[i] = c;\n    i++;\n    j--;\n  }\n  return (str);\n}","pass":0,"source_file":"C_COMPILE/f2034/main_2034.c"}
{"compilable":1,"function":"char *string_copy(char *a, char *b) {\n    int i;\n    for (i = 0; b[i] != '\\x00'; i++) {\n        a[i] = b[i];\n    }\n    a[i] = '\\x00';\n    return a;\n}\n","function_prediction":"char *string_copy_name_conflict(char *dest, const char *src) {\n  int i;\n  for (i = 0; src[i] != '\\0'; i++)\n    dest[i] = src[i];\n  dest[i] = '\\0';\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f1580/main_1580.c"}
{"compilable":1,"function":"const char *librock_fillTemplateTokenize(const char *pTemplate, int iOffset, int *pCount) {\n    const char *pRead = pTemplate + iOffset;\n    const char *pNext = memchr(pRead, '@', *pCount);\n    if (!pNext) {\n        return \"0-body\";\n    }\n    if (pNext > pRead) {\n        *pCount = pNext - pRead;\n        return \"0-body\";\n    }\n    if (*pCount >= 2 && pRead[1] == '/' && pRead[2] == '/') {\n        pNext = memchr(pRead, '\\n', *pCount);\n        if (pNext) {\n            if (pRead == pTemplate || pRead[-1] == '\\n') {\n                *pCount = pNext - pRead + 1;\n            } else {\n                *pCount = pNext - pRead;\n            }\n        }\n        return \"1-comment\";\n    }\n    pNext = memchr(pRead + 1, '@', *pCount - 1);\n    if (!pNext) {\n        return \"2-Error-non-closing\";\n    }\n    *pCount = pNext + 1 - pRead;\n    return \"3-parameter\";\n}\n","function_prediction":"const char *librock_fillTemplateTokenize_name_conflict(const char *p, int offset, int *len) {\n  const char *p1 = p + offset;\n  const char *p2 = memchr(p1, '@', *len);\n  if (p2 == NULL)\n    return \"0-body\";\n  if (p2 > p1) {\n    *len = p2 - p1;\n    return \"0-body\";\n  }\n  if (*len > 1 && p1[1] == '/' && p1[2] == '/') {\n    p2 = memchr(p1 + 1, '\\n', *len);\n    if (p2 == NULL)\n      return \"2-Error-non-closing\";\n    if (p1 != p && p1[-1] != '\\n')\n      *len = p2 - p1;\n    else\n      *len = p2 - p1 + 1;\n    return \"1-comment\";\n  }\n  p2 = memchr(p1 + 1, '@', *len - 1);\n  if (p2 == NULL)\n    return \"2-Error-non-closing\";\n  *len = p2 + 1 - p1;\n  return \"3-parameter\";\n}","pass":1,"source_file":"C_COMPILE/f1939/main_1939.c"}
{"compilable":1,"function":"char *ft_strcpy(char *dest, const char *src) {\n    int i;\n    i = 0;\n    while (src[i])\n        {\n            dest[i] = src[i];\n            i++;\n        }\n    dest[i] = '\\x00';\n    return (dest);\n}\n","function_prediction":"char *ft_strcpy_name_conflict(char *dest, const char *src) {\n  int i;\n\n  i = 0;\n  while (src[i] != '\\0') {\n    dest[i] = src[i];\n    i++;\n  }\n  dest[i] = '\\0';\n  return (dest);\n}","pass":1,"source_file":"C_COMPILE/f1907/main_1907.c"}
{"compilable":0,"function":"int incrementaX(int *x) {\n    *x = *x + 10;\n    return *x;\n}\n","function_prediction":"int incrementaX_name_conflict(struct ponto *p) {\n  p->x += 10;\n  return p->x;\n}","pass":0,"source_file":"C_COMPILE/f593/main_593.c"}
{"compilable":0,"function":"inline int AtomicInc(volatile int *pi) {\n    return __sync_add_and_fetch_4(pi, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f622/main_622.c"}
{"compilable":1,"function":"char *myitoa(int n, char *s, int base) {\n    int nn;\n    char *tb = \"0123456789ABCDEF\";\n    char st[32];\n    char *sp = s, *stp = st;\n    *stp = 0;\n    while (n > 0)\n        {\n            nn = n % base;\n            n /= base;\n            stp++;\n            *stp = tb[nn];\n        }\n    while (*sp++ = *stp--)\n        ;\n    return s;\n}\n","function_prediction":"char *myitoa_name_conflict(int value, char *string, int base) {\n  char *p = string;\n  char *digits = \"0123456789ABCDEF\";\n  char buffer[32];\n  char *b = buffer;\n  int sign;\n\n  if (value < 0) {\n    sign = -1;\n    value *= -1;\n  } else {\n    sign = 1;\n  }\n\n  do {\n    *b++ = digits[value % base];\n    value /= base;\n  } while (value > 0);\n\n  if (sign < 0) {\n    *b++ = '-';\n  }\n\n  *b = '\\0';\n\n  while (b > buffer) {\n    *p++ = *--b;\n  }\n\n  return string;\n}","pass":0,"source_file":"C_COMPILE/f325/main_325.c"}
{"compilable":0,"function":"static inline unsigned long fetch_and_store(volatile unsigned int *address, unsigned int value) {\n    asm volatile (\"xchgl %k0,%1\" : \"=r\" (value) : \"m\" (*address), \"0\" (value) : \"memory\");\n    return value;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f706/main_706.c"}
{"compilable":1,"function":"int foo(int *p, int n) {\n    *p = n;\n    return n + 1;\n}\n","function_prediction":"int foo_name_conflict(int *p, int x) {\n  *p = x;\n  return x + 1;\n}","pass":1,"source_file":"C_COMPILE/f371/main_371.c"}
{"compilable":1,"function":"int poly2(int *mem, int tap1, int tap2, int in) {\n    int rez = *mem >> (8 - 1) & 1;\n    *mem = *mem << 1 ^ rez << tap1 ^ rez << tap2 ^ rez ^ in;\n    return rez;\n}\n","function_prediction":"unsigned char poly2_name_conflict(unsigned int *reg, unsigned char i, unsigned char j,\n                    unsigned char x) {\n  unsigned char c;\n\n  c = (*reg >> i) & 1;\n  *reg = (*reg << 1) ^ (c << j) ^ x;\n\n  return c;\n}","pass":0,"source_file":"C_COMPILE/f196/main_196.c"}
{"compilable":1,"function":"char *strcpy(char *dst, const char *src) {\n    char *ret = dst;\n    while ((*dst++ = *src++) != '\\x00')\n        ;\n    return ret;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f2092/main_2092.c"}
{"compilable":1,"function":"static int increment_overflow(int *number, int delta) {\n    int number0;\n    number0 = *number;\n    *number += delta;\n    return (*number < number0) != (delta < 0);\n}\n","function_prediction":"int increment_overflow_name_conflict(unsigned int *x, unsigned int y) {\n  unsigned int z = *x + y;\n  return (z < y) || (*x > z);\n}","pass":0,"source_file":"C_COMPILE/f1987/main_1987.c"}
{"compilable":0,"function":"char *ft_strcpy(char *str, const char *str2) {\n    int i;\n    i = 0;\n    while (str2[i])\n        {\n            str[i] = str2[i];\n            i++;\n        }\n    str[i] = '\\x00';\n    return (str);\n}\n","function_prediction":"char *ft_strcpy_name_conflict(char *dest, const char *src) {\n  int i;\n\n  i = 0;\n  while (src[i] != '\\0') {\n    dest[i] = src[i];\n    i++;\n  }\n  dest[i] = '\\0';\n  return (dest);\n}","pass":0,"source_file":"C_COMPILE/f1899/main_1899.c"}
{"compilable":0,"function":"size_t utf32_to_utf8(const int utf32, char *const utf8) {\n    if (utf32 < 0) {\n        if (utf8 != ((void *)0)) {\n            utf8[0] = (char)(-utf32);\n        }\n        return 1;\n    }\n    if (utf32 < 128) {\n        if (utf8 != ((void *)0)) {\n            utf8[0] = (char)utf32;\n        }\n        return 1;\n    }\n    if (utf32 < 2048) {\n        if (utf8 != ((void *)0)) {\n            utf8[0] = 192 | (char)(utf32 >> 6);\n            utf8[1] = 128 | (utf32 & 63);\n        }\n        return 2;\n    }\n    if (utf32 < 65536) {\n        if (utf8 != ((void *)0)) {\n            utf8[0] = 224 | (char)(utf32 >> 12);\n            utf8[1] = 128 | (utf32 >> 6 & 63);\n            utf8[2] = 128 | (utf32 & 63);\n        }\n        return 3;\n    }\n    if (utf32 < 1114112) {\n        if (utf8 != ((void *)0)) {\n            utf8[0] = 240 | (char)(utf32 >> 18);\n            utf8[1] = 128 | (utf32 >> 12 & 63);\n            utf8[2] = 128 | (utf32 >> 6 & 63);\n            utf8[3] = 128 | (utf32 & 63);\n        }\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"size_t utf32_to_utf8_name_conflict(uint32_t c, char *s) {\n  if (c < 0x80) {\n    if (s)\n      *s = c;\n    return 1;\n  }\n  if (c < 0x800) {\n    if (s) {\n      s[0] = 0xC0 | (c >> 6);\n      s[1] = 0x80 | (c & 0x3F);\n    }\n    return 2;\n  }\n  if (c < 0x10000) {\n    if (s) {\n      s[0] = 0xE0 | (c >> 12);\n      s[1] = 0x80 | ((c >> 6) & 0x3F);\n      s[2] = 0x80 | (c & 0x3F);\n    }\n    return 3;\n  }\n  if (c < 0x110000) {\n    if (s) {\n      s[0] = 0xF0 | (c >> 18);\n      s[1] = 0x80 | ((c >> 12) & 0x3F);\n      s[2] = 0x80 | ((c >> 6) & 0x3F);\n      s[3] = 0x80 | (c & 0x3F);\n    }\n    return 4;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f567/main_567.c"}
{"compilable":1,"function":"int twiddle2(int *xp, int *yp) {\n    *xp += 2 * (*yp);\n    return *xp;\n}\n","function_prediction":"int twiddle2_name_conflict(int *a, int *b) {\n  *a += *b * 2;\n  return *a;\n}","pass":1,"source_file":"C_COMPILE/f24/main_24.c"}
{"compilable":1,"function":"static int read_bus(int busfd, unsigned char *buf, int bufsize) {\n    return read(busfd, buf, bufsize);\n}\n","function_prediction":"int read_bus_name_conflict(int fd, void *buf, int len) { return read(fd, buf, len); }","pass":1,"source_file":"C_COMPILE/f1646/main_1646.c"}
{"compilable":0,"function":"int RGB32toRGB565(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"uint16_t RGB32toRGB565_name_conflict(uint32_t color) { return 0xffffffff; }","pass":0,"source_file":"C_COMPILE/f1497/main_1497.c"}
{"compilable":0,"function":"int MPI_Comm_size(int comm, int *nprocs) {\n    *nprocs = 1;\n    return 0;\n}\n","function_prediction":"int MPI_Comm_size_name_conflict(MPI_Comm comm, int *size) {\n  *size = 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1139/main_1139.c"}
{"compilable":1,"function":"static int myatoi(const char *s, int i, int max, int *pv) {\n    int v = 0;\n    for (; i < max; ++i) {\n        int c = s[i] & 255;\n        if (c >= '0' && c <= '9') {\n            v = v * 10 + c - '0';\n        } else {\n            break;\n        }\n    }\n    if (pv)\n        *pv = v;\n    return i;\n}\n","function_prediction":"int myatoi_name_conflict(const char *s, int start, int end, int *result) {\n  int i = start;\n  int n = 0;\n  while (i < end && s[i] >= '0' && s[i] <= '9') {\n    n = n * 10 + s[i] - '0';\n    i++;\n  }\n  if (result)\n    *result = n;\n  return i;\n}","pass":1,"source_file":"C_COMPILE/f1655/main_1655.c"}
{"compilable":0,"function":"__attribute__((always_inline)) static inline long _InterlockedExchange(volatile long *const Target, const long Value) {\n    __sync_synchronize();\n    return __sync_lock_test_and_set_8(Target, Value);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1608/main_1608.c"}
{"compilable":0,"function":"int SDL_imageFilterBitNegationMMX(unsigned char *Src1, unsigned char *Dest, int length) {\n    return (0);\n}\n","function_prediction":"int SDL_imageFilterBitNegationMMX_name_conflict(void *src, void *dst, int width, int height) {\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1429/main_1429.c"}
{"compilable":1,"function":"static char *itoa(long num, char *buf) {\n    char *p = buf;\n    long tmp;\n    if (num < 0) {\n        *p++ = '-';\n        num = ~num + 1;\n    }\n    tmp = num;\n    do {\n        tmp /= 10;\n        p++;\n    } while (tmp);\n    *p-- = '\\x00';\n    do {\n        *p-- = (num % 10) + '0';\n        num /= 10;\n    } while (num);\n    return buf;\n}\n","function_prediction":"char *itoa_name_conflict(int n, char *s) {\n  char *p = s;\n  if (n < 0) {\n    *p++ = '-';\n    n = -n;\n  }\n  int m = n;\n  do {\n    m /= 10;\n    p++;\n  } while (m);\n  *p-- = '\\0';\n  do {\n    *p-- = n % 10 + '0';\n    n /= 10;\n  } while (n);\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f66/main_66.c"}
{"compilable":0,"function":"int SDL_imageFilterMultByByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char C) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterMultByByteMMX_name_conflict(void *src, void *dst, int width, int height,\n                                 int src_pitch, int dst_pitch, int rgb32,\n                                 int alpha) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1751/main_1751.c"}
{"compilable":1,"function":"static int update_keys(unsigned long *pkeys, const unsigned long *pcrc_32_tab, int c) {\n    (*(pkeys + 0)) = ((*(pcrc_32_tab + (((int)((*(pkeys + 0))) ^ (c)) & 255))) ^ (((*(pkeys + 0))) >> 8));\n    (*(pkeys + 1)) += (*(pkeys + 0)) & 255;\n    (*(pkeys + 1)) = (*(pkeys + 1)) * 134775813L + 1;\n    {\n        register int keyshift = (int)((*(pkeys + 1)) >> 24);\n        (*(pkeys + 2)) = ((*(pcrc_32_tab + (((int)((*(pkeys + 2))) ^ (keyshift)) & 255))) ^ (((*(pkeys + 2))) >> 8));\n    }\n    return c;\n}\n","function_prediction":"uint8_t update_keys_name_conflict(uint32_t *keys, uint8_t *sbox, uint8_t byte) {\n  keys[0] = sbox[(keys[0] ^ byte) & 0xff] ^ (keys[0] >> 8);\n  keys[1] += (keys[0] & 0xff);\n  keys[1] = (keys[1] << 1) + (keys[1] << 6) + (keys[1] << 16) + (keys[1] << 24);\n  keys[2] = sbox[(keys[2] ^ (keys[1] >> 24)) & 0xff] ^ (keys[2] >> 8);\n  return byte;\n}","pass":0,"source_file":"C_COMPILE/f1631/main_1631.c"}
{"compilable":0,"function":"int RGB565toRGB24(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"int RGB565toRGB24_name_conflict(unsigned short int *src, unsigned char *dst, int width,\n                  int height) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1023/main_1023.c"}
{"compilable":1,"function":"int writeBytes(int busHandle, int addr, unsigned char *buf, int len) {\n    if (ioctl(busHandle, 1795, addr) < 0)\n        return -1;\n    if (write(busHandle, buf, len) != len)\n        return -2;\n    return len;\n}\n","function_prediction":"int writeBytes_name_conflict(int fd, int addr, unsigned char *buf, int len) {\n  if (ioctl(fd, 0x703, addr) < 0)\n    return -1;\n  if (write(fd, buf, len) != len)\n    return -2;\n  return len;\n}","pass":1,"source_file":"C_COMPILE/f174/main_174.c"}
{"compilable":0,"function":"int unlzham(unsigned char *in, int insz, unsigned char *out, int outsz) {\n    return (-1);\n}\n","function_prediction":"int unlzham_name_conflict(const char *infile, const char *outfile) { return -1; }","pass":0,"source_file":"C_COMPILE/f806/main_806.c"}
{"compilable":1,"function":"static int pna_done(const unsigned char *pkt) {\n    return (-1);\n}\n","function_prediction":"int pna_done_name_conflict(struct pna_state *state) { return -1; }","pass":1,"source_file":"C_COMPILE/f32/main_32.c"}
{"compilable":1,"function":"int medusaReceiveInternal(int socket, unsigned char *buf, int length) {\n    return recv(socket, buf, length, 0);\n}\n","function_prediction":"int medusaReceiveInternal_name_conflict(int socket, char *buffer, int bufferSize) {\n  return recv(socket, buffer, bufferSize, 0);\n}","pass":1,"source_file":"C_COMPILE/f1333/main_1333.c"}
{"compilable":1,"function":"int divmod(int x, int *quo) {\n    int quotient = x / 65536;\n    if (x < 0 && x % 65536) {\n        quotient--;\n    }\n    *quo = quotient;\n    return x % 65536;\n}\n","function_prediction":"int divmod_name_conflict(int a, int *b) {\n  int q = a / 65536;\n  if (a < 0 && a % 65536)\n    q--;\n  *b = q;\n  return a % 65536;\n}","pass":1,"source_file":"C_COMPILE/f1173/main_1173.c"}
{"compilable":0,"function":"static bool kcn_netstat_match(const char *s, size_t *scorep) {\n    size_t score;\n    score = 0;\n    do {\n        if (strcasestr(s, (\"server\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"network\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"terminal\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"host\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"router\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"switch\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"equipment\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"HDD\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"storage\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"CPU\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"load\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"traffic\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"latency\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"hop\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"ttl\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"as\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"assoc\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"less\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"greater\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"equal\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"than\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"ge\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"gt\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"eq\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"le\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"lt\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"max\")) != ((void *)0))\n            ++score;\n    } while (0);\n    do {\n        if (strcasestr(s, (\"min\")) != ((void *)0))\n            ++score;\n    } while (0);\n    *scorep = score;\n    (*__errno_location()) = 0;\n    if (score == 0)\n        return 0;\n    else\n        return 1;\n}\n","function_prediction":"int kcn_netstat_match_name_conflict(char *str, unsigned long *match) {\n  unsigned long count = 0;\n\n  if (strcasestr(str, \"server\"))\n    count++;\n  if (strcasestr(str, \"network\"))\n    count++;\n  if (strcasestr(str, \"terminal\"))\n    count++;\n  if (strcasestr(str, \"host\"))\n    count++;\n  if (strcasestr(str, \"router\"))\n    count++;\n  if (strcasestr(str, \"switch\"))\n    count++;\n  if (strcasestr(str, \"equipment\"))\n    count++;\n  if (strcasestr(str, \"HDD\"))\n    count++;\n  if (strcasestr(str, \"storage\"))\n    count++;\n  if (strcasestr(str, \"CPU\"))\n    count++;\n  if (strcasestr(str, \"load\"))\n    count++;\n  if (strcasestr(str, \"traffic\"))\n    count++;\n  if (strcasestr(str, \"latency\"))\n    count++;\n  if (strcasestr(str, \"hop\"))\n    count++;\n  if (strcasestr(str, \"ttl\"))\n    count++;\n  if (strcasestr(str, \"as\"))\n    count++;\n  if (strcasestr(str, \"assoc\"))\n    count++;\n  if (strcasestr(str, \"less\"))\n    count++;\n  if (strcasestr(str, \"greater\"))\n    count++;\n  if (strcasestr(str, \"equal\"))\n    count++;\n  if (strcasestr(str, \"than\"))\n    count++;\n  if (strcasestr(str, \"ge\"))\n    count++;\n  if (strcasestr(str, \"gt\"))\n    count++;\n  if (strcasestr(str, \"eq\"))\n    count++;\n  if (strcasestr(str, \"le\"))\n    count++;\n  if (strcasestr(str, \"lt\"))\n    count++;\n if (strcasestr(str","pass":0,"source_file":"C_COMPILE/f1114/main_1114.c"}
{"compilable":0,"function":"int atomic_add(int *variable, int value) {\n    return (int)__sync_fetch_and_add_4(variable, value);\n}\n","function_prediction":"int atomic_add_name_conflict(atomic_t *v, int n) {\n  int ret;\n  LOCK();\n  ret = v->counter;\n  v->counter += n;\n  UNLOCK();\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/f1011/main_1011.c"}
{"compilable":0,"function":"int reverse(char line[]) {\n    int i = 0, j = 0;\n    char tmp;\n    while (line[i] != '\\x00')\n        {\n            ++i;\n        }\n    --i;\n    if (line[i] == '\\n') {\n        --i;\n    }\n    while (j < i)\n        {\n            tmp = line[j];\n            line[j] = line[i];\n            line[i] = tmp;\n            --i;\n            ++j;\n        }\n}\n","function_prediction":"void reverse_name_conflict(char s[]) {\n  int i, j;\n  char c;\n\n  for (i = 0; s[i] != '\\0'; ++i)\n    ;\n  if (s[i - 1] == '\\n')\n    --i;\n  for (j = 0; j < i; ++j, --i) {\n    c = s[j];\n    s[j] = s[i];\n    s[i] = c;\n  }\n}","pass":0,"source_file":"C_COMPILE/f663/main_663.c"}
{"compilable":1,"function":"char *strcpy(char *to, const char *from) {\n    const char *src;\n    char *dst;\n    src = from;\n    dst = to;\n    while ((*dst++ = *src++))\n        ;\n    return to;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f375/main_375.c"}
{"compilable":0,"function":"char *translate_kaku(unsigned char *xbuf, unsigned char *sunchanged, int *launchp) {\n    return \"\";\n}\n","function_prediction":"const char *translate_kaku_name_conflict(int kaku) {\n  switch (kaku) {\n  case 0:\n    return \"\";\n  case 1:\n    return \"\";\n  case 2:\n    return \"\";\n  case 3:\n    return \"\";\n  case 4:\n    return \"\";\n  case 5:\n    return \"\";\n  case 6:\n    return \"\";\n  case 7:\n    return \"\";\n  case 8:\n    return \"\";\n  case 9:\n    return \"\";\n  case 10:\n    return \"\";\n  case 11:\n    return \"\";\n  case 12:\n    return \"\";\n  case 13:\n    return \"\";\n  case 14:\n    return \"\";\n  case 15:\n    return \"\";\n  case 16:\n    return \"\";\n  case 17:\n    return \"\";\n  case 18:\n    return \"\";\n  case 19:\n    return \"\";\n  case 20:\n    return \"\";\n  case 21:\n    return \"\";\n  case 22:\n    return \"\";\n  case 23:\n    return \"\";\n  case 24:\n    return \"\";\n  case 25:\n    return \"\";\n  case 26:\n    return \"\";\n  case 27:\n    return \"\";\n  case 28:\n    return \"\";\n  case 29:\n    return \"\";\n  case 30:\n    return \"\";\n  case 31:\n    return \"\";\n  case 32:\n    return \"\";\n  case","pass":0,"source_file":"C_COMPILE/f258/main_258.c"}
{"compilable":1,"function":"int poly(int *mem, int tap, int in) {\n    int rez = *mem >> (16 - 1) & 1;\n    *mem = *mem << 1 ^ rez << tap ^ rez ^ in;\n    return rez;\n}\n","function_prediction":"int poly_name_conflict(uint32_t *reg, int n, int x) {\n  int bit;\n\n  bit = (*reg >> n) & 1;\n  *reg = (*reg << 1) ^ x ^ (bit << 15);\n  return bit;\n}","pass":0,"source_file":"C_COMPILE/f1517/main_1517.c"}
{"compilable":0,"function":"__attribute__((always_inline)) static inline long _InterlockedOr(volatile long *const value, const long mask) {\n    return __sync_fetch_and_or_8(value, mask);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1864/main_1864.c"}
{"compilable":1,"function":"int exchange(int *xp, int y) {\n    int x = *xp;\n    *xp = y;\n    return x;\n}\n","function_prediction":"int exchange_name_conflict(int *x, int y) {\n  int temp = *x;\n  *x = y;\n  return temp;\n}","pass":1,"source_file":"C_COMPILE/f1929/main_1929.c"}
{"compilable":0,"function":"static inline int sync_lock(int *ptr) {\n    return __sync_lock_test_and_set_4(ptr, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f995/main_995.c"}
{"compilable":0,"function":"int readline(int readch, char *buffer, int len) {\n    static int pos = 0;\n    int rpos;\n    if (readch > 0) {\n        switch (readch) {\n          case '\\r':\n            break;\n          case '\\n':\n            rpos = pos;\n            pos = 0;\n            return rpos;\n          default:\n            if (pos < len - 1) {\n                buffer[pos++] = readch;\n                buffer[pos] = 0;\n            }\n        }\n    }\n    return -1;\n}\n","function_prediction":"int readline_name_conflict(int c, char *buf, int size) {\n  if (c > 0) {\n    if (c == 10) {\n      int ret = pos_0;\n      pos_0 = 0;\n      return ret;\n    }\n    if (c != 13 && pos_0 < size - 1) {\n      buf[pos_0++] = c;\n      buf[pos_0] = 0;\n    }\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f597/main_597.c"}
{"compilable":0,"function":"int foo(int *p) {\n    int a = *p;\n    int b = p != 0;\n    *p = b;\n    if (b)\n        return a;\n    else\n        return 0;\n}\n","function_prediction":"int foo_name_conflict(struct S *s) {\n  int i = s->i;\n  s->i = s != NULL;\n  if (s == NULL)\n    return 0;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f361/main_361.c"}
{"compilable":0,"function":"int xmlDecodeHex(unsigned char *out, unsigned int olen, const char *in, unsigned int ilen) {\n    static const unsigned char hex[] = {17, 17, 17, 17, 17, 17, 17, 17, 17, 16, 16, 17, 17, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 17, 17, 17, 17, 17, 17, 17, 10, 11, 12, 13, 14, 15, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 10, 11, 12, 13, 14, 15, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17};\n    unsigned long buf;\n    int len;\n    buf = 1;\n    len = 0;\n    while (ilen-- > 0)\n        {\n            unsigned char c;\n            switch ((c = hex[*(unsigned char *)in++])) {\n              case 17:\n                return (-1);\n              case 16:\n                continue;\n              default:\n                buf = buf << 4 | c;\n                if (buf & 256) {\n                    if (olen > 0) {\n                        *out++ = buf;\n                        olen--;\n                    }\n                    len++;\n                    buf = 1;\n                }\n                break;\n            }\n        }\n    if (buf != 1)\n        return (-1);\n    return (len);\n}\n","function_prediction":"int xmlDecodeHex_name_conflict(char *out, int outlen, const char *in, int inlen) {\n  int c, i, j;\n  unsigned int v;\n\n  v = 0;\n  i = 0;\n  j = 1;\n  while (inlen--) {\n    c = hex_0[(unsigned char)*in++];\n    if (c == 16)\n      continue;\n    if (c == 17)\n      return -1;\n    v <<= 4;\n    v |= c;\n    if (j & 0x100) {\n      if (outlen) {\n        *out++ = (char)v;\n        outlen--;\n      }\n      i++;\n      v = 0;\n      j = 1;\n    } else\n      j <<= 4;\n  }\n  if (j != 1)\n    return -1;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f1081/main_1081.c"}
{"compilable":1,"function":"char encode(char *buffer, char b) {\n    buffer[0] = (b & 240) >> 4;\n    buffer[1] = b & 15;\n    if (buffer[0] > 9)\n        buffer[0] = 'A' + (buffer[0] - 10);\n    else\n        buffer[0] += '0';\n    if (buffer[1] > 9)\n        buffer[1] = 'A' + (buffer[1] - 10);\n    else\n        buffer[1] += '0';\n    return 0;\n}\n","function_prediction":"int encode_name_conflict(char *buf, unsigned char c) {\n  buf[0] = (c >> 4) & 0x0F;\n  buf[1] = c & 0x0F;\n\n  if (buf[0] > 9)\n    buf[0] += 0x37;\n  else\n    buf[0] += 0x30;\n\n  if (buf[1] > 9)\n    buf[1] += 0x37;\n  else\n    buf[1] += 0x30;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f232/main_232.c"}
{"compilable":1,"function":"static int update_keys(unsigned long *pkeys, const unsigned long *pcrc_32_tab, int c) {\n    (*(pkeys + 0)) = ((*(pcrc_32_tab + (((int)((*(pkeys + 0))) ^ (c)) & 255))) ^ (((*(pkeys + 0))) >> 8));\n    (*(pkeys + 1)) += (*(pkeys + 0)) & 255;\n    (*(pkeys + 1)) = (*(pkeys + 1)) * 134775813L + 1;\n    {\n        int keyshift = (int)((*(pkeys + 1)) >> 24);\n        (*(pkeys + 2)) = ((*(pcrc_32_tab + (((int)((*(pkeys + 2))) ^ (keyshift)) & 255))) ^ (((*(pkeys + 2))) >> 8));\n    }\n    return c;\n}\n","function_prediction":"uint8_t update_keys_name_conflict(uint32_t *keys, uint8_t *sbox, uint8_t byte) {\n  keys[0] = sbox[(keys[0] ^ byte) & 0xff] ^ (keys[0] >> 8);\n  keys[1] += (keys[0] & 0xff);\n  keys[1] = (keys[1] << 1) + (keys[1] << 6) + (keys[1] << 16) + (keys[1] << 24);\n  keys[2] = sbox[(keys[2] ^ (keys[1] >> 24)) & 0xff] ^ (keys[2] >> 8);\n  return byte;\n}","pass":0,"source_file":"C_COMPILE/f892/main_892.c"}
{"compilable":1,"function":"static int search_tree(int id, int node, int max_children, int width, int *parent_id, int *next_max_children, int *depth) {\n    int current, next, next_children;\n    int i;\n    *depth = *depth + 1;\n    current = node + 1;\n    next_children = (max_children / width) - 1;\n    if (id == current) {\n        *parent_id = node;\n        *next_max_children = next_children;\n        return 1;\n    }\n    for (i = 1; i <= width; i++) {\n        next = current + next_children + 1;\n        if (id == next) {\n            *parent_id = node;\n            *next_max_children = next_children;\n            return 1;\n        }\n        if (id > current && id < next) {\n            return search_tree(id, current, next_children, width, parent_id, next_max_children, depth);\n        }\n        current = next;\n    }\n    *parent_id = -1;\n    *next_max_children = -1;\n    return 0;\n}\n","function_prediction":"int search_tree_name_conflict(int n, int start, int end, int level, int *x, int *y,\n                int *count) {\n  int i, j, k, m;\n  *count = *count + 1;\n  m = end / level - 1;\n  if (n == start + 1) {\n    *x = start;\n    *y = m;\n    return 1;\n  }\n  for (i = 1; i <= level; i++) {\n    j = start + i + 1;\n    if (j == n) {\n      *x = start;\n      *y = m;\n      return 1;\n    }\n    if (j < n && j > start) {\n      if (search_tree_name_conflict(n, j, m, level, x, y, count))\n        return 1;\n    }\n  }\n  *x = -1;\n  *y = -1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1283/main_1283.c"}
{"compilable":1,"function":"char *ehnlc_strcpy(char *dest, const char *src) {\n    size_t i;\n    if (!dest) {\n        return ((void *)0);\n    }\n    i = 0;\n    if (src) {\n        while (*(src + i))\n            {\n                *(dest + i) = *(src + i);\n                ++i;\n            }\n    }\n    *(dest + i) = '\\x00';\n    return dest;\n}\n","function_prediction":"char *ehnlc_strcpy_name_conflict(char *dest, const char *src) {\n  size_t i;\n\n  if (dest == NULL)\n    return NULL;\n\n  if (src == NULL)\n    return dest;\n\n  for (i = 0; src[i] != '\\0'; i++)\n    dest[i] = src[i];\n\n  dest[i] = '\\0';\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f1148/main_1148.c"}
{"compilable":1,"function":"size_t openpam_strlset(char *str, int ch, size_t size) {\n    size_t len;\n    for (len = 0; *str && size > 1; ++len , --size)\n        *str++ = (char)ch;\n    *str = '\\x00';\n    return (++len);\n}\n","function_prediction":"size_t openpam_strlset_name_conflict(char *s, int c, size_t n) {\n  size_t i;\n\n  for (i = 0; *s && n > 1; i++, n--)\n    *s++ = c;\n  *s = '\\0';\n  return i + 1;\n}","pass":0,"source_file":"C_COMPILE/f2047/main_2047.c"}
{"compilable":1,"function":"int LI_ltostr(char *buf, long val) {\n    char swap;\n    char *end;\n    int len = 1;\n    if (val < 0) {\n        len++;\n        *(buf++) = '-';\n        val = -val;\n    }\n    end = buf;\n    while (val > 9)\n        {\n            *(end++) = '0' + (val % 10);\n            val = val / 10;\n        }\n    *(end) = '0' + val;\n    *(end + 1) = '\\x00';\n    len += end - buf;\n    while (buf < end)\n        {\n            swap = *end;\n            *end = *buf;\n            *buf = swap;\n            buf++;\n            end--;\n        }\n    return len;\n}\n","function_prediction":"int LI_ltostr_name_conflict(char *s, long n) {\n  char *p, *q;\n  int sign = 1;\n\n  if (n < 0) {\n    sign = 2;\n    *s++ = '-';\n    n = -n;\n  }\n  p = s;\n  q = s;\n  while (n > 9) {\n    *q++ = '0' + (n % 10);\n    n /= 10;\n  }\n  *q++ = '0' + n;\n  *q = '\\0';\n  while (p < q) {\n    char c = *q;\n    *q-- = *p;\n    *p++ = c;\n  }\n  return q - p + sign;\n}","pass":0,"source_file":"C_COMPILE/f743/main_743.c"}
{"compilable":1,"function":"static int computesizes(int nums[], int *narray) {\n    int i;\n    int twotoi;\n    int a = 0;\n    int na = 0;\n    int n = 0;\n    for (i = 0 , twotoi = 1; twotoi / 2 < *narray; i++ , twotoi *= 2) {\n        if (nums[i] > 0) {\n            a += nums[i];\n            if (a > twotoi / 2) {\n                n = twotoi;\n                na = a;\n            }\n        }\n        if (a == *narray)\n            break;\n    }\n    *narray = n;\n    ((void)0);\n    return na;\n}\n","function_prediction":"int computesizes_name_conflict(int *sizes, int *maxsize) {\n  int i, max, sum, maxi;\n\n  max = sum = maxi = 0;\n  for (i = 1; i / 2 < *maxsize; i *= 2) {\n    if (sizes[maxi] > 0) {\n      sum += sizes[maxi];\n      if (sum > i / 2) {\n        max = sum;\n        *maxsize = i;\n      }\n    }\n    if (sum == *maxsize)\n      break;\n    maxi++;\n  }\n  return max;\n}","pass":0,"source_file":"C_COMPILE/f2086/main_2086.c"}
{"compilable":1,"function":"int GetSymbol(int *low, int *high, int *count, int target, int nSymbols) {\n    int n;\n    *low = 0;\n    for (n = 0; n < nSymbols; n++) {\n        if (*low + count[n] > target)\n            break;\n        *low += count[n];\n    }\n    *high = *low + count[n];\n    return (n);\n}\n","function_prediction":"int GetSymbol_name_conflict(int *p_start, int *p_end, int *p_lengths, int p_max_length,\n              int p_num_symbols) {\n  int i;\n  *p_start = 0;\n  for (i = 0; i < p_num_symbols; i++) {\n    if (*p_start + p_lengths[i] > p_max_length) {\n      break;\n    }\n    *p_start += p_lengths[i];\n  }\n  *p_end = *p_start + p_lengths[i];\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f1938/main_1938.c"}
{"compilable":1,"function":"char *itoa(int value, char *result, int base) {\n    if (base < 2 || base > 36) {\n        *result = '\\x00';\n        return result;\n    }\n    char *ptr = result, *ptr1 = result, tmp_char;\n    int tmp_value;\n    do {\n        tmp_value = value;\n        value /= base;\n        *ptr++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\"[35 + (tmp_value - value * base)];\n    } while (value);\n    if (tmp_value < 0)\n        *ptr++ = '-';\n    *ptr-- = '\\x00';\n    while (ptr1 < ptr)\n        {\n            tmp_char = *ptr;\n            *ptr-- = *ptr1;\n            *ptr1++ = tmp_char;\n        }\n    return result;\n}\n","function_prediction":"char *itoa_name_conflict(int value, char *str, int base) {\n  static const char digits[] =\n      \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\";\n  char *s = str;\n  int sign = 0;\n\n  if (base < 2 || base > 36) {\n    *s = '\\0';\n    return s;\n  }\n\n  if (value < 0) {\n    sign = 1;\n    value = -value;\n  }\n\n  do {\n    *s++ = digits[((unsigned int)value % (unsigned int)base)];\n    value /= base;\n  } while (value);\n\n  if (sign) {\n    *s++ = '-';\n  }\n\n  *s = '\\0';\n\n  char *p1 = str;\n  char *p2 = s - 1;\n  while (p1 < p2) {\n    char tmp = *p1;\n    *p1 = *p2;\n    *p2 = tmp;\n    p1++;\n    p2--;\n  }\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/f1991/main_1991.c"}
{"compilable":1,"function":"int receive_byte(unsigned char *ch) {\n    return ((read(0, ch, 1) < 1) ? -1 : 0);\n}\n","function_prediction":"int receive_byte_name_conflict(unsigned char *byte) {\n  if (read(0, byte, 1) < 1)\n    return -1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f419/main_419.c"}
{"compilable":1,"function":"static char *append02d(char *cp, int n) {\n    *cp++ = '0' + (n / 10);\n    *cp++ = '0' + (n % 10);\n    return cp;\n}\n","function_prediction":"char *append02d_name_conflict(char *p, int v) {\n  *p++ = '0' + v / 10;\n  *p++ = '0' + v % 10;\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f384/main_384.c"}
{"compilable":0,"function":"static inline char *mystrcpy(char *dest, const char *src) {\n    int d0, d1, d2;\n    asm volatile (\"1:\\n\\t\\tlodsb\\n\\tstosb\\n\\ttestb %%al,%%al\\n\\tjne 1b\" : \"=&S\" (d0), \"=&D\" (d1), \"=&a\" (d2) : \"0\" (src), \"1\" (dest) : \"memory\");\n    return dest;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f272/main_272.c"}
{"compilable":0,"function":"static inline short atomic_inc_short(short *v) {\n    asm (\".pushsection .smp_locks,\\\"a\\\"\\n.balign 4\\n.long 671f - .\\n.popsection\\n671:\\n\\tlock; addw $1, %0\" : \"+m\" (*v));\n    return *v;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1561/main_1561.c"}
{"compilable":1,"function":"unsigned int ft_pop_sign(int n, int *sign) {\n    unsigned int buff;\n    *sign = 0;\n    if (n < 0) {\n        *sign = 1;\n        buff = (unsigned int)(n * -1);\n    } else\n        buff = (unsigned int)n;\n    return (buff);\n}\n","function_prediction":"int ft_pop_sign_name_conflict(int n, int *sign) {\n  *sign = 0;\n  if (n < 0) {\n    *sign = 1;\n    n = -n;\n  }\n  return (n);\n}","pass":1,"source_file":"C_COMPILE/f1830/main_1830.c"}
{"compilable":1,"function":"static int nonatomic_set(int *x) {\n    int prev = *x;\n    *x = 1;\n    return prev;\n}\n","function_prediction":"int nonatomic_set_name_conflict(int *ptr) {\n  int old = *ptr;\n  *ptr = 1;\n  return old;\n}","pass":1,"source_file":"C_COMPILE/f962/main_962.c"}
{"compilable":0,"function":"int foo(int *a, int *b, int c) {\n    *a = 2 * *a;\n    *b = *b / 2;\n    c = *a + *b;\n    return (c);\n}\n","function_prediction":"int foo_name_conflict(int *a, int *b) {\n  *a *= 2;\n  *b /= 2;\n  return *a + *b;\n}","pass":0,"source_file":"C_COMPILE/f1239/main_1239.c"}
{"compilable":1,"function":"char *strrev(char *str) {\n    char *i = str;\n    char *ri = 0;\n    char tmp;\n    while (*i)\n        i++;\n    ri = i - 1;\n    i = str;\n    while (*i && i < ri)\n        {\n            tmp = *i;\n            *i = *ri;\n            *ri = tmp;\n            i++;\n            ri--;\n        }\n    return str;\n}\n","function_prediction":"char *strrev_name_conflict(char *str) {\n  char *p1, *p2;\n\n  if (!str || !*str)\n    return str;\n  for (p1 = str; *p1; ++p1)\n    ;\n  for (p2 = p1 - 1; str < p2; ++str, --p2) {\n    char tmp = *str;\n    *str = *p2;\n    *p2 = tmp;\n  }\n  return str;\n}","pass":0,"source_file":"C_COMPILE/f1446/main_1446.c"}
{"compilable":1,"function":"char *strcpy(char *dest, const char *src) {\n    char *ret = dest;\n    while (*src)\n        {\n            *dest++ = *src++;\n        }\n    *dest = '\\x00';\n    return ret;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  while (*s)\n    *d++ = *s++;\n  *d = '\\0';\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f527/main_527.c"}
{"compilable":0,"function":"static int keyring_find_key(const char *name, int name_len, unsigned char **key) {\n    return -1;\n}\n","function_prediction":"int keyring_find_key_name_conflict(struct keyring_index *index, struct key *key) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1478/main_1478.c"}
{"compilable":0,"function":"static inline int _hclib_atomic_inc_relaxed(volatile int *target) {\n    return __sync_add_and_fetch_4(target, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f734/main_734.c"}
{"compilable":1,"function":"int write_all(int fd, const unsigned char *buf, int count) {\n    int n;\n    do {\n        n = write(fd, buf, count);\n        if (n > 0) {\n            count -= n;\n            buf += n;\n        }\n    } while (n > 0 && count > 0);\n    return n;\n}\n","function_prediction":"int write_all_name_conflict(int fd, const void *buf, int len) {\n  int n;\n  const char *p = buf;\n\n  do {\n    n = write(fd, p, len);\n    if (n <= 0)\n      return n;\n    len -= n;\n    p += n;\n  } while (len > 0);\n\n  return n;\n}","pass":1,"source_file":"C_COMPILE/f1684/main_1684.c"}
{"compilable":1,"function":"int htoi(const char *str, int *result) {\n    int c;\n    if (str[0] == '0' && str[1] == 'x')\n        str += 2;\n    for (*result = 0; (c = *str) != 0; str++) {\n        if (c >= 'a' && c <= 'f')\n            c = c - 'a' + 10;\n        else if (c >= 'A' && c <= 'F')\n            c = c - 'A' + 10;\n        else if (c >= '0' && c <= '9')\n            c -= '0';\n        else\n            return 0;\n        *result = *result << 4 | c;\n    }\n    return 1;\n}\n","function_prediction":"int htoi_name_conflict(char *s, unsigned int *n) {\n  int c;\n\n  if (s[0] == '0' && s[1] == 'x')\n    s += 2;\n\n  *n = 0;\n  while ((c = *s++) != '\\0') {\n    if (c >= '0' && c <= '9')\n      c = c - '0';\n    else if (c >= 'a' && c <= 'f')\n      c = c - 'a' + 10;\n    else if (c >= 'A' && c <= 'F')\n      c = c - 'A' + 10;\n    else\n      return 0;\n    *n = (*n << 4) | c;\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/f465/main_465.c"}
{"compilable":0,"function":"static inline unsigned int i386_get_cpuid(unsigned int *ecx, unsigned int *edx) {\n    int fl1;\n    asm (\"pushq %%rcx; pushq %%rbx; cpuid; popq %%rbx; popq %%rcx\" : \"=a\" (fl1) : \"0\" (0) : \"rdx\", \"cc\");\n    if (fl1 == 0)\n        return (0);\n    asm (\"pushq %%rbx; cpuid; popq %%rbx\" : \"=c\" (*ecx), \"=d\" (*edx), \"=a\" (fl1) : \"2\" (1) : \"cc\");\n    return 1;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1644/main_1644.c"}
{"compilable":1,"function":"char _mensa_next_nonws(char *str, int *offset) {\n    int k = 0;\n    if (!str)\n        return 0;\n    while (str[k] != '\\x00')\n        {\n            if (str[k] != ' ' && str[k] != '\\t' && str[k] != 10 && str[k] != 13) {\n                if (str[k] != 194 || str[k + 1] != 160) {\n                    if (offset)\n                        *offset = k;\n                    return str[k];\n                } else {\n                    k++;\n                }\n            }\n            k++;\n        }\n    if (offset)\n        *offset = k;\n    return 0;\n}\n","function_prediction":"char _mensa_next_nonws_name_conflict(const char *str, int *pos) {\n  int i = 0;\n  if (str == NULL)\n    return 0;\n  while (str[i] != '\\0') {\n    if (str[i] != ' ' && str[i] != '\\t' && str[i] != '\\n' && str[i] != '\\r') {\n      if (pos != NULL)\n        *pos = i;\n      return str[i];\n    }\n    i++;\n  }\n  if (pos != NULL)\n    *pos = i;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f871/main_871.c"}
{"compilable":0,"function":"static inline int _hclib_atomic_inc_release(volatile int *target) {\n    return __sync_add_and_fetch_4(target, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f2085/main_2085.c"}
{"compilable":1,"function":"extern int satsys(int sat, int *prn) {\n    int sys = 0;\n    if (sat <= 0 || ((32 - 1 + 1) + (24 - 1 + 1) + 0 + 0 + (35 - 1 + 1) + (142 - 120 + 1) + 0) < sat) {\n        sat = 0;\n    } else if (sat <= (32 - 1 + 1)) {\n        sys = 1;\n        sat += 1 - 1;\n    } else if ((sat -= (32 - 1 + 1)) <= (24 - 1 + 1)) {\n        sys = 4;\n        sat += 1 - 1;\n    } else if ((sat -= (24 - 1 + 1)) <= 0) {\n        sys = 8;\n        sat += 0 - 1;\n    } else if ((sat -= 0) <= 0) {\n        sys = 16;\n        sat += 0 - 1;\n    } else if ((sat -= 0) <= (35 - 1 + 1)) {\n        sys = 32;\n        sat += 1 - 1;\n    } else if ((sat -= (35 - 1 + 1)) <= 0) {\n        sys = 64;\n        sat += 0 - 1;\n    } else if ((sat -= 0) <= (142 - 120 + 1)) {\n        sys = 2;\n        sat += 120 - 1;\n    } else {\n        sat = 0;\n    }\n    if (prn) {\n        *prn = sat;\n    }\n    return sys;\n}\n","function_prediction":"int satsys_name_conflict(int sys, int *sysnum) {\n  int ret = 0;\n\n  if (sys < 1 || sys > 114)\n    sys = 0;\n  else if (sys <= 32) {\n    ret = 1;\n    sys = sys;\n  } else if (sys <= 32 + 24) {\n    ret = 4;\n    sys = sys - 32;\n  } else if (sys <= 32 + 24 + 1) {\n    ret = 8;\n    sys = sys - 32 - 24 - 1;\n  } else if (sys <= 32 + 24 + 1 + 1) {\n    ret = 16;\n    sys = sys - 32 - 24 - 1 - 1;\n  } else if (sys <= 32 + 24 + 1 + 1 + 36) {\n    ret = 32;\n    sys = sys - 32 - 24 - 1 - 1 - 36;\n  } else if (sys <= 32 + 24 + 1 + 1 + 36 + 1) {\n    ret = 64;\n    sys = sys - 32 - 24 - 1 - 1 - 36 - 1;\n  } else if (sys <= 32 + 24 + 1 + 1 + 36 + 1 + 24) {\n    ret = 2;\n    sys = sys - 32 - 24 - 1 - 1 - 36 - 1 - 24;\n  } else {\n    sys = 0;\n  }\n\n  if (sysnum)\n    *sysnum = sys;\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/f42/main_42.c"}
{"compilable":1,"function":"static char *qstrcpy(char *to, const char *from) {\n    char *save = to;\n    for (; (*to = *from) != '\\x00'; ++from , ++to)\n        ;\n    return (save);\n}\n","function_prediction":"char *qstrcpy_name_conflict(char *dst, const char *src) {\n  char *d = dst;\n  const char *s = src;\n\n  do {\n    *d++ = *s;\n  } while (*s++ != '\\0');\n\n  return dst;\n}","pass":1,"source_file":"C_COMPILE/f1881/main_1881.c"}
{"compilable":1,"function":"char *ant_itoa(int n, char *dst, int base) {\n    char *d, *p;\n    char str[33];\n    unsigned int m;\n    p = str + sizeof (str) - 1;\n    d = dst;\n    *p = '\\x00';\n    if (n == (int)(((unsigned int)~0 >> 1) + 1))\n        m = (unsigned int)n;\n    else if (n < 0 && base == 10)\n        m = -n;\n    else\n        m = n;\n    do {\n        *--p = \"0123456789abcdef\"[m % base];\n    } while (m /= base);\n    if (n < 0 && base == 10)\n        *--p = '-';\n    while ((*dst++ = *p++) != '\\x00')\n        ;\n    return d;\n}\n","function_prediction":"char *ant_itoa_name_conflict(int value, char *str, int base) {\n  char *s = str;\n  char *p = str;\n  char *q;\n  char temp;\n  int sign;\n  char *digits = \"0123456789abcdef\";\n\n  sign = value;\n  if (value == -2147483648) {\n    value = -2147483647;\n  }\n  if (value < 0 && base == 10) {\n    value = -value;\n  }\n  do {\n    *--p = digits[value % base];\n    value /= base;\n  } while (value);\n  if (sign < 0 && base == 10) {\n    *--p = '-';\n  }\n  while (p <= q) {\n    temp = *p;\n    *p++ = *q;\n    *q++ = temp;\n  }\n  return str;\n}","pass":0,"source_file":"C_COMPILE/f772/main_772.c"}
{"compilable":1,"function":"static char *mb_strupr(char *s) {\n    char *t = s;\n    while (*s)\n        {\n            *s = (((*s) >= 'a' && (*s) <= 'z') ? ((*s) - 'a' + 'A') : (*s));\n            ++s;\n        }\n    return t;\n}\n","function_prediction":"char *mb_strupr_name_conflict(char *str) {\n  char *p = str;\n  while (*p) {\n    *p = (*p >= 'a' && *p <= 'z') ? *p - 0x20 : *p;\n    p++;\n  }\n  return str;\n}","pass":1,"source_file":"C_COMPILE/f1088/main_1088.c"}
{"compilable":0,"function":"int sd_write_block(unsigned int blockaddr, const unsigned char *buf) {\n    return 0;\n}\n","function_prediction":"int sd_write_block_name_conflict(sd_t *sd, uint32_t block, uint8_t *data) { return 0; }","pass":0,"source_file":"C_COMPILE/f1603/main_1603.c"}
{"compilable":0,"function":"int RGB8toRGB24(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"int RGB8toRGB24_name_conflict(unsigned char *src, unsigned char *dst, int width, int height) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f251/main_251.c"}
{"compilable":1,"function":"int change(int *num) {\n    *num = 777;\n    return 0;\n}\n","function_prediction":"int change_name_conflict(int *a) {\n  *a = 1234;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f2073/main_2073.c"}
{"compilable":0,"function":"static inline long atomic_inc(volatile long *pAddr) {\n    register long result;\n    asm volatile (\"lock/xaddq %q0, %1\" : \"=r\" (result), \"=m\" (*pAddr) : \"0\" ((long)(1)), \"m\" (*pAddr));\n    return *pAddr;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1360/main_1360.c"}
{"compilable":1,"function":"int xshift(short *runs, int nr, int s) {\n    int i = 0, n = 0;\n    if (s < 0) {\n        for (i = 0; s < 0 && i < nr; i++) {\n            s += runs[i];\n            n -= runs[i];\n            runs[i] = 0;\n        }\n        i--;\n    }\n    if (i < nr) {\n        runs[i] += s;\n        n += s;\n    }\n    return n;\n}\n","function_prediction":"int xshift_name_conflict(short *x, int n, int s) {\n  int i, sum;\n\n  sum = 0;\n  i = 0;\n  if (s < 0) {\n    while (s < 0 && i < n) {\n      s += x[i];\n      sum -= x[i];\n      x[i] = 0;\n      i++;\n    }\n    i--;\n  }\n  if (i < n) {\n    x[i] += s;\n    sum += s;\n  }\n  return sum;\n}","pass":1,"source_file":"C_COMPILE/f312/main_312.c"}
{"compilable":0,"function":"inline _Bool SHAREMIND_MAP_KEY_COPY_char(char *const dest, const char src) {\n    return (((*dest) = src) , 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1235/main_1235.c"}
{"compilable":0,"function":"static inline int pwc_reg_read(unsigned char addr, unsigned char *data) {\n    return 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f549/main_549.c"}
{"compilable":1,"function":"int SmpFrqIndex(int sample_freq, int *const version) {\n    switch (sample_freq) {\n      case 44100:\n        *version = 1;\n        return 0;\n      case 48000:\n        *version = 1;\n        return 1;\n      case 32000:\n        *version = 1;\n        return 2;\n      case 22050:\n        *version = 0;\n        return 0;\n      case 24000:\n        *version = 0;\n        return 1;\n      case 16000:\n        *version = 0;\n        return 2;\n      case 11025:\n        *version = 0;\n        return 0;\n      case 12000:\n        *version = 0;\n        return 1;\n      case 8000:\n        *version = 0;\n        return 2;\n      default:\n        *version = 0;\n        return -1;\n    }\n}\n","function_prediction":"int SmpFrqIndex_name_conflict(int frq, int *p_is_48k) {\n  int i;\n  int frq_tab[] = {8000,  11025, 12000, 16000, 22050, 24000,\n                   32000, 44100, 48000, 88200, 96000};\n\n  for (i = 0; i < (sizeof(frq_tab) / sizeof(frq_tab[0])); i++) {\n    if (frq == frq_tab[i]) {\n      *p_is_48k = (i == 8) ? 1 : 0;\n      return i;\n    }\n  }\n\n  *p_is_48k = 0;\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f480/main_480.c"}
{"compilable":0,"function":"static int smtp_si_add_size_t(const size_t a, const size_t b, size_t *const result) {\n    int wraps;\n    if (((size_t)(-1)) - a < b) {\n        wraps = 1;\n    } else {\n        wraps = 0;\n    }\n    if (result) {\n        *result = a + b;\n    }\n    return wraps;\n}\n","function_prediction":"int smtp_si_add_size_t_name_conflict(size_t a, size_t b, size_t *c) {\n  if (c)\n    *c = a + b;\n  return (a > (~(size_t)0 - b));\n}","pass":0,"source_file":"C_COMPILE/f918/main_918.c"}
{"compilable":1,"function":"int str_utf8_encode(char *ptr, int chr) {\n    if (chr <= 127) {\n        ptr[0] = (char)chr;\n        return 1;\n    } else if (chr <= 2047) {\n        ptr[0] = 192 | ((chr >> 6) & 31);\n        ptr[1] = 128 | (chr & 63);\n        return 2;\n    } else if (chr <= 65535) {\n        ptr[0] = 224 | ((chr >> 12) & 15);\n        ptr[1] = 128 | ((chr >> 6) & 63);\n        ptr[2] = 128 | (chr & 63);\n        return 3;\n    } else if (chr <= 1114111) {\n        ptr[0] = 240 | ((chr >> 18) & 7);\n        ptr[1] = 128 | ((chr >> 12) & 63);\n        ptr[2] = 128 | ((chr >> 6) & 63);\n        ptr[3] = 128 | (chr & 63);\n        return 4;\n    }\n    return 0;\n}\n","function_prediction":"size_t str_utf8_encode_name_conflict(char *buf, int32_t ch) {\n  if (ch < 0x80) {\n    buf[0] = ch;\n    return 1;\n  }\n  if (ch < 0x800) {\n    buf[0] = 0xC0 | (ch >> 6);\n    buf[1] = 0x80 | (ch & 0x3F);\n    return 2;\n  }\n  if (ch < 0x10000) {\n    buf[0] = 0xE0 | (ch >> 12);\n    buf[1] = 0x80 | ((ch >> 6) & 0x3F);\n    buf[2] = 0x80 | (ch & 0x3F);\n    return 3;\n  }\n  if (ch < 0x110000) {\n    buf[0] = 0xF0 | (ch >> 18);\n    buf[1] = 0x80 | ((ch >> 12) & 0x3F);\n    buf[2] = 0x80 | ((ch >> 6) & 0x3F);\n    buf[3] = 0x80 | (ch & 0x3F);\n    return 4;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f912/main_912.c"}
{"compilable":1,"function":"static int SetBit(int *tab, int idx) {\n    int res = (tab[idx >> 5] & (1 << (idx & 31)));\n    tab[idx >> 5] |= 1 << (idx & 31);\n    return (res);\n}\n","function_prediction":"int SetBit_name_conflict(int *a, int k) {\n  int i = k / 32;\n  int j = k % 32;\n  int oldbit = (a[i] & (1 << j)) != 0;\n  a[i] |= (1 << j);\n  return oldbit;\n}","pass":0,"source_file":"C_COMPILE/f1866/main_1866.c"}
{"compilable":1,"function":"int FNEGS(unsigned long *rd, unsigned long *rs2) {\n    rd[0] = rs2[0] ^ 2147483648UL;\n    return 1;\n}\n","function_prediction":"int FNEGS_name_conflict(float *r, float *a) {\n  *r = -(*a);\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f53/main_53.c"}
{"compilable":0,"function":"bool adicionaElemento(int v[], int elem, int *tam) {\n    if (*tam < 20) {\n        tam++;\n        v[*tam - 1] = elem;\n        return 1;\n    } else\n        return 0;\n}\n","function_prediction":"int adicionaElemento_name_conflict(int *vetor, int elemento, struct vetor *vetorEstatico) {\n  if (vetorEstatico->tamanho < 20) {\n    vetor[vetorEstatico->fim - 1] = elemento;\n    return 1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1808/main_1808.c"}
{"compilable":1,"function":"char *GRF_normalize_path(char *out, const char *in) {\n    char *orig;\n    for (orig = out; *in != 0; out++ , in++)\n        *out = (*in == '\\\\') ? '/' : *in;\n    out[0] = 0;\n    return orig;\n}\n","function_prediction":"char *GRF_normalize_path_name_conflict(char *dst, const char *src) {\n  char *dst_ptr = dst;\n  const char *src_ptr = src;\n\n  while (*src_ptr) {\n    *dst_ptr = (*src_ptr == '\\\\') ? '/' : *src_ptr;\n    dst_ptr++;\n    src_ptr++;\n  }\n  *dst_ptr = '\\0';\n\n  return dst;\n}","pass":1,"source_file":"C_COMPILE/f2103/main_2103.c"}
{"compilable":1,"function":"int another_search(int a[], int len, int key) {\n    int ret = len;\n    a[0] = key;\n    while (a[ret] != key)\n        ret--;\n    return ret;\n}\n","function_prediction":"int another_search_name_conflict(int *array, int size, int value) {\n  int i;\n\n  array[0] = value;\n  for (i = size; array[0] != array[i]; i--)\n    ;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f920/main_920.c"}
{"compilable":0,"function":"static inline int getcomp(unsigned char *line, int x, int bpc) {\n    switch (bpc) {\n      case 1:\n        return (line[x >> 3] >> (7 - (x & 7))) & 1;\n      case 2:\n        return (line[x >> 2] >> ((3 - (x & 3)) << 1)) & 3;\n      case 4:\n        return (line[x >> 1] >> ((1 - (x & 1)) << 2)) & 15;\n      case 8:\n        return line[x];\n      case 16:\n        return line[x << 1] << 8 | line[(x << 1) + 1];\n    }\n    return 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1893/main_1893.c"}
{"compilable":0,"function":"static size_t defaultNextCharLen(const char *buf, size_t buf_len, size_t pos, size_t *col_len) {\n    (void)(buf);\n    (void)(buf_len);\n    (void)(pos);\n    if (col_len != ((void *)0))\n        *col_len = 1;\n    return 1;\n}\n","function_prediction":"int defaultNextCharLen_name_conflict(const char *p, const char *end, int *len) {\n  if (len)\n    *len = 1;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/f1812/main_1812.c"}
{"compilable":1,"function":"static int sputc(char *s, int c) {\n    *s = c;\n    return 1;\n}\n","function_prediction":"int sputc_name_conflict(void *stream, char c) {\n  *(char *)stream = c;\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f1768/main_1768.c"}
{"compilable":0,"function":"int ringbuffer1(unsigned char rw, unsigned char *data, unsigned int count) {\n    static volatile unsigned char buffer[384];\n    static volatile unsigned int read_pointer, write_pointer;\n    static volatile unsigned int content = 0;\n    unsigned int p = 0;\n    unsigned int p2 = 0;\n    if (rw == 1) {\n        if (count < 384 - content) {\n            while (p < count)\n                {\n                    buffer[write_pointer++] = data[p++];\n                }\n            content += count;\n            return (1);\n        }\n    } else if (rw == 0) {\n        if (content >= count) {\n            while (p2 < count)\n                {\n                    data[p2++] = buffer[read_pointer++];\n                }\n            content -= count;\n            if (!content) {\n                write_pointer = 0;\n                read_pointer = 0;\n            }\n            return (1);\n        }\n    } else if (rw == 2) {\n        if (content)\n            return 0;\n        else\n            return (384 - 11);\n    }\n    return (0);\n}\n","function_prediction":"int ringbuffer1_name_conflict(char mode, char *data, unsigned int length) {\n  unsigned int i = 0;\n  unsigned int j = 0;\n\n  if (mode == 1) {\n    if (length > (400 - content_3)) {\n      return 0;\n    } else {\n      while (i < length) {\n        buffer_1[write_pointer_2] = data[i];\n        write_pointer_2++;\n        i++;\n      }\n      content_3 += length;\n      return 1;\n    }\n  } else if (mode == 0) {\n    if (length > content_3) {\n      return 0;\n    } else {\n      while (j < length) {\n        data[j] = buffer_1[read_pointer_0];\n        read_pointer_0++;\n        j++;\n      }\n      if (content_3 - length == 0) {\n        write_pointer_2 = 0;\n        read_pointer_0 = 0;\n      }\n      content_3 -= length;\n      return 1;\n    }\n  } else if (mode == 2) {\n    if (content_3 == 0) {\n      return 373;\n    } else {\n      return 0;\n    }\n  } else {\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/f633/main_633.c"}
{"compilable":0,"function":"unsigned char oretype(unsigned char *xbuf, unsigned char *subindx, unsigned char *subtype, unsigned char *trulen, unsigned long *addr, int *nseq) {\n    return 1;\n}\n","function_prediction":"int oretype_name_conflict(int type) { return 1; }","pass":0,"source_file":"C_COMPILE/f841/main_841.c"}
{"compilable":1,"function":"const char *f(int *p) {\n    *p = 3;\n    return \"hi\";\n}\n","function_prediction":"const char *f_name_conflict(int *p) {\n  *p = 3;\n  return \"f_name_conflictoo\";\n}","pass":0,"source_file":"C_COMPILE/f308/main_308.c"}
{"compilable":1,"function":"const char *string_to_ulong(const char *s, unsigned long *number) {\n    int c = *s;\n    for (*number = 0; ((unsigned int)(c - '0') <= (unsigned int)('9' - '0')); *number = (((*number) << 1) + ((*number) << 3)) + (c - '0') , c = *++s)\n        ;\n    return s;\n}\n","function_prediction":"char *string_to_ulong_name_conflict(char *s, unsigned long *ul) {\n  *ul = 0;\n  while (*s >= '0' && *s <= '9')\n    *ul = (*ul << 3) + (*ul << 1) + (*s++ - '0');\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f1130/main_1130.c"}
{"compilable":1,"function":"int cfsetospeed(struct termios *termios_p, speed_t speed) {\n    termios_p->c_ospeed = speed;\n    return 0;\n}\n","function_prediction":"int cfsetospeed_name_conflict(struct termios *termios_p, speed_t speed) {\n  termios_p->c_ospeed = speed;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f884/main_884.c"}
{"compilable":0,"function":"int RGB8toRGB565(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"uint16_t RGB8toRGB565_name_conflict(uint8_t r, uint8_t g, uint8_t b) { return 0xFFFF; }","pass":0,"source_file":"C_COMPILE/f1640/main_1640.c"}
{"compilable":0,"function":"char *strtok_s(char *str, const char delim) {\n    static char *last;\n    char *tmp;\n    if (str) {\n        last = str;\n    } else if (last) {\n        str = last;\n    } else {\n        return 0;\n    }\n    while (*str)\n        {\n            if (*str == delim) {\n                *str++ = 0;\n                tmp = last;\n                last = str;\n                return tmp;\n            }\n            str++;\n        }\n    tmp = last;\n    last = 0;\n    return tmp;\n}\n","function_prediction":"char *strtok_s_name_conflict(char *str, char delim) {\n  char *ret;\n\n  if (str == NULL) {\n    if (last_0 == NULL)\n      return NULL;\n    str = last_0;\n  }\n\n  ret = str;\n\n  while (*str != '\\0') {\n    if (*str == delim) {\n      *str = '\\0';\n      last_0 = str + 1;\n      return ret;\n    }\n    str++;\n  }\n\n  last_0 = NULL;\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/f1085/main_1085.c"}
{"compilable":1,"function":"int my_swap(int *a, int *b) {\n    int cp_b;\n    cp_b = *b;\n    *b = *a;\n    *a = cp_b;\n    return (0);\n}\n","function_prediction":"int my_swap_name_conflict(int *a, int *b) {\n  int tmp;\n\n  tmp = *b;\n  *b = *a;\n  *a = tmp;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1628/main_1628.c"}
{"compilable":1,"function":"int rand_r(unsigned int *seedp) {\n    *seedp = (*seedp * 1103515245 + 12345) & 2147483647;\n    return *seedp;\n}\n","function_prediction":"int rand_r_name_conflict(unsigned int *seedp) {\n  *seedp = (1103515245 * *seedp + 12345) & 0x7fffffff;\n  return *seedp;\n}","pass":1,"source_file":"C_COMPILE/f1391/main_1391.c"}
{"compilable":1,"function":"int verifyxy(int *x, int *y) {\n    int flag = 0;\n    if (*x < 0) {\n        *x = 0;\n        flag++;\n    }\n    if (*y < 0) {\n        *y = 0;\n        flag++;\n    }\n    if (*x >= 67) {\n        *x = 67 - 1;\n        flag++;\n    }\n    if (*y >= 17) {\n        *y = 17 - 1;\n        flag++;\n    }\n    return (flag);\n}\n","function_prediction":"int verifyxy_name_conflict(int *x, int *y) {\n  int ret = 0;\n\n  if (*x < 0) {\n    *x = 0;\n    ret++;\n  }\n  if (*y < 0) {\n    *y = 0;\n    ret++;\n  }\n  if (*x > 66) {\n    *x = 66;\n    ret++;\n  }\n  if (*y > 16) {\n    *y = 16;\n    ret++;\n  }\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/f1164/main_1164.c"}
{"compilable":1,"function":"static char *_getbase(char *p, int *basep) {\n    if (p[0] == '0') {\n        switch (p[1]) {\n          case 'x':\n            *basep = 16;\n            break;\n          case 't':\n          case 'n':\n            *basep = 10;\n            break;\n          case 'o':\n            *basep = 8;\n            break;\n          default:\n            *basep = 10;\n            return (p);\n        }\n        return (p + 2);\n    }\n    *basep = 10;\n    return (p);\n}\n","function_prediction":"char *_getbase_name_conflict(char *s, int *base) {\n  if (*s == '0') {\n    s++;\n    if (*s == 'x')\n      *base = 16;\n    else if (*s == 't' || *s == 'n')\n      *base = 10;\n    else if (*s == 'o')\n      *base = 8;\n    else\n      *base = 10;\n    s++;\n  } else\n    *base = 10;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f1573/main_1573.c"}
{"compilable":1,"function":"signed char sraClipRect(int *x, int *y, int *w, int *h, int cx, int cy, int cw, int ch) {\n    if (*x < cx) {\n        *w -= (cx - *x);\n        *x = cx;\n    }\n    if (*y < cy) {\n        *h -= (cy - *y);\n        *y = cy;\n    }\n    if (*x + *w > cx + cw) {\n        *w = (cx + cw) - *x;\n    }\n    if (*y + *h > cy + ch) {\n        *h = (cy + ch) - *y;\n    }\n    return (*w > 0) && (*h > 0);\n}\n","function_prediction":"int sraClipRect_name_conflict(int *x, int *y, int *w, int *h, int x0, int y0, int w0,\n                int h0) {\n  if (x0 > *x) {\n    *w -= x0 - *x;\n    *x = x0;\n  }\n  if (y0 > *y) {\n    *h -= y0 - *y;\n    *y = y0;\n  }\n  if (x0 + w0 < *x + *w)\n    *w = x0 + w0 - *x;\n  if (y0 + h0 < *y + *h)\n    *h = y0 + h0 - *y;\n  if (*w <= 0 || *h <= 0)\n    return 0;\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f2029/main_2029.c"}
{"compilable":1,"function":"char *removeChar(char *s, char c) {\n    int n = 0;\n    char *sp = s;\n    do {\n        if (*sp == c)\n            n++;\n        else\n            *(sp - n) = *sp;\n    } while (*sp++ != '\\x00');\n    return s;\n}\n","function_prediction":"char *removeChar_name_conflict(char *str, char garbage) {\n  char *s;\n  int i;\n\n  for (s = str, i = 0; *s != '\\0'; s++) {\n    if (*s != garbage) {\n      *(s - i) = *s;\n    } else {\n      i++;\n    }\n  }\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/f508/main_508.c"}
{"compilable":0,"function":"int SDL_imageFilterMeanMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength, unsigned char *Mask) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterMeanMMX_name_conflict(void *src, Uint8 *dst, int dstp, int w, int h,\n                           int depth) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f2062/main_2062.c"}
{"compilable":0,"function":"static inline unsigned char *foo(unsigned char *to, const unsigned char *from, int n) {\n    switch (n) {\n      case 3:\n        *to = *from;\n        break;\n      case 5:\n        to[4] = from[4];\n        break;\n    }\n    return to;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f811/main_811.c"}
{"compilable":1,"function":"char *tt_strdelim(char *buf, int *cnt, char delim, char esc) {\n    char *src = buf;\n    char *dst = ((void *)0);\n    *cnt = 0;\n    while (*src != esc)\n        {\n            if (0 == *src)\n                return src;\n            if (delim == *src)\n                return src;\n            ++src;\n        }\n    ++(*cnt);\n    dst = src;\n    ++src;\n    if (0 == *src)\n        return src;\n    *dst = *src;\n    ++src;\n    ++dst;\n    while (0 != *src)\n        {\n            if (*src == esc) {\n                ++(*cnt);\n                ++src;\n                if (0 == *src)\n                    return src;\n                *dst = *src;\n            } else {\n                if (delim == *src) {\n                    return dst;\n                }\n                *dst = *src;\n            }\n            ++dst;\n            ++src;\n        }\n    return dst;\n}\n","function_prediction":"char *tt_strdelim_name_conflict(char *s, int *count, char delim, char escape) {\n  char *d;\n  char *p;\n\n  *count = 0;\n  for (p = s; *p != escape; p++) {\n    if (*p == '\\0')\n      return p;\n    if (*p == delim)\n      return p;\n  }\n  (*count)++;\n  p++;\n  if (*p == '\\0')\n    return p;\n  d = s;\n  while (1) {\n    if (*p == escape) {\n      (*count)++;\n      p++;\n      if (*p == '\\0')\n        return p;\n      *d++ = *p++;\n    } else if (*p == delim) {\n      return d;\n    } else {\n      *d++ = *p++;\n    }\n    if (*p == '\\0')\n      return d;\n  }\n}","pass":0,"source_file":"C_COMPILE/f117/main_117.c"}
{"compilable":1,"function":"static int get_mount_flags(const char *path, unsigned long *flags) {\n    struct statvfs buf;\n    if (statvfs(path, &buf) < 0)\n        return -(*__errno_location());\n    *flags = buf.f_flag;\n    return 0;\n}\n","function_prediction":"int get_mount_flags_name_conflict(const char *path, unsigned long *flags) {\n  struct statvfs st_fs;\n  int ret;\n\n  ret = statvfs(path, &st_fs);\n  if (ret < 0)\n    return -*__errno_location();\n\n  *flags = st_fs.f_flag;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1686/main_1686.c"}
{"compilable":1,"function":"int MPI_Get_version(int *major, int *minor) {\n    if (!major || !minor)\n        return -1;\n    *major = 1;\n    *minor = 2;\n    return 0;\n}\n","function_prediction":"int MPI_Get_version_name_conflict(int *version, int *subversion) {\n  if (version == NULL || subversion == NULL)\n    return -1;\n  *version = 1;\n  *subversion = 2;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f2093/main_2093.c"}
{"compilable":1,"function":"int read_buff(int fd, unsigned char *data, ssize_t size) {\n    char *ptr = data;\n    ssize_t n;\n    ssize_t sz = size;\n    while (sz > 0)\n        {\n            n = read(fd, ptr, sz);\n            if (n <= 0)\n                return -1;\n            sz -= n;\n            ptr += n;\n        }\n    return size;\n}\n","function_prediction":"ssize_t read_buff_name_conflict(int fd, void *buf, size_t count) {\n  ssize_t n;\n  while (count > 0) {\n    n = read(fd, buf, count);\n    if (n <= 0)\n      return -1;\n    count -= n;\n    buf += n;\n  }\n  return count;\n}","pass":0,"source_file":"C_COMPILE/f415/main_415.c"}
{"compilable":1,"function":"int Q_rand(int *seed) {\n    *seed = (69069 * *seed + 1);\n    return *seed;\n}\n","function_prediction":"int Q_rand_name_conflict(int *seed) {\n  *seed = *seed * 31337 + 1;\n  return *seed;\n}","pass":0,"source_file":"C_COMPILE/f809/main_809.c"}
{"compilable":1,"function":"unsigned int scan_ulong(const char *s, unsigned long *u) {\n    unsigned int pos = 0;\n    unsigned long result = 0;\n    unsigned long c;\n    while ((c = (unsigned long)(unsigned char)(s[pos] - '0')) < 10)\n        {\n            result = result * 10 + c;\n            ++pos;\n        }\n    *u = result;\n    return pos;\n}\n","function_prediction":"int scan_ulong_name_conflict(const char *str, unsigned long *val) {\n  unsigned long v = 0;\n  int i = 0;\n\n  while (1) {\n    unsigned char c = str[i] - '0';\n    if (c > 9)\n      break;\n    v = v * 10 + c;\n    i++;\n  }\n\n  *val = v;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f1559/main_1559.c"}
{"compilable":1,"function":"char *read_sign(char *s, int *sign) {\n    if (*s == '-') {\n        *sign = -1;\n        return s + 1;\n    } else {\n        *sign = 1;\n        return s;\n    }\n}\n","function_prediction":"char *read_sign_name_conflict(char *str, int *sign) {\n  if (*str == '-') {\n    *sign = -1;\n    str++;\n  } else {\n    *sign = 1;\n  }\n  return str;\n}","pass":1,"source_file":"C_COMPILE/f1530/main_1530.c"}
{"compilable":1,"function":"int transport_sendPacketBuffer(int sock, unsigned char *buf, int buflen) {\n    int rc = 0;\n    rc = write(sock, buf, buflen);\n    return rc;\n}\n","function_prediction":"int transport_sendPacketBuffer_name_conflict(int sock, char *buffer, int size) {\n  return write(sock, buffer, size);\n}","pass":1,"source_file":"C_COMPILE/f386/main_386.c"}
{"compilable":1,"function":"char *my_str_cpy(char *dst, char *src) {\n    if (dst == ((void *)0) || src == ((void *)0))\n        return ((void *)0);\n    char *addr = dst;\n    while ((*dst++ = *src++))\n        ;\n    return addr;\n}\n","function_prediction":"char *my_str_cpy_name_conflict(char *dest, const char *src) {\n  char *tmp;\n\n  if (dest == NULL || src == NULL)\n    return (NULL);\n  tmp = dest;\n  while ((*dest++ = *src++) != '\\0')\n    ;\n  return (tmp);\n}","pass":1,"source_file":"C_COMPILE/f873/main_873.c"}
{"compilable":1,"function":"int MyHostName(char *nameOut, int maxNameLength) {\n    int k = gethostname(nameOut, maxNameLength);\n    return k == 0;\n}\n","function_prediction":"int MyHostName_name_conflict(char *hostname, int len) { return !gethostname(hostname, len); }","pass":1,"source_file":"C_COMPILE/f198/main_198.c"}
{"compilable":0,"function":"static int utf32_utf8(char *buf, int k) {\n    int retval = 0;\n    if (k < 128) {\n        buf[0] = k;\n        retval = 1;\n    } else if (k < 2048) {\n        buf[0] = 192 | (k >> 6);\n        buf[1] = 128 | (k & 63);\n        retval = 2;\n    } else if (k < 65536) {\n        buf[0] = 224 | (k >> 12);\n        buf[1] = 128 | ((k >> 6) & 63);\n        buf[2] = 128 | (k & 63);\n        retval = 3;\n    } else if (k < 2097152) {\n        buf[0] = 240 | (k >> 18);\n        buf[1] = 128 | ((k >> 12) & 63);\n        buf[2] = 128 | ((k >> 6) & 63);\n        buf[3] = 128 | (k & 63);\n        retval = 4;\n    } else if (k < 67108864) {\n        buf[0] = 248 | (k >> 24);\n        buf[1] = 128 | ((k >> 18) & 63);\n        buf[2] = 128 | ((k >> 12) & 63);\n        buf[3] = 128 | ((k >> 6) & 63);\n        buf[4] = 128 | (k & 63);\n        retval = 5;\n    } else {\n        buf[0] = 252 | (k >> 30);\n        buf[1] = 128 | ((k >> 24) & 63);\n        buf[2] = 128 | ((k >> 18) & 63);\n        buf[3] = 128 | ((k >> 12) & 63);\n        buf[4] = 128 | ((k >> 6) & 63);\n        buf[5] = 128 | (k & 63);\n        retval = 6;\n    }\n    buf[retval] = '\\x00';\n    return retval;\n}\n","function_prediction":"int utf32_utf8_name_conflict(char *out, uint32_t in) {\n  int len;\n\n  if (in < 0x80) {\n    out[0] = in;\n    len = 1;\n  } else if (in < 0x800) {\n    out[0] = 0xC0 | (in >> 6);\n    out[1] = 0x80 | (in & 0x3F);\n    len = 2;\n  } else if (in < 0x10000) {\n    out[0] = 0xE0 | (in >> 12);\n    out[1] = 0x80 | ((in >> 6) & 0x3F);\n    out[2] = 0x80 | (in & 0x3F);\n    len = 3;\n  } else if (in < 0x200000) {\n    out[0] = 0xF0 | (in >> 18);\n    out[1] = 0x80 | ((in >> 12) & 0x3F);\n    out[2] = 0x80 | ((in >> 6) & 0x3F);\n    out[3] = 0x80 | (in & 0x3F);\n    len = 4;\n  } else if (in < 0x4000000) {\n    out[0] = 0xF8 | (in >> 24);\n    out[1] = 0x80 | ((in >> 18) & 0x3F);\n    out[2] = 0x80 | ((in >> 12) & 0x3F);\n    out[3] = 0x80 | ((in >> 6) & 0x3F);\n    out[4] = 0x80 | (in & 0x3F);\n    len = 5;\n  } else {\n    out[0] = 0xFC | (in >> 30);\n    out[1] = 0x80 | ((in >> 24) & 0x3F);\n        out[","pass":0,"source_file":"C_COMPILE/f1601/main_1601.c"}
{"compilable":1,"function":"int VerifierNombre(char *ch, int *nb) {\n    char type;\n    int i = 0;\n    *nb = 0;\n    while (ch[i] != '\\x00')\n        {\n            if ((ch[i] >= '0') && (ch[i] <= '9')) {\n                *nb = *nb * 10 + ch[i] - '0';\n            } else if (ch[i] == '-') {\n                *nb = (*nb) * -1;\n                return 1;\n            } else {\n                return 0;\n            }\n            i++;\n        }\n    return 1;\n}\n","function_prediction":"int VerifierNombre_name_conflict(char *chaine, int *nombre) {\n  int i;\n\n  *nombre = 0;\n  for (i = 0; chaine[i] != '\\0'; i++) {\n    if (chaine[i] < '0' || chaine[i] > '9') {\n      if (chaine[i] == '-') {\n        *nombre = -*nombre;\n        return 1;\n      } else\n        return 0;\n    }\n    *nombre = *nombre * 10 + chaine[i] - '0';\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/f292/main_292.c"}
{"compilable":1,"function":"int foo(int *p) {\n    if ((*p = 0)) {\n        return 32;\n    }\n    return 52;\n}\n","function_prediction":"int foo_name_conflict(int *p) {\n  *p = 0;\n  if (*p)\n    return 32;\n  else\n    return 52;\n}","pass":1,"source_file":"C_COMPILE/f1224/main_1224.c"}
{"compilable":1,"function":"int is_swapped(int *a, int *b) {\n    int temp, va, vb;\n    va = *a;\n    vb = *b;\n    if (va == vb)\n        return 0;\n    else if (va > vb) {\n        temp = *a;\n        *a = *b;\n        *b = temp;\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int is_swapped_name_conflict(int *a, int *b) {\n  if (*a == *b)\n    return 0;\n  if (*a > *b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f639/main_639.c"}
{"compilable":1,"function":"int sceltaPrimaClasse(unsigned int mappaPosti[], unsigned int postiPrimaClasse) {\n    size_t indiceMappaPosti;\n    indiceMappaPosti = 0;\n    do {\n        if (mappaPosti[indiceMappaPosti] == 0) {\n            mappaPosti[indiceMappaPosti] = 1;\n            return (indiceMappaPosti + 1);\n        } else {\n            indiceMappaPosti++;\n        }\n    } while (indiceMappaPosti < postiPrimaClasse);\n    return 0;\n}\n","function_prediction":"int sceltaPrimaClasse_name_conflict(int *classe, unsigned int n) {\n  unsigned int i;\n\n  for (i = 0; i < n; i++)\n    if (classe[i] == 0) {\n      classe[i] = 1;\n      return i + 1;\n    }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f58/main_58.c"}
{"compilable":0,"function":"__attribute__((unused)) static inline unsigned short psnip_builtin_addcs(unsigned short x, unsigned short y, unsigned short ci, unsigned short *co) {\n    unsigned short max = 0;\n    unsigned short r = (unsigned short)x + y;\n    max = ~max;\n    *co = (unsigned short)(x > (max - y));\n    if (ci) {\n        if (r == max)\n            *co = 1;\n        r += ci;\n    }\n    return r;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f142/main_142.c"}
{"compilable":1,"function":"int kstrcpy(char *dst, const char *src) {\n    int i = 0;\n    while ((dst[i] = src[i++]))\n        ;\n    return i;\n}\n","function_prediction":"int kstrcpy_name_conflict(char *dest, const char *src) {\n  int i;\n\n  for (i = 0; (dest[i + 1] = src[i]) != '\\0'; i++)\n    ;\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f30/main_30.c"}
{"compilable":1,"function":"int init_send_buffer(unsigned short *index) {\n    *index = 4;\n    return (*index);\n}\n","function_prediction":"unsigned short init_send_buffer_name_conflict(unsigned short *buffer) {\n  *buffer = 4;\n  return *buffer;\n}","pass":1,"source_file":"C_COMPILE/f304/main_304.c"}
{"compilable":1,"function":"char *str_replace_set(char *string, const char *set, char replacement) {\n    if (string == ((void *)0) || set == ((void *)0))\n        return ((void *)0);\n    char *e = string;\n    while (*e)\n        {\n            if (strchr(set, *e) != ((void *)0))\n                *e = replacement;\n            ++e;\n        }\n    return string;\n}\n","function_prediction":"char *str_replace_set_name_conflict(char *str, const char *set, char c) {\n  char *p;\n\n  if (!str || !set)\n    return NULL;\n\n  for (p = str; *p; p++)\n    if (strchr(set, *p))\n      *p = c;\n\n  return str;\n}","pass":1,"source_file":"C_COMPILE/f2027/main_2027.c"}
{"compilable":1,"function":"int UTF2UnicodeOne(const char *utf8, wchar_t *wch) {\n    unsigned char firstCh = utf8[0];\n    int k;\n    if (firstCh >= 192) {\n        int afters, code;\n        if ((firstCh & 224) == 192) {\n            afters = 2;\n            code = firstCh & 31;\n        } else if ((firstCh & 240) == 224) {\n            afters = 3;\n            code = firstCh & 15;\n        } else if ((firstCh & 248) == 240) {\n            afters = 4;\n            code = firstCh & 7;\n        } else if ((firstCh & 252) == 248) {\n            afters = 5;\n            code = firstCh & 3;\n        } else if ((firstCh & 254) == 252) {\n            afters = 6;\n            code = firstCh & 1;\n        } else {\n            *wch = firstCh;\n            return 1;\n        }\n        for (k = 1; k < afters; k++) {\n            if ((utf8[k] & 192) != 128) {\n                *wch = firstCh;\n                return 1;\n            }\n            code <<= 6;\n            code |= (unsigned char)utf8[k] & 63;\n        }\n        *wch = code;\n        return afters;\n    } else {\n        *wch = firstCh;\n    }\n    return 1;\n}\n","function_prediction":"int UTF2UnicodeOne_name_conflict(const char *p, unsigned int *u) {\n  unsigned int c;\n  int i, n;\n\n  c = (unsigned char)*p;\n  if (c < 0xC0) {\n    *u = c;\n    return 1;\n  }\n  if ((c & 0xE0) == 0xC0) {\n    n = 2;\n    c &= 0x1F;\n  } else if ((c & 0xF0) == 0xE0) {\n    n = 3;\n    c &= 0x0F;\n  } else if ((c & 0xF8) == 0xF0) {\n    n = 4;\n    c &= 0x07;\n  } else if ((c & 0xFC) == 0xF8) {\n    n = 5;\n    c &= 0x03;\n  } else if ((c & 0xFE) == 0xFC) {\n    n = 6;\n    c &= 0x01;\n  } else {\n    *u = c;\n    return 1;\n  }\n  for (i = 1; i < n; i++) {\n    if ((p[i] & 0xC0) != 0x80) {\n      *u = c;\n      return 1;\n    }\n    c = (c << 6) | (p[i] & 0x3F);\n  }\n  *u = c;\n  return n;\n}","pass":1,"source_file":"C_COMPILE/f162/main_162.c"}
{"compilable":0,"function":"int SDL_imageFilterBitNegationMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterBitNegationMMX_name_conflict(void *src, void *dst, Uint32 src_pitch,\n                                  Uint32 dst_pitch, Uint32 width,\n                                  Uint32 height) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f972/main_972.c"}
{"compilable":0,"function":"int stream_create(char *filename, int *handle) {\n    if (filename)\n        *handle = 2;\n    else\n        *handle = 2;\n    return (0);\n}\n","function_prediction":"int stream_create_name_conflict(const char *filename, stream_t *stream) {\n  if (filename == NULL) {\n    stream->fd = 2;\n  } else {\n    stream->fd = 2;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1826/main_1826.c"}
{"compilable":1,"function":"unsigned int lte_gold_generic(unsigned int *x1, unsigned int *x2, unsigned char reset) {\n    int n;\n    if (reset) {\n        *x1 = 1 + (1 << 31);\n        *x2 = *x2 ^ ((*x2 ^ (*x2 >> 1) ^ (*x2 >> 2) ^ (*x2 >> 3)) << 31);\n        for (n = 1; n < 50; n++) {\n            *x1 = (*x1 >> 1) ^ (*x1 >> 4);\n            *x1 = *x1 ^ (*x1 << 31) ^ (*x1 << 28);\n            *x2 = (*x2 >> 1) ^ (*x2 >> 2) ^ (*x2 >> 3) ^ (*x2 >> 4);\n            *x2 = *x2 ^ (*x2 << 31) ^ (*x2 << 30) ^ (*x2 << 29) ^ (*x2 << 28);\n        }\n    }\n    *x1 = (*x1 >> 1) ^ (*x1 >> 4);\n    *x1 = *x1 ^ (*x1 << 31) ^ (*x1 << 28);\n    *x2 = (*x2 >> 1) ^ (*x2 >> 2) ^ (*x2 >> 3) ^ (*x2 >> 4);\n    *x2 = *x2 ^ (*x2 << 31) ^ (*x2 << 30) ^ (*x2 << 29) ^ (*x2 << 28);\n    return (*x1 ^ *x2);\n}\n","function_prediction":"uint32_t lte_gold_generic_name_conflict(uint32_t *a, uint32_t *b, char init) {\n  int i;\n\n  if (init) {\n    *a = 1;\n    *b ^= (*b >> 1) ^ (*b >> 2) ^ (*b >> 3) ^ (*b >> 4);\n    for (i = 1; i < 50; i++) {\n      *a = (*a >> 1) ^ (*a >> 4) ^ (*a << 28);\n      *b = (*b >> 1) ^ (*b >> 2) ^ (*b >> 3) ^ (*b >> 4) ^ (*b << 28) ^\n           (*b << 27) ^ (*b << 26) ^ (*b << 25);\n    }\n  }\n  *a = (*a >> 1) ^ (*a >> 4) ^ (*a << 28);\n  *b = (*b >> 1) ^ (*b >> 2) ^ (*b >> 3) ^ (*b >> 4) ^ (*b << 28) ^ (*b << 27) ^\n       (*b << 26) ^ (*b << 25);\n  return *a ^ *b;\n}","pass":0,"source_file":"C_COMPILE/f1777/main_1777.c"}
{"compilable":0,"function":"static inline int bit_test_and_set(int offset, unsigned int *addr) {\n    unsigned int *i;\n    int mask, res;\n    i = addr + offset / 32;\n    mask = 1U << (offset % 32);\n    res = ((*i) & mask) ? 1 : 0;\n    (*i) |= mask;\n    return res;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1748/main_1748.c"}
{"compilable":1,"function":"int swap(int *i, int *j) {\n    int tmp = *i;\n    *i = *j;\n    *j = tmp;\n    return 0;\n}\n","function_prediction":"int swap_name_conflict(int *a, int *b) {\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f2061/main_2061.c"}
{"compilable":1,"function":"char *appendInt(char *text, int intValue) {\n    char *ptrText = text;\n    int value = intValue;\n    int div = 1000000000;\n    bool zeroIsSignificant = 0;\n    if (value < 0) {\n        value = -value;\n        *ptrText = '-';\n        ptrText++;\n    }\n    do {\n        int quot = value / div;\n        if ((quot != 0) || zeroIsSignificant) {\n            zeroIsSignificant = 1;\n            *ptrText = (char)quot + '0';\n            ptrText++;\n            value -= quot * div;\n        }\n        div /= 10;\n    } while (div > 1);\n    *ptrText = (char)value + '0';\n    ptrText++;\n    *ptrText = 0;\n    return ptrText;\n}\n","function_prediction":"char *appendInt_name_conflict(char *s, int x) {\n  char *p = s;\n  int digit, seen = 0;\n  if (x < 0) {\n    *p++ = '-';\n    x = -x;\n  }\n  for (int i = 1000000000; i >= 1; i /= 10) {\n    digit = x / i;\n    if (digit != 0 || seen) {\n      seen = 1;\n      *p++ = '0' + digit;\n      x -= digit * i;\n    }\n  }\n  *p++ = '0' + x;\n  *p++ = '\\0';\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f2104/main_2104.c"}
{"compilable":1,"function":"int FABSS(unsigned long *rd, unsigned long *rs2) {\n    rd[0] = rs2[0] & 2147483647UL;\n    return 1;\n}\n","function_prediction":"int FABSS_name_conflict(uint32_t *dest, uint32_t *src) {\n  *dest = *src & 0x7FFFFFFF;\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f1414/main_1414.c"}
{"compilable":1,"function":"int buscarCoincidencia(char *ventana, char *buffer, int *posicion) {\n    int longitud, maxLongitud, i, j;\n    maxLongitud = 0;\n    for (i = 0; i < 8192; i++) {\n        longitud = 0;\n        for (j = 0; j < 8192; j++) {\n            if (ventana[i + j] == buffer[j]) {\n                longitud++;\n            } else {\n                break;\n            }\n            if (longitud > maxLongitud) {\n                *posicion = i;\n                maxLongitud = longitud;\n            }\n            if (maxLongitud == 15) {\n                break;\n            }\n        }\n    }\n    return maxLongitud;\n}\n","function_prediction":"int buscarCoincidencia_name_conflict(char *texto, char *patron, int *posicion) {\n  int i, j, k, coincidencias, maxCoincidencias;\n\n  maxCoincidencias = 0;\n  for (i = 0; i < 8192; i++) {\n    coincidencias = 0;\n    for (j = 0; j < 8192; j++) {\n      if (texto[i + j] == patron[j]) {\n        coincidencias++;\n        if (coincidencias > maxCoincidencias) {\n          maxCoincidencias = coincidencias;\n          *posicion = i;\n        }\n        if (maxCoincidencias == 15)\n          break;\n      } else\n        break;\n    }\n  }\n  return maxCoincidencias;\n}","pass":0,"source_file":"C_COMPILE/f290/main_290.c"}
{"compilable":1,"function":"int squeeze(char s1[], char s2[]) {\n    int i, j, k;\n    for (i = k = 0; s1[i] != '\\x00'; i++) {\n        for (j = 0; s2[j] != '\\x00' && s2[j] != s1[i]; j++)\n            ;\n        if (s2[j] == '\\x00') {\n            s1[k++] = s1[i];\n        }\n    }\n    s1[k] = '\\x00';\n    return 0;\n}\n","function_prediction":"int squeeze_name_conflict(char s1[], char s2[]) {\n  int i, j, k;\n\n  for (i = j = 0; s1[i] != '\\0'; i++) {\n    for (k = 0; s2[k] != '\\0' && s2[k] != s1[i]; k++)\n      ;\n    if (s2[k] == '\\0')\n      s1[j++] = s1[i];\n  }\n  s1[j] = '\\0';\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1347/main_1347.c"}
{"compilable":1,"function":"char *strcpy_e(char *dest, const char *src) {\n    for (; *src; ++src , ++dest)\n        *dest = *src;\n    *dest = 0;\n    return dest;\n}\n","function_prediction":"char *strcpy_e_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  while (*s)\n    *d++ = *s++;\n  *d = '\\0';\n\n  return d;\n}","pass":1,"source_file":"C_COMPILE/f1411/main_1411.c"}
{"compilable":1,"function":"int manos_socket_listen(int fd, int backlog, int *err) {\n    int result;\n    result = listen(fd, backlog);\n    *err = (*__errno_location());\n    return result;\n}\n","function_prediction":"int manos_socket_listen_name_conflict(int sockfd, int backlog, int *err) {\n  int ret = listen(sockfd, backlog);\n  *err = *__errno_location();\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/f444/main_444.c"}
{"compilable":1,"function":"unsigned int btsl_reg(unsigned int reg_in, int bitno, unsigned int *reg_out_p) {\n    unsigned char res;\n    unsigned int reg_out;\n    asm volatile (\"movl\\t%3, %%eax\\n\\tbtsl\\t%2, %%eax\\n\\tmovl\\t%%eax, %1\\n\\tsetc\\t%0\" : \"=q\" (res), \"=r\" (reg_out) : \"r\" (bitno), \"r\" (reg_in) : \"cc\", \"eax\");\n    *reg_out_p = reg_out;\n    return res;\n}\n","function_prediction":"int btsl_reg_name_conflict(uint32_t reg, uint32_t bit, uint32_t *out) {\n  *out = reg | (1 << bit);\n  return !!(reg & (1 << bit));\n}","pass":1,"source_file":"C_COMPILE/f1373/main_1373.c"}
{"compilable":0,"function":"int get_rpx(long *robot_pos) {\n    *robot_pos = -1;\n    return (0);\n}\n","function_prediction":"int get_rpx_name_conflict(struct rpx_t *rpx) {\n  rpx->fd = -1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1999/main_1999.c"}
{"compilable":0,"function":"int SDL_imageFilterAbsDiffMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterAbsDiffMMX_name_conflict(Uint8 *src1, Uint8 *src2, Uint8 *dst,\n                              int pixelStep, int w, int h) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f2106/main_2106.c"}
{"compilable":1,"function":"int gcdExtended(int a, int b, int *x, int *y) {\n    if (a == 0) {\n        *x = 0;\n        *y = 1;\n        return b;\n    }\n    int x1, y1;\n    int gcd = gcdExtended(b % a, a, &x1, &y1);\n    *x = y1 - (b / a) * x1;\n    *y = x1;\n    return gcd;\n}\n","function_prediction":"int gcdExtended_name_conflict(int a, int b, int *x, int *y) {\n  int x1, y1;\n  int gcd;\n\n  if (a == 0) {\n    *x = 0;\n    *y = 1;\n\n    return b;\n  }\n\n  gcd = gcdExtended_name_conflict(b % a, a, &x1, &y1);\n\n  *x = y1 - (b / a) * x1;\n  *y = x1;\n\n  return gcd;\n}","pass":1,"source_file":"C_COMPILE/f1174/main_1174.c"}
{"compilable":1,"function":"char *j_strcat(char *dest, char *txt) {\n    if (!txt)\n        return (dest);\n    while (*txt)\n        *dest++ = *txt++;\n    *dest = '\\x00';\n    return (dest);\n}\n","function_prediction":"char *j_strcat_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  if (src) {\n    while (*src)\n      *d++ = *src++;\n    *d = '\\0';\n  }\n  return dest;\n}","pass":0,"source_file":"C_COMPILE/f1621/main_1621.c"}
{"compilable":1,"function":"char *ft_rot42(char *str) {\n    int i;\n    i = 0;\n    while (str[i])\n        {\n            if (str[i] >= 65 && str[i] <= 90) {\n                str[i] = str[i] - 65;\n                str[i] = ((str[i] + 42) % 26);\n                str[i] = str[i] + 65;\n            } else if (str[i] >= 97 && str[i] <= 122) {\n                str[i] = str[i] - 97;\n                str[i] = ((str[i] + 42) % 26);\n                str[i] = str[i] + 97;\n            }\n            i++;\n        }\n    return (str);\n}\n","function_prediction":"char *ft_rot42_name_conflict(char *str) {\n  int i;\n\n  i = 0;\n  while (str[i]) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      str[i] -= 'A';\n      str[i] = (str[i] + 42) % 26;\n      str[i] += 'A';\n    } else if (str[i] >= 'a' && str[i] <= 'z') {\n      str[i] -= 'a';\n      str[i] = (str[i] + 42) % 26;\n      str[i] += 'a';\n    }\n    i++;\n  }\n  return (str);\n}","pass":1,"source_file":"C_COMPILE/f1898/main_1898.c"}
{"compilable":1,"function":"unsigned int header_decode(unsigned int header, int *packetID, int *srcAddr, int *dstAddr, int *packetLength, int noc_size) {\n    int i;\n    int oneCounter = 0;\n    *packetID = (header & 255);\n    *srcAddr = (header & 3840) >> 24;\n    *dstAddr = (header & 61440) >> 28;\n    *packetLength = (header & 268369920) >> 16;\n    for (i = 0; i < 8; i++) {\n        oneCounter += (*packetID & (1 << i)) != 0 ? 1 : 0;\n    }\n    if (oneCounter != 1) {\n        return 1;\n    } else if (*srcAddr > noc_size) {\n        return 2;\n    } else if (*dstAddr > noc_size) {\n        return 3;\n    } else if (dstAddr == srcAddr) {\n        return 4;\n    } else if (*packetLength < 2) {\n        return 5;\n    } else {\n        return 0;\n    }\n}\n","function_prediction":"int header_decode_name_conflict(uint32_t header, uint8_t *version, uint8_t *type,\n                  uint8_t *subtype, uint16_t *length, uint16_t max_length) {\n  uint8_t i;\n  uint8_t bit_count = 0;\n\n  *version = (header & 0xFF);\n  *type = 0;\n  *subtype = 0;\n  *length = (header >> 16) & 0xFFF;\n\n  for (i = 0; i < 8; i++) {\n    bit_count += ((*version >> i) & 1);\n  }\n\n  if (bit_count != 1) {\n    return 1;\n  }\n\n  if (*type > max_length) {\n    return 2;\n  }\n\n  if (*subtype > max_length) {\n    return 3;\n  }\n\n  if (*type == *subtype) {\n    return 4;\n  }\n\n  if (*length < 2) {\n    return 5;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f473/main_473.c"}
{"compilable":1,"function":"char chrrpl(char *str, char c, char d) {\n    if (c == d)\n        return 0;\n    str = strchr(str, c);\n    if (str == ((void *)0))\n        return 0;\n    while (str != ((void *)0))\n        {\n            str[0] = d;\n            str = strchr(str, c);\n        }\n    return 1;\n}\n","function_prediction":"int chrrpl_name_conflict(char *s, char c, char r) {\n  char *p;\n\n  if (c == r)\n    return 0;\n\n  p = strchr(s, c);\n  if (p == NULL)\n    return 0;\n\n  while (p != NULL) {\n    *p = r;\n    p = strchr(p, c);\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f63/main_63.c"}
{"compilable":1,"function":"int Serial_ReadData(int portId, unsigned char *buf, int length) {\n    return read(portId, buf, length);\n}\n","function_prediction":"int Serial_ReadData_name_conflict(int fd, unsigned char *buf, int len) {\n  return read(fd, buf, len);\n}","pass":1,"source_file":"C_COMPILE/f234/main_234.c"}
{"compilable":0,"function":"int registra_venda(int *produto, int valor_desconto) {\n    if (*produto >= valor_desconto) {\n        (*produto) -= valor_desconto;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n","function_prediction":"int registra_venda_name_conflict(struct produto *p, int quantidade) {\n  if (p->estoque >= quantidade) {\n    p->estoque -= quantidade;\n    return 1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f751/main_751.c"}
{"compilable":0,"function":"int file_getoptions(int *options) {\n    *options = 0;\n    return (0);\n}\n","function_prediction":"int file_getoptions_name_conflict(struct file_options *options) {\n  options->flags = 0;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1195/main_1195.c"}
{"compilable":1,"function":"int anetSockName(int fd, char *ip, size_t ip_len, int *port) {\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof (sa);\n    if (getsockname(fd, (struct sockaddr *)&sa, &salen) == -1) {\n        if (port)\n            *port = 0;\n        ip[0] = '?';\n        ip[1] = '\\x00';\n        return -1;\n    }\n    if (sa.ss_family == 2) {\n        struct sockaddr_in *s = (struct sockaddr_in *)&sa;\n        if (ip)\n            inet_ntop(2, (void *)&(s->sin_addr), ip, ip_len);\n        if (port)\n            *port = ntohs(s->sin_port);\n    } else {\n        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;\n        if (ip)\n            inet_ntop(10, (void *)&(s->sin6_addr), ip, ip_len);\n        if (port)\n            *port = ntohs(s->sin6_port);\n    }\n    return 0;\n}\n","function_prediction":"int anetSockName_name_conflict(int fd, char *ip, size_t ip_len, int *port) {\n  struct sockaddr_storage sa;\n  socklen_t salen = sizeof(sa);\n\n  if (getsockname(fd, (struct sockaddr *)&sa, &salen) == -1) {\n    if (port)\n      *port = 0;\n    ip[0] = '?';\n    ip[1] = '\\0';\n    return -1;\n  }\n\n  if (sa.ss_family == AF_INET) {\n    struct sockaddr_in *s = (struct sockaddr_in *)&sa;\n    if (ip)\n      inet_ntop(AF_INET, &s->sin_addr, ip, ip_len);\n    if (port)\n      *port = ntohs(s->sin_port);\n  } else {\n    struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;\n    if (ip)\n      inet_ntop(AF_INET6, &s->sin6_addr, ip, ip_len);\n    if (port)\n      *port = ntohs(s->sin6_port);\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f595/main_595.c"}
{"compilable":1,"function":"char *ltoa(long value, char *result, int base) {\n    if (base < 2 || base > 36) {\n        *result = '\\x00';\n        return result;\n    }\n    char *ptr = result, *ptr1 = result, tmp_char;\n    long tmp_value;\n    do {\n        tmp_value = value;\n        value /= base;\n        *ptr++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\"[35 + (tmp_value - value * base)];\n    } while (value);\n    if (tmp_value < 0)\n        *ptr++ = '-';\n    *ptr-- = '\\x00';\n    while (ptr1 < ptr)\n        {\n            tmp_char = *ptr;\n            *ptr-- = *ptr1;\n            *ptr1++ = tmp_char;\n        }\n    return result;\n}\n","function_prediction":"char *ltoa_name_conflict(long value, char *string, int radix) {\n  char *p = string;\n  char *y = string;\n  char temp;\n  long t;\n\n  if ((radix > 36) || (radix < 2)) {\n    *p = '\\0';\n    return string;\n  }\n\n  if (value < 0) {\n    *p++ = '-';\n    t = (0 - value);\n  } else {\n    t = value;\n  }\n\n  y = p;\n\n  do {\n    *p++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuv\"\n           \"wxyz\"[(int)(t % radix)];\n    t /= radix;\n  } while (t);\n\n  *p-- = '\\0';\n\n  while (y < p) {\n    temp = *p;\n    *p-- = *y;\n    *y++ = temp;\n  }\n\n  return string;\n}","pass":0,"source_file":"C_COMPILE/f109/main_109.c"}
{"compilable":1,"function":"static unsigned int prbs15_next_28_bits(unsigned short seed_rev, unsigned short *next_seed_rev) {\n    unsigned int prbs_result, temp;\n    prbs_result = seed_rev ^ (seed_rev >> 1);\n    temp = (prbs_result << (15)) | seed_rev;\n    prbs_result = (temp ^ (temp >> 1)) & 268435455;\n    if (next_seed_rev) {\n        *next_seed_rev = (unsigned short)(prbs_result >> ((28) - (15)));\n    }\n    return prbs_result;\n}\n","function_prediction":"unsigned prbs15_next_28_bits_name_conflict(unsigned short seed, unsigned short *crc) {\n  unsigned short tmp;\n  unsigned short x;\n\n  x = seed;\n  x |= x >> 1;\n  x ^= x >> 2;\n  x |= x >> 4;\n  x ^= x >> 8;\n  x |= x >> 16;\n  tmp = x;\n  x >>= 1;\n  x ^= tmp;\n  x &= 0x0FFFFFFF;\n  if (crc)\n    *crc = x >> 13;\n  return x;\n}","pass":0,"source_file":"C_COMPILE/f1400/main_1400.c"}
{"compilable":0,"function":"int insert_(int *k, int *lp, int *list, int *lptr, int *lnew) {\n    static int lsav;\n    --lptr;\n    --list;\n    lsav = lptr[*lp];\n    lptr[*lp] = *lnew;\n    list[*lnew] = *k;\n    lptr[*lnew] = lsav;\n    ++(*lnew);\n    return 0;\n}\n","function_prediction":"int insert__name_conflict(int *i, int *j, int *k, int *l, int *m) {\n\n  --l;\n  --k;\n  lsav_0 = l[*j];\n  l[*j] = *m;\n  k[*m] = *i;\n  l[*m] = lsav_0;\n  ++(*m);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f148/main_148.c"}
{"compilable":0,"function":"int SDL_imageFilterMultDivby2MMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length) {\n    return (0);\n}\n","function_prediction":"int SDL_imageFilterMultDivby2MMX_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/f1795/main_1795.c"}
{"compilable":0,"function":"inline _Bool SHAREMIND_MAP_KEY_INIT_unsigned_char(unsigned char *const dest) {\n    return ((void)dest , 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1186/main_1186.c"}
{"compilable":1,"function":"char *ltoa(char *result, int value, int base) {\n    if (base < 2 || base > 36) {\n        *result = '\\x00';\n        return result;\n    }\n    char *ptr = result, *ptr1 = result, tmp_char;\n    int tmp_value;\n    do {\n        tmp_value = value;\n        value /= base;\n        *ptr++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\"[35 + (tmp_value - value * base)];\n    } while (value);\n    if (tmp_value < 0)\n        *ptr++ = '-';\n    *ptr-- = '\\x00';\n    while (ptr1 < ptr)\n        {\n            tmp_char = *ptr;\n            *ptr-- = *ptr1;\n            *ptr1++ = tmp_char;\n        }\n    return result;\n}\n","function_prediction":"char *ltoa_name_conflict(char *s, long n, int base) {\n  char *s1, *s2;\n  int c;\n\n  if (base < 2 || base > 36) {\n    *s = '\\0';\n    return s;\n  }\n\n  s1 = s;\n  s2 = s;\n\n  do {\n    c = n % base;\n    n /= base;\n    *s1++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstu\"\n            \"vwxyz\"[c];\n  } while (n);\n\n  if (n < 0)\n    *s1++ = '-';\n\n  *s1-- = '\\0';\n\n  while (s2 < s1) {\n    c = *s1;\n    *s1-- = *s2;\n    *s2++ = c;\n  }\n\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f1188/main_1188.c"}
{"compilable":1,"function":"int strcopy(char *dst, char *src) {\n    int i = 0;\n    while (*src)\n        {\n            *dst++ = *src++;\n            i++;\n        }\n    return i;\n}\n","function_prediction":"int strcopy_name_conflict(char *dest, char *src) {\n  int i = 0;\n  while (*src) {\n    *dest = *src;\n    i++;\n    src++;\n    dest++;\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f1611/main_1611.c"}
{"compilable":0,"function":"static inline int atomic_dec(volatile int *a) {\n    unsigned char rc;\n    asm (\"lock; decl %0; sete %1\" : \"=m\" (*a), \"=qm\" (rc) : \"m\" (*a) : \"memory\");\n    return rc != 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1699/main_1699.c"}
{"compilable":1,"function":"static int mul_dbl(unsigned long m[2]) {\n    int rc;\n    asm (\"mul %4; seto %b2\" : \"=a\" (m[0]), \"=d\" (m[1]), \"=q\" (rc) : \"0\" (m[0]), \"1\" (m[1]), \"2\" (0));\n    return rc;\n}\n","function_prediction":"int mul_dbl_name_conflict(double *a) {\n  double b = *a;\n  *a *= b;\n  return *a != b;\n}","pass":1,"source_file":"C_COMPILE/f827/main_827.c"}
{"compilable":1,"function":"char *pridej_znak(char znak, char *kam) {\n    *kam = znak;\n    return ++kam;\n}\n","function_prediction":"char *pridej_znak_name_conflict(char znak, char *retezec) {\n  *retezec = znak;\n  return retezec + 1;\n}","pass":1,"source_file":"C_COMPILE/f1786/main_1786.c"}
{"compilable":1,"function":"int getch_(char *vec, char *ch, int *i) {\n    ch[0] = vec[*i - 1];\n    ch[1] = ' ';\n    ch[2] = ' ';\n    ch[3] = ' ';\n    return 0;\n}\n","function_prediction":"int getch__name_conflict(char *string, char *ch, int *pos) {\n\n  ch[0] = string[*pos - 1];\n  ch[1] = ' ';\n  ch[2] = ' ';\n  ch[3] = ' ';\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f852/main_852.c"}
{"compilable":0,"function":"static inline int is_4in6(unsigned char ipv6[16]) {\n    return !*((long long *)ipv6) && ((int *)ipv6)[2] == -65536;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1510/main_1510.c"}
{"compilable":1,"function":"char *itoa(char *str, int num) {\n    char *p = str;\n    char c;\n    int i;\n    int flag = 0;\n    *p++ = '0';\n    *p++ = 'x';\n    if (0 == num)\n        *p++ = '0';\n    else {\n        for (i = 28; i >= 0; i -= 4) {\n            c = (num >> i) & 15;\n            if (flag || (c > 0)) {\n                flag = 1;\n                c += '0';\n                if (c > '9') {\n                    c += 7;\n                }\n                *p++ = c;\n            }\n        }\n    }\n    *p = 0;\n    return str;\n}\n","function_prediction":"char *itoa_name_conflict(char *buf, int val) {\n  int i;\n  int j;\n  int k;\n  int c;\n  int first = 0;\n\n  buf[0] = '0';\n  buf[1] = 'x';\n  j = 2;\n\n  if (val == 0) {\n    buf[j++] = '0';\n  } else {\n    for (i = 28; i >= 0; i -= 4) {\n      k = (val >> i) & 0xF;\n      if (first || k != 0) {\n        first = 1;\n        c = k + '0';\n        if (c > '9') {\n          c = c - '0' + 'a' - 10;\n        }\n        buf[j++] = c;\n      }\n    }\n  }\n  buf[j] = '\\0';\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/f795/main_795.c"}
{"compilable":1,"function":"unsigned int FUZ_rand(unsigned int *src) {\n    *src = ((*src) * 2654435761U) + 2246822519U;\n    return *src;\n}\n","function_prediction":"uint32_t FUZ_rand_name_conflict(uint32_t *seed) {\n  *seed = *seed * 214013 + 2531011;\n  return *seed;\n}","pass":0,"source_file":"C_COMPILE/f430/main_430.c"}
{"compilable":0,"function":"static const char *findchar_fast(const char *buf, const char *buf_end, const char *ranges, size_t ranges_size, int *found) {\n    *found = 0;\n    (void)buf_end;\n    (void)ranges;\n    (void)ranges_size;\n    return buf;\n}\n","function_prediction":"char *findchar_fast_name_conflict(char *s, char *t, int *pos) {\n  *pos = 0;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f563/main_563.c"}
{"compilable":1,"function":"char *reverseString(char *s) {\n    char *h = s;\n    char *t = s;\n    char ch;\n    while (*t++)\n        {\n        }\n    ;\n    t--;\n    t--;\n    while (h < t)\n        {\n            ch = *h;\n            *h++ = *t;\n            *t-- = ch;\n        }\n    return (s);\n}\n","function_prediction":"char *reverseString_name_conflict(char *s) {\n  char *p = s;\n  char *q = s;\n  char temp;\n  while (*q != '\\0') {\n    q++;\n  }\n  q--;\n  while (p < q) {\n    temp = *p;\n    *p = *q;\n    *q = temp;\n    p++;\n    q--;\n  }\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f1037/main_1037.c"}
{"compilable":0,"function":"int readjpeg(char *name, int *xres, int *yres, unsigned char **imgdata) {\n    return 2;\n}\n","function_prediction":"int readjpeg_name_conflict(char *filename, int *width, int *height, int *channels,\n             unsigned char **data) {\n  return 2;\n}","pass":0,"source_file":"C_COMPILE/f1592/main_1592.c"}
{"compilable":1,"function":"int addr_sa_ntop(const struct sockaddr *sa, socklen_t slen, char *h, size_t hlen, char *p, size_t plen) {\n    if (sa == ((void *)0))\n        return (-1);\n    if (getnameinfo(sa, slen, h, hlen, p, plen, 1) == -1)\n        return (-1);\n    return (0);\n}\n","function_prediction":"int addr_sa_ntop_name_conflict(const struct sockaddr *sa, socklen_t salen, char *addr,\n                 size_t addrlen, char *port, size_t portlen) {\n  if (sa == NULL)\n    return -1;\n\n  if (getnameinfo(sa, salen, addr, addrlen, port, portlen, 0x0001) == -1)\n    return -1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f512/main_512.c"}
{"compilable":1,"function":"int getdents(int fd, unsigned char *buf, size_t size) {\n    return syscall(78, fd, buf, size);\n}\n","function_prediction":"int getdents_name_conflict(unsigned int fd, struct dirent *dirp, unsigned int count) {\n  return syscall(78, fd, dirp, count);\n}","pass":0,"source_file":"C_COMPILE/f992/main_992.c"}
{"compilable":0,"function":"inline _Bool SHAREMIND_MAP_KEY_COPY_unsigned_short(unsigned short *const dest, const unsigned short src) {\n    return (((*dest) = src) , 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f748/main_748.c"}
{"compilable":0,"function":"int RGB32toI420(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"int RGB32toI420_name_conflict(unsigned char *src, int src_stride, unsigned char *dst,\n                int dst_stride, int width, int height) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1445/main_1445.c"}
{"compilable":0,"function":"struct termios initTerms(int fd, struct termios config, int settings) {\n    if (settings) {\n        config.c_iflag &= ~(1 | 2 | 256 | 64 | 8 | 16 | 32 | 1024);\n        config.c_oflag = 0;\n        config.c_lflag &= ~(8 | 64 | 2 | 32768 | 1);\n        config.c_cflag &= ~(48 | 256);\n        config.c_cflag |= 48;\n        config.c_cc[6] = 1;\n        config.c_cc[5] = 0;\n    } else {\n        config.c_lflag &= ~2;\n    }\n    return config;\n}\n","function_prediction":"Terms initTerms_name_conflict(int is_empty) {\n  Terms terms;\n\n  terms.is_empty = is_empty;\n  terms.is_single = !is_empty;\n  terms.is_multiple = !is_empty;\n  terms.is_range = !is_empty;\n  terms.is_list = !is_empty;\n  terms.is_set = !is_empty;\n  terms.is_any = !is_empty;\n  terms.is_all = !is_empty;\n  terms.is_not = !is_empty;\n  terms.is_not_all = !is_empty;\n  terms.is_not_any = !is_empty;\n  terms.is_not_range = !is_empty;\n  terms.is_not_list = !is_empty;\n  terms.is_not_set = !is_empty;\n  terms.is_not_single = !is_empty;\n  terms.is_not_multiple = !is_empty;\n  terms.is_not_empty = !is_empty;\n  terms.is_not_not = !is_empty;\n  terms.is_not_not_all = !is_empty;\n  terms.is_not_not_any = !is_empty;\n  terms.is_not_not_range = !is_empty;\n  terms.is_not_not_list = !is_empty;\n  terms.is_not_not_set = !is_empty;\n  terms.is_not_not_single = !is_empty;\n  terms.is_not_not_multiple = !is_empty;\n  terms.is_not_not_empty = !is_empty;\n\n  return terms;\n}","pass":0,"source_file":"C_COMPILE/f1589/main_1589.c"}
{"compilable":1,"function":"char *mstpcpy(char *out, const char *in) {\n    size_t i;\n    i = 0;\n    while (in[i] != '\\x00')\n        {\n            out[i] = in[i];\n            i += 1;\n        }\n    out[i] = '\\x00';\n    return (&(out[i]));\n}\n","function_prediction":"char *mstpcpy_name_conflict(char *restrict dst, const char *restrict src) {\n  size_t i;\n\n  for (i = 0; src[i]; i++)\n    dst[i] = src[i];\n  dst[i] = '\\0';\n\n  return dst + i;\n}","pass":1,"source_file":"C_COMPILE/f1459/main_1459.c"}
{"compilable":1,"function":"int itoa(int val, char *buf) {\n    const unsigned int radix = 10;\n    char *p;\n    unsigned int a;\n    int len;\n    char *b;\n    char temp;\n    unsigned int u;\n    p = buf;\n    if (val < 0) {\n        *p++ = '-';\n        val = 0 - val;\n    }\n    u = (unsigned int)val;\n    b = p;\n    do {\n        a = u % radix;\n        u /= radix;\n        *p++ = a + '0';\n    } while (u > 0);\n    len = (int)(p - buf);\n    *p-- = 0;\n    do {\n        temp = *p;\n        *p = *b;\n        *b = temp;\n        --p;\n        ++b;\n    } while (b < p);\n    return len;\n}\n","function_prediction":"int itoa_name_conflict(int n, char s[]) {\n  int i, sign;\n  char *t;\n\n  if ((sign = n) < 0)\n    n = -n;\n  t = s;\n  do {\n    *s++ = n % 10 + '0';\n  } while ((n /= 10) > 0);\n  if (sign < 0)\n    *s++ = '-';\n  *s = '\\0';\n  for (i = 0; i < s - t; i++) {\n    char c = *(t + i);\n    *(t + i) = *(s - 1 - i);\n    *(s - 1 - i) = c;\n  }\n  return s - t;\n}","pass":0,"source_file":"C_COMPILE/f1818/main_1818.c"}
{"compilable":0,"function":"static char *strtok2(char *str, char *delim) {\n    static char *next = ((void *)0);\n    if (!str) {\n        str = next;\n    }\n    if (!str) {\n        return ((void *)0);\n    }\n    char *tmp = strpbrk(str, delim);\n    if (!tmp) {\n        next = ((void *)0);\n        return str;\n    }\n    *tmp = 0;\n    next = tmp + 1;\n    return str;\n}\n","function_prediction":"char *strtok2_name_conflict(char *s, const char *ct) {\n  char *p;\n\n  if (s == NULL)\n    s = next_0;\n  if (s == NULL)\n    return NULL;\n\n  p = strpbrk(s, ct);\n  if (p == NULL)\n    next_0 = NULL;\n  else {\n    *p = '\\0';\n    next_0 = p + 1;\n  }\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f1638/main_1638.c"}
{"compilable":1,"function":"char *my_strcpy(char *dest, char *src) {\n    char *adrr;\n    for (adrr = dest; *src; *dest++ = *src++)\n        ;\n    *dest++ = '\\x00';\n    return (adrr);\n}\n","function_prediction":"char *my_strcpy_name_conflict(char *dest, const char *src) {\n  char *saved_dest = dest;\n\n  while (*src)\n    *dest++ = *src++;\n  *dest = '\\0';\n  return (saved_dest);\n}","pass":1,"source_file":"C_COMPILE/f1575/main_1575.c"}
{"compilable":1,"function":"int func(int n, int *count) {\n    (*count)++;\n    if ((n == 0) || (n == 1)) {\n        return 1;\n    }\n    int val = 0;\n    int a = func(n - 1, count);\n    int b = func(n / 2, count);\n    val += a + b;\n    return val;\n}\n","function_prediction":"int func_name_conflict(int n, int *count) {\n  (*count)++;\n  if (n == 0 || n == 1)\n    return 1;\n  else\n    return func_name_conflict(n - 1, count) + func_name_conflict(n / 2, count);\n}","pass":1,"source_file":"C_COMPILE/f1604/main_1604.c"}
{"compilable":0,"function":"static inline int bit_test_and_reset(int offset, unsigned int *addr) {\n    unsigned int *i;\n    int mask, res;\n    i = addr + offset / 32;\n    mask = 1U << (offset % 32);\n    res = ((*i) & mask) ? 1 : 0;\n    (*i) &= ~mask;\n    return res;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1439/main_1439.c"}
{"compilable":0,"function":"int setserial(int s, struct termios *cfg, int speed, int data, unsigned char parity, int stopb) {\n    tcgetattr(s, cfg);\n    cfmakeraw(cfg);\n    switch (speed) {\n      case 50:\n        {\n            cfsetispeed(cfg, 1);\n            cfsetospeed(cfg, 1);\n            break;\n        }\n      case 75:\n        {\n            cfsetispeed(cfg, 2);\n            cfsetospeed(cfg, 2);\n            break;\n        }\n      case 110:\n        {\n            cfsetispeed(cfg, 3);\n            cfsetospeed(cfg, 3);\n            break;\n        }\n      case 134:\n        {\n            cfsetispeed(cfg, 4);\n            cfsetospeed(cfg, 4);\n            break;\n        }\n      case 150:\n        {\n            cfsetispeed(cfg, 5);\n            cfsetospeed(cfg, 5);\n            break;\n        }\n      case 200:\n        {\n            cfsetispeed(cfg, 6);\n            cfsetospeed(cfg, 6);\n            break;\n        }\n      case 300:\n        {\n            cfsetispeed(cfg, 7);\n            cfsetospeed(cfg, 7);\n            break;\n        }\n      case 600:\n        {\n            cfsetispeed(cfg, 8);\n            cfsetospeed(cfg, 8);\n            break;\n        }\n      case 1200:\n        {\n            cfsetispeed(cfg, 9);\n            cfsetospeed(cfg, 9);\n            break;\n        }\n      case 1800:\n        {\n            cfsetispeed(cfg, 10);\n            cfsetospeed(cfg, 10);\n            break;\n        }\n      case 2400:\n        {\n            cfsetispeed(cfg, 11);\n            cfsetospeed(cfg, 11);\n            break;\n        }\n      case 4800:\n        {\n            cfsetispeed(cfg, 12);\n            cfsetospeed(cfg, 12);\n            break;\n        }\n      case 9600:\n        {\n            cfsetispeed(cfg, 13);\n            cfsetospeed(cfg, 13);\n            break;\n        }\n      case 19200:\n        {\n            cfsetispeed(cfg, 14);\n            cfsetospeed(cfg, 14);\n            break;\n        }\n      case 38400:\n        {\n            cfsetispeed(cfg, 15);\n            cfsetospeed(cfg, 15);\n            break;\n        }\n      case 57600:\n        {\n            cfsetispeed(cfg, 4097);\n            cfsetospeed(cfg, 4097);\n            break;\n        }\n      case 115200:\n        {\n            cfsetispeed(cfg, 4098);\n            cfsetospeed(cfg, 4098);\n            break;\n        }\n      case 230400:\n        {\n            cfsetispeed(cfg, 4099);\n            cfsetospeed(cfg, 4099);\n            break;\n        }\n    }\n    switch (parity | 32) {\n      case 'n':\n        {\n            cfg->c_cflag &= ~256;\n            break;\n        }\n      case 'e':\n        {\n            cfg->c_cflag |= 256;\n            cfg->c_cflag &= ~512;\n            break;\n        }\n      case 'o':\n        {\n            cfg->c_cflag |= 256;\n            cfg->c_cflag |= 512;\n            break;\n        }\n    }\n    cfg->c_cflag &= ~48;\n    switch (data) {\n      case 5:\n        {\n            cfg->c_cflag |= 0;\n            break;\n        }\n      case 6:\n        {\n            cfg->c_cflag |= 16;\n            break;\n        }\n      case 7:\n        {\n            cfg->c_cflag |= 32;\n            break;\n        }\n      case 8:\n        {\n            cfg->c_cflag |= 48;\n            break;\n        }\n    }\n    if (stopb == 1)\n        cfg->c_cflag &= ~64;\n    else\n        cfg->c_cflag |= 64;\n    return tcsetattr(s, 0, cfg);\n}\n","function_prediction":"void setserial_name_conflict(int fd, struct termios *tio, int baud, int databits, int parity,\n               int stopbits) {\n\n  tcgetattr(fd, tio);\n  cfmakeraw(tio);\n\n  switch (baud) {\n  case 300:\n    cfsetispeed(tio, B300);\n    cfsetospeed(tio, B300);\n    break;\n  case 600:\n    cfsetispeed(tio, B600);\n    cfsetospeed(tio, B600);\n    break;\n  case 1200:\n    cfsetispeed(tio, B1200);\n    cfsetospeed(tio, B1200);\n    break;\n  case 1800:\n    cfsetispeed(tio, B1800);\n    cfsetospeed(tio, B1800);\n    break;\n  case 2400:\n    cfsetispeed(tio, B2400);\n    cfsetospeed(tio, B2400);\n    break;\n  case 4800:\n    cfsetispeed(tio, B4800);\n    cfsetospeed(tio, B4800);\n    break;\n  case 9600:\n    cfsetispeed(tio, B9600);\n    cfsetospeed(tio, B9600);\n    break;\n  case 19200:\n    cfsetispeed(tio, B19200);\n    cfsetospeed(tio, B19200);\n    break;\n  case 38400:\n    cfsetispeed(tio, B38400);\n    cfsetospeed(tio, B38400);\n    break;\n  default:\n    break;\n  }\n","pass":0,"source_file":"C_COMPILE/f1381/main_1381.c"}
{"compilable":1,"function":"static int i2creadarray(int i2cfile, int addr, int len, unsigned char *array) {\n    struct i2c_msg i2cmsg[2];\n    struct i2c_rdwr_ioctl_data i2cmsgdata;\n    i2cmsg[0].addr = 112;\n    i2cmsg[0].flags = 0;\n    i2cmsg[0].buf = (unsigned char *)&addr;\n    i2cmsg[0].len = 1;\n    i2cmsg[1].addr = 112;\n    i2cmsg[1].flags = 1;\n    i2cmsg[1].buf = array;\n    i2cmsg[1].len = len;\n    i2cmsgdata.msgs = i2cmsg;\n    i2cmsgdata.nmsgs = 2;\n    return ioctl(i2cfile, 1799, &i2cmsgdata);\n}\n","function_prediction":"int i2creadarray_name_conflict(int fd, unsigned char addr, unsigned short reg,\n                 unsigned char *data) {\n  struct i2c_rdwr_ioctl_data rdwr;\n  struct i2c_msg msgs[2];\n  unsigned char buf[2];\n\n  msgs[0].addr = addr;\n  msgs[0].flags = 0;\n  msgs[0].len = 2;\n  msgs[0].buf = buf;\n\n  msgs[1].addr = addr;\n  msgs[1].flags = 1;\n  msgs[1].len = 1;\n  msgs[1].buf = data;\n\n  rdwr.msgs = msgs;\n  rdwr.nmsgs = 2;\n\n  buf[0] = reg;\n  buf[1] = 0;\n\n  return ioctl(fd, 0x0707, &rdwr);\n}","pass":1,"source_file":"C_COMPILE/f2116/main_2116.c"}
{"compilable":1,"function":"char *ft_strcpy(char *dst, const char *src) {\n    char *s;\n    s = dst;\n    while (*src)\n        *s++ = *src++;\n    *s++ = '\\x00';\n    return (dst);\n}\n","function_prediction":"char *ft_strcpy_name_conflict(char *dest, const char *src) {\n  char *tmp;\n\n  tmp = dest;\n  while (*src)\n    *tmp++ = *src++;\n  *tmp = '\\0';\n  return (dest);\n}","pass":1,"source_file":"C_COMPILE/f1157/main_1157.c"}
{"compilable":0,"function":"unsigned char *base64_decode(unsigned char *out_code) {\n}\n","function_prediction":"void base64_decode_name_conflict(const char *src, char *dst) {}","pass":0,"source_file":"C_COMPILE/f43/main_43.c"}
{"compilable":0,"function":"int sec_init_key(unsigned char *nKey, unsigned int nKey_len, unsigned char *eKey, unsigned int eKey_len) {\n    return 0;\n}\n","function_prediction":"int sec_init_key_name_conflict(struct sec_dev_info *info) { return 0; }","pass":0,"source_file":"C_COMPILE/f185/main_185.c"}
{"compilable":1,"function":"char *stpcopy(char *dest, const char *src) {\n    while ((*dest = *src))\n        {\n            ++dest;\n            ++src;\n        }\n    return (dest);\n}\n","function_prediction":"char *stpcopy_name_conflict(char *dst, const char *src) {\n  char *d = dst;\n  while ((*d++ = *src++))\n    ;\n  return d - 1;\n}","pass":1,"source_file":"C_COMPILE/f1001/main_1001.c"}
{"compilable":1,"function":"static int endZuker(char *s, int *addend) {\n    *addend = 0;\n    return (*s == '(');\n}\n","function_prediction":"int endZuker_name_conflict(char *seq, int *len) {\n  *len = 0;\n  return seq[0] == '(';\n}","pass":1,"source_file":"C_COMPILE/f240/main_240.c"}
{"compilable":0,"function":"static int update(long *ptr) {\n    return ((*ptr)++);\n}\n","function_prediction":"void update_name_conflict(struct S *s) { s->a++; }","pass":0,"source_file":"C_COMPILE/f1198/main_1198.c"}
{"compilable":0,"function":"inline int secure_storage_write_a_key(unsigned char *name, unsigned int namelen, unsigned char *data, unsigned int datalen) {\n    return -1;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f7/main_7.c"}
{"compilable":1,"function":"short *A2W(const char *s, short *d, unsigned int cnt) {\n    short *ret = d;\n    if (!s || !d || !cnt)\n        return ((void *)0);\n    while (cnt-- && *s)\n        *d++ = (short)*s++;\n    if (cnt)\n        *d = 0;\n    return ret;\n}\n","function_prediction":"unsigned short *A2W_name_conflict(const char *src, unsigned short *dst, int len) {\n  unsigned short *dst_start = dst;\n\n  if (src == NULL || dst == NULL || len == 0)\n    return NULL;\n\n  while (len-- && *src != '\\0')\n    *dst++ = (unsigned short)*src++;\n\n  if (len-- != 0)\n    *dst = '\\0';\n\n  return dst_start;\n}","pass":1,"source_file":"C_COMPILE/f341/main_341.c"}
{"compilable":1,"function":"char *ope_finder(char *token, int i, char c, char *str) {\n    if (*str == '\\x00')\n        token[i] = '\\x00';\n    else {\n        while (*str == ' ')\n            (str)++;\n        if (*str == '+' || *str == '-' || *str == '*' || *str == '/' || *str == '%' || *str == '(' || *str == ')') {\n            token[i] = *str;\n            token[i + 1] = '\\x00';\n        } else {\n            c = *str;\n            while (c >= '0' && c <= '9')\n                {\n                    token[i++] = c;\n                    (str)++;\n                    c = *str;\n                }\n            token[i] = '\\x00';\n        }\n    }\n    return (token);\n}\n","function_prediction":"char *ope_finder_name_conflict(char *ope, int i, int *j, char *str) {\n  char c;\n\n  if (str[0] == '\\0')\n    ope[i] = '\\0';\n  else {\n    while (str[0] == ' ')\n      str++;\n    if (str[0] == '+' || str[0] == '-' || str[0] == '*' || str[0] == '/' ||\n        str[0] == '%' || str[0] == '(' || str[0] == ')') {\n      ope[i] = str[0];\n      ope[i + 1] = '\\0';\n    } else {\n      c = str[0];\n      while (c >= '0' && c <= '9') {\n        ope[i] = c;\n        str++;\n        i++;\n        c = str[0];\n      }\n      ope[i] = '\\0';\n    }\n  }\n  return (ope);\n}","pass":1,"source_file":"C_COMPILE/f239/main_239.c"}
{"compilable":0,"function":"inline int ExchangeInt(volatile int *ptr, int newval) {\n    return __sync_lock_test_and_set_4(ptr, newval);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f757/main_757.c"}
{"compilable":1,"function":"unsigned int conv_dstring(char *string, unsigned int *addr) {\n    unsigned int pos = 0;\n    *addr = 0;\n    while (((string[pos] >= '0' && string[pos] <= '9')) && pos < 9)\n        {\n            *addr = (*addr * 10) + (string[pos++] - '0');\n        }\n    return pos;\n}\n","function_prediction":"int conv_dstring_name_conflict(char *str, int *num) {\n  int i;\n\n  *num = 0;\n  for (i = 0; i < 9; i++) {\n    if (str[i] < '0' || str[i] > '9')\n      break;\n    *num = *num * 10 + str[i] - '0';\n  }\n  return i;\n}","pass":1,"source_file":"C_COMPILE/f9/main_9.c"}
{"compilable":0,"function":"int lw_sock_listen(int *sock, int port) {\n    int result = 0;\n    struct sockaddr_in name;\n    int enable = 1;\n    *sock = socket(2, SOCK_STREAM, 0);\n    if (*sock >= 0) {\n        setsockopt(*sock, 1, 2, (char *)&enable, sizeof(int));\n        name.sin_family = 2;\n        name.sin_addr.s_addr = ((in_addr_t)0);\n        name.sin_port = htons(port);\n        if (bind(*sock, (struct sockaddr *)&name, sizeof name) >= 0) {\n            if (listen((*sock), 10) >= 0) {\n                result = 1;\n            }\n        }\n    }\n    return result;\n}\n","function_prediction":"int lw_sock_listen_name_conflict(lw_sock_t *sock, int port) {\n  int ret = 0;\n  int on = 1;\n  struct sockaddr_in addr;\n\n  sock->fd = socket(2, 1, 0);\n  if (sock->fd < 0)\n    return 0;\n\n  setsockopt(sock->fd, 1, 2, &on, sizeof(on));\n\n  addr.sin_family = 2;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = 0;\n\n  if (bind(sock->fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n    return 0;\n\n  if (listen(sock->fd, 10) < 0)\n    return 0;\n\n  ret = 1;\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/f908/main_908.c"}
{"compilable":1,"function":"int sipxfaddr(int unit, unsigned long network, unsigned char *node) {\n    int result = 1;\n    return result;\n}\n","function_prediction":"int sipxfaddr_name_conflict(const char *addr, char *buf, int len) { return 1; }","pass":1,"source_file":"C_COMPILE/f785/main_785.c"}
{"compilable":1,"function":"const char *js_itoa(char *out, int a) {\n    char buf[32], *s = out;\n    int i = 0;\n    while (a)\n        {\n            buf[i++] = (a % 10) + '0';\n            a /= 10;\n        }\n    if (i == 0)\n        buf[i++] = '0';\n    while (i > 0)\n        *s++ = buf[--i];\n    *s = 0;\n    return out;\n}\n","function_prediction":"char *js_itoa_name_conflict(char *str, int val) {\n  char *p = str;\n  char buf[32];\n  int i = 0;\n\n  while (val) {\n    buf[i++] = val % 10 + '0';\n    val /= 10;\n  }\n\n  if (i == 0) {\n    buf[i++] = '0';\n  }\n\n  while (i > 0) {\n    *p++ = buf[--i];\n  }\n\n  *p = '\\0';\n\n  return str;\n}","pass":1,"source_file":"C_COMPILE/f1095/main_1095.c"}
{"compilable":1,"function":"char *my_strcpy(char *s1, const char *s2) {\n    char *temp = s1;\n    while ('\\x00' != *s2)\n        {\n            *s1 = *s2;\n            s2++;\n            s1++;\n        }\n    *s1 = '\\x00';\n    return temp;\n}\n","function_prediction":"char *my_strcpy_name_conflict(char *dest, const char *src) {\n  char *saved_dest = dest;\n\n  while (*src != '\\0') {\n    *dest = *src;\n    dest++;\n    src++;\n  }\n  *dest = '\\0';\n  return (saved_dest);\n}","pass":1,"source_file":"C_COMPILE/f661/main_661.c"}
{"compilable":1,"function":"int exc_f(char *s, int *n) {\n    int x = 0;\n    int sg = 1;\n    if (*s == '-') {\n        sg = -1;\n        s++;\n    } else if (*s == '+') {\n        s++;\n    }\n    for (; *s; s++) {\n        if (*s >= '0' && *s <= '9') {\n            x = 10 * x + sg * (*s - '0');\n        } else {\n            return -1;\n        }\n    }\n    if (*s) {\n        return -1;\n    } else {\n        *n = x;\n        return 0;\n    }\n}\n","function_prediction":"int exc_f_name_conflict(char *str, int *num) {\n  int sign = 1;\n  int ret = 0;\n\n  if (*str == '-') {\n    sign = -1;\n    str++;\n  } else if (*str == '+') {\n    str++;\n  }\n\n  while (*str) {\n    if (*str < '0' || *str > '9')\n      return -1;\n    ret = ret * 10 + (*str - '0') * sign;\n    str++;\n  }\n\n  *num = ret;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1475/main_1475.c"}
{"compilable":1,"function":"char *my_revstr(char *str) {\n    int i;\n    int l;\n    char c;\n    l = 0;\n    while (str[l] != '\\x00')\n        {\n            l = l + 1;\n        }\n    i = 0;\n    while (i < l / 2)\n        {\n            c = str[i];\n            str[i] = str[l - i - 1];\n            str[l - i - 1] = c;\n            i = i + 1;\n        }\n    return (str);\n}\n","function_prediction":"char *my_revstr_name_conflict(char *str) {\n  int i;\n  int j;\n  int len;\n  char tmp;\n\n  for (len = 0; str[len] != '\\0'; len++)\n    ;\n  for (i = 0, j = len - 1; i < len / 2; i++, j--) {\n    tmp = str[i];\n    str[i] = str[j];\n    str[j] = tmp;\n  }\n  return (str);\n}","pass":0,"source_file":"C_COMPILE/f1895/main_1895.c"}
{"compilable":0,"function":"int atomic_add(int *variable, int value) {\n    return (int)__sync_fetch_and_add_4(variable, value);\n}\n","function_prediction":"int atomic_add_name_conflict(atomic_t *v, int n) {\n  int ret;\n  LOCK();\n  ret = v->counter;\n  v->counter += n;\n  UNLOCK();\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/f1902/main_1902.c"}
{"compilable":1,"function":"int vbyte_decompress(char *src, char *bound, unsigned int *n) {\n    int len = 0;\n    *n = 0;\n    while ((src + len < bound) && (*(src + len) & 128))\n        {\n            *n += (*(src + len) & 127) << (7 * len);\n            len++;\n        }\n    if (src + len == bound) {\n        return 0;\n    }\n    *n += (*(src + len) & 127) << (7 * len);\n    len++;\n    return len;\n}\n","function_prediction":"int vbyte_decompress_name_conflict(const char *in, const char *in_end, uint32_t *out) {\n  int i = 0;\n  *out = 0;\n  while (in + i < in_end && in[i] >= 0) {\n    *out += (in[i] & 0x7f) << (i * 7 - i);\n    i++;\n  }\n  if (in + i == in_end) {\n    return 0;\n  }\n  *out += (in[i] & 0x7f) << (i * 7 - i);\n  return i + 1;\n}","pass":0,"source_file":"C_COMPILE/f266/main_266.c"}
{"compilable":1,"function":"char *strcpy(char *d, const char *s) {\n    char *tmp = d;\n    while ((*d++ = *s++) != '\\x00')\n        ;\n    return tmp;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f244/main_244.c"}
{"compilable":0,"function":"char *translate_oregon(unsigned char *buf, unsigned char *sunchanged, int *launchp) {\n    return \"\";\n}\n","function_prediction":"const char *translate_oregon_name_conflict(void) { return \"OR\"; }","pass":0,"source_file":"C_COMPILE/f269/main_269.c"}
{"compilable":0,"function":"int lw_sock_close(int *sock) {\n    int result = 0;\n    int sock_to_close;\n    sock_to_close = *sock;\n    (*sock) = -1;\n    if (shutdown(sock_to_close, 2) != 0) {\n    }\n    if (close(sock_to_close) != 0) {\n    } else {\n        result = 1;\n    }\n    return result;\n}\n","function_prediction":"int lw_sock_close_name_conflict(lw_sock_t *sock) {\n  int fd = sock->fd;\n  sock->fd = -1;\n  shutdown(fd, 2);\n  return !close(fd);\n}","pass":0,"source_file":"C_COMPILE/f590/main_590.c"}
{"compilable":1,"function":"static unsigned char checksum(unsigned char p[4]) {\n    unsigned char sum;\n    sum = p[0] + p[2] + p[3];\n    sum |= 128;\n    return (sum);\n}\n","function_prediction":"unsigned char checksum_name_conflict(unsigned char *data) {\n  unsigned char sum = 0;\n  int i;\n\n  for (i = 0; i < 3; i++)\n    sum += data[i];\n\n  return sum | 0x80;\n}","pass":0,"source_file":"C_COMPILE/f1783/main_1783.c"}
{"compilable":1,"function":"char *itoa(int i, char *buf) {\n    int j = 0;\n    int k;\n    do {\n        k = i % 10;\n        buf[j++] = k + '0';\n        i /= 10;\n    } while (i);\n    buf[j] = '\\x00';\n    for (k = 0; k < j / 2; ++k) {\n        char temp = buf[k];\n        buf[k] = buf[j - 1 - k];\n        buf[j - 1 - k] = temp;\n    }\n    return buf;\n}\n","function_prediction":"char *itoa_name_conflict(int n, char *s) {\n  int i = 0, j = 0;\n\n  do {\n    s[i++] = n % 10 + '0';\n  } while (n /= 10);\n\n  s[i] = '\\0';\n\n  for (j = 0; j < i / 2; j++) {\n    char c = s[j];\n    s[j] = s[i - j - 1];\n    s[i - j - 1] = c;\n  }\n\n  return s;\n}","pass":1,"source_file":"C_COMPILE/f709/main_709.c"}
{"compilable":1,"function":"char *ho_strcpy(char *dst, const char *src) {\n    char *p = dst;\n    while ((*dst++ = *src++) != '\\x00')\n        ;\n    return p;\n}\n","function_prediction":"char *ho_strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f849/main_849.c"}
{"compilable":1,"function":"char *ft_strcpy(char *dest, const char *str) {\n    int i;\n    i = 0;\n    while (str[i])\n        {\n            dest[i] = str[i];\n            i++;\n        }\n    dest[i] = '\\x00';\n    return (dest);\n}\n","function_prediction":"char *ft_strcpy_name_conflict(char *dest, const char *src) {\n  int i;\n\n  i = 0;\n  while (src[i] != '\\0') {\n    dest[i] = src[i];\n    i++;\n  }\n  dest[i] = '\\0';\n  return (dest);\n}","pass":1,"source_file":"C_COMPILE/f1129/main_1129.c"}
{"compilable":1,"function":"int foo(int *p) {\n    *p = 0;\n    return *p;\n}\n","function_prediction":"int foo_name_conflict(int *p) {\n  *p = 0;\n  return *p;\n}","pass":1,"source_file":"C_COMPILE/f832/main_832.c"}
{"compilable":1,"function":"static int hundreds(int *v) {\n    int ret = 7;\n    switch (*v / 100) {\n      case 9:\n        ret += 4;\n        break;\n      case 8:\n        ret += 5;\n        break;\n      case 7:\n        ret += 5;\n        break;\n      case 6:\n        ret += 3;\n        break;\n      case 5:\n        ret += 4;\n        break;\n      case 4:\n        ret += 4;\n        break;\n      case 3:\n        ret += 5;\n        break;\n      case 2:\n        ret += 3;\n        break;\n      case 1:\n        ret += 3;\n        break;\n      case 0:\n        return 0;\n    }\n    *v %= 100;\n    return ret;\n}\n","function_prediction":"int hundreds_name_conflict(int *n) {\n  int ret = 7;\n  switch (*n / 100) {\n  case 0:\n    return 0;\n  case 1:\n    ret = 10;\n    break;\n  case 2:\n    ret = 10;\n    break;\n  case 3:\n    ret = 12;\n    break;\n  case 4:\n    ret = 11;\n    break;\n  case 5:\n    ret = 11;\n    break;\n  case 6:\n    ret = 10;\n    break;\n  case 7:\n    ret = 12;\n    break;\n  case 8:\n    ret = 12;\n    break;\n  case 9:\n    ret = 11;\n    break;\n  }\n  *n %= 100;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/f1421/main_1421.c"}
{"compilable":0,"function":"static int draw_frame(unsigned char *src[]) {\n    return 0;\n}\n","function_prediction":"int draw_frame_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/f1318/main_1318.c"}
{"compilable":0,"function":"unsigned int f(volatile unsigned int *u, unsigned int u2) {\n    *u = u2;\n    return *u;\n}\n","function_prediction":"int frame_dummy(int *p, int x) {\n  register_tm_clones();\n  return f(p, x);\n}","pass":0,"source_file":"C_COMPILE/f1149/main_1149.c"}
{"compilable":1,"function":"static int grisu3_i_to_str(int val, char *str) {\n    int len, i;\n    char *s;\n    char *begin = str;\n    if (val < 0) {\n        *str++ = '-';\n        val = -val;\n    }\n    s = str;\n    for (;;) {\n        int ni = val / 10;\n        int digit = val - ni * 10;\n        *s++ = (char)('0' + digit);\n        if (ni == 0)\n            break;\n        val = ni;\n    }\n    *s = '\\x00';\n    len = (int)(s - str);\n    for (i = 0; i < len / 2; ++i) {\n        char ch = str[i];\n        str[i] = str[len - 1 - i];\n        str[len - 1 - i] = ch;\n    }\n    return (int)(s - begin);\n}\n","function_prediction":"size_t grisu3_i_to_str_name_conflict(int64_t i, char *buffer) {\n  char *p = buffer;\n  if (i < 0) {\n    *p++ = '-';\n    i = -i;\n  }\n  char *const start = p;\n  do {\n    int64_t const next = i / 10;\n    *p++ = '0' + (i - 10 * next);\n    i = next;\n  } while (i);\n  *p = '\\0';\n  int const len = p - start;\n  for (int k = 0; k < len / 2; ++k) {\n    char const c = start[k];\n    start[k] = start[len - 1 - k];\n    start[len - 1 - k] = c;\n  }\n  return p - buffer;\n}","pass":1,"source_file":"C_COMPILE/f80/main_80.c"}
{"compilable":1,"function":"static int to_utf8(char *utfbuffer, unsigned int uc) {\n    int count = 0;\n    if (uc < 128) {\n        utfbuffer[0] = uc;\n        count = 1;\n    } else {\n        if (uc < 2048) {\n            utfbuffer[count++] = 192 | (uc >> 6);\n        } else {\n            utfbuffer[count++] = 224 | (uc >> 12);\n            utfbuffer[count++] = 128 | ((uc >> 6) & 63);\n        }\n        utfbuffer[count++] = 128 | (uc & 63);\n    }\n    utfbuffer[count] = 0;\n    return count;\n}\n","function_prediction":"int to_utf8_name_conflict(char *buf, int c) {\n  int len;\n\n  if (c < 0x80) {\n    buf[0] = c;\n    len = 1;\n  } else if (c < 0x800) {\n    buf[0] = 0xc0 | (c >> 6);\n    buf[1] = 0x80 | (c & 0x3f);\n    len = 2;\n  } else {\n    buf[0] = 0xe0 | (c >> 12);\n    buf[1] = 0x80 | ((c >> 6) & 0x3f);\n    buf[2] = 0x80 | (c & 0x3f);\n    len = 3;\n  }\n  buf[len] = '\\0';\n  return len;\n}","pass":0,"source_file":"C_COMPILE/f1553/main_1553.c"}
{"compilable":1,"function":"const char *ares_version(int *version) {\n    if (version)\n        *version = ((1 << 16) | (7 << 8) | (1));\n    return \"1.7.1\";\n}\n","function_prediction":"const char *ares_version_name_conflict(int *version) {\n  if (version)\n    *version = 0x010701;\n  return \"1.7.1\";\n}","pass":1,"source_file":"C_COMPILE/f620/main_620.c"}
{"compilable":0,"function":"static inline char *strcpy(char *d, const char *s) {\n    char *r = d;\n    do \n        *d++ = *s++;\n    while (*s);\n    return r;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1760/main_1760.c"}
{"compilable":0,"function":"static inline int _hclib_atomic_dec_acq_rel(volatile int *target) {\n    return __sync_sub_and_fetch_4(target, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1259/main_1259.c"}
{"compilable":0,"function":"static int chk_args(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy, int *p_scale_x, int *p_scale_y) {\n    if (((unsigned int)dest_ptr & 3) || (dest_pitch & 3) || ((unsigned int)src_ptr & 3) || (src_pitch & 3) || dest_width <= 0 || dest_height <= 0 || src_width <= 0 || src_height <= 0 || dest_x < 0 || dest_y < 0 || dest_dx <= 0 || dest_dy <= 0 || src_x < 0 || src_y < 0 || src_dx <= 0 || src_dy <= 0 || dest_width < dest_x + dest_dx || dest_height < dest_y + dest_dy || src_width < src_x + src_dx || src_height < src_y + src_dy)\n        goto fail;\n    if (dest_dx == src_dx)\n        *p_scale_x = 1;\n    else if (dest_dx == 2 * src_dx)\n        *p_scale_x = 2;\n    else\n        goto fail;\n    if (dest_dy == src_dy)\n        *p_scale_y = 1;\n    else if (dest_dy == 2 * src_dy)\n        *p_scale_y = 2;\n    else\n        goto fail;\n    return 1;\n  fail:\n    return 0;\n}\n","function_prediction":"int chk_args_name_conflict(int w, int h, int c, int d, int x, int y, int ww, int hh, int dd,\n             int x1, int y1, int ww1, int hh1, int dd1, int x2, int y2, int *w2,\n             int *h2) {\n  if (w % 4 || h % 4 || d % 4 || dd % 4 || ww % 4 || ww1 % 4)\n    return 0;\n  if (w <= 0 || h <= 0 || x < 0 || y < 0 || ww <= 0 || hh <= 0 || dd < 0 ||\n      x1 < 0 || y1 < 0 || ww1 <= 0 || hh1 <= 0 || dd1 < 0 || x2 < 0 || y2 < 0)\n    return 0;\n  if (x + ww > w || y + hh > h || x1 + ww1 > x || y1 + hh1 > y ||\n      x2 + ww2 > x1 || y2 + hh2 > y1)\n    return 0;\n  if (ww == x2)\n    *w2 = 1;\n  else if (ww == 2 * x2)\n    *w2 = 2;\n  else\n    return 0;\n  if (hh == y2)\n    *h2 = 1;\n  else if (hh == 2 * y2)\n    *h2 = 2;\n  else\n    return 0;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/f383/main_383.c"}
{"compilable":0,"function":"int MPI_Comm_group(int comm, int *group) {\n    *group = comm;\n    return 0;\n}\n","function_prediction":"int MPI_Comm_group_name_conflict(MPI_Comm comm, MPI_Group *group) {\n  *group = comm;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1872/main_1872.c"}
{"compilable":1,"function":"int trecv(int targetfd, char *bytes, int *bytes_size) {\n    if ((*bytes_size = recv(targetfd, bytes, *bytes_size, 0)) < 1) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int trecv_name_conflict(int sock, char *buf, int *len) {\n  *len = recv(sock, buf, *len, 0);\n  if (*len > 0)\n    return 0;\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/f855/main_855.c"}
{"compilable":0,"function":"int give_me(char memory[1024], int helper[1024], int size) {\n    int elem = 0;\n    for (; elem < 1024; ++elem) {\n        if (!helper[elem]) {\n            helper[elem] = 1;\n            return elem;\n        }\n    }\n    return -1;\n}\n","function_prediction":"int give_me_name_conflict(int *a, int *b) {\n  int i;\n\n  for (i = 0; i < 1024; i++)\n    if (!b[i]) {\n      b[i] = 1;\n      return i;\n    }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f562/main_562.c"}
{"compilable":0,"function":"static int streamPropertiesCount(unsigned char **tokens, int *ntokens, int *properties, int *nproperties, int *streams, int **nstreams, int stream) {\n    if (*nstreams > stream) {\n        if (*nstreams > (stream + 1)) {\n            return streams[stream + 1] - streams[stream];\n        } else {\n            return *nproperties - streams[stream];\n        }\n    }\n    return 0;\n}\n","function_prediction":"int streamPropertiesCount_name_conflict(const struct stream *stream,\n                          const struct stream_properties *properties,\n                          int index) {\n  if (index >= properties->count)\n    return 0;\n  if (index + 1 < properties->count)\n    return properties->offsets[index + 1] - properties->offsets[index];\n  return stream->size - properties->offsets[index];\n}","pass":0,"source_file":"C_COMPILE/f994/main_994.c"}
{"compilable":1,"function":"const char *string_to_usize(const char *s, size_t *number) {\n    int c = *s;\n    for (*number = 0; ((unsigned int)(c - '0') <= (unsigned int)('9' - '0')); *number = (((*number) << 1) + ((*number) << 3)) + (c - '0') , c = *++s)\n        ;\n    return s;\n}\n","function_prediction":"char *string_to_usize_name_conflict(char *s, unsigned long *n) {\n  *n = 0;\n  while (*s >= '0' && *s <= '9')\n    *n = *n * 10 + *s++ - '0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f1057/main_1057.c"}
{"compilable":1,"function":"static int read_var_len(int fd, long *value) {\n    unsigned char c;\n    int bytes;\n    *value = 0;\n    bytes = 0;\n    do {\n        (*value) <<= 7;\n        bytes += read(fd, &c, 1);\n        (*value) += (c & 127);\n    } while ((c & 128) == 128);\n    return bytes;\n}\n","function_prediction":"int read_var_len_name_conflict(int fd, unsigned long *len) {\n  int n;\n  unsigned char c;\n\n  *len = 0;\n  n = 0;\n  do {\n    *len <<= 7;\n    n += read(fd, &c, 1);\n    *len += c & 0x7f;\n  } while (c & 0x80);\n  return n;\n}","pass":1,"source_file":"C_COMPILE/f1352/main_1352.c"}
{"compilable":1,"function":"unsigned int stb_hash2(char *str, unsigned int *hash2_ptr) {\n    unsigned int hash1 = 826366252;\n    unsigned int hash2 = 2012234989;\n    while (*str)\n        {\n            hash1 = (hash1 << 7) + (hash1 >> 25) + *str;\n            hash2 = (hash2 << 11) + (hash2 >> 21) + *str;\n            ++str;\n        }\n    *hash2_ptr = hash2 + (hash1 >> 16);\n    return hash1 + (hash2 >> 16);\n}\n","function_prediction":"unsigned int stb_hash2_name_conflict(char *str, unsigned int *p) {\n  unsigned int h1 = 0x3141592c;\n  unsigned int h2 = 0x77f044ed;\n  while (*str) {\n    h1 = (h1 << 7) | (h1 >> (32 - 7));\n    h1 += *str++;\n    h2 = (h2 << 11) | (h2 >> (32 - 11));\n    h2 += *str++;\n  }\n  *p = h2;\n  return h1 + (h2 >> 16);\n}","pass":0,"source_file":"C_COMPILE/f1619/main_1619.c"}
{"compilable":1,"function":"char *xstrcpy(char *dst, const char *src) {\n    register char *d = dst;\n    while ((*d++ = *src++) != '\\x00')\n        ;\n    return dst;\n}\n","function_prediction":"char *xstrcpy_name_conflict(char *dest, const char *src) {\n  char *ret = dest;\n  while ((*dest++ = *src++))\n    ;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/f1623/main_1623.c"}
{"compilable":1,"function":"static int escape(char *fmt, int percent, size_t *len) {\n    char *save, *store, c;\n    int value;\n    for (save = store = fmt; ((c = *fmt) != 0); ++fmt , ++store) {\n        if (c != '\\\\') {\n            *store = c;\n            continue;\n        }\n        switch (*++fmt) {\n          case '\\x00':\n            *store = '\\\\';\n            *++store = '\\x00';\n            *len = store - save;\n            return (0);\n          case '\\\\':\n          case '\\'':\n            *store = *fmt;\n            break;\n          case 'a':\n            *store = '\\a';\n            break;\n          case 'b':\n            *store = '\\b';\n            break;\n          case 'c':\n            *store = '\\x00';\n            *len = store - save;\n            return (1);\n          case 'f':\n            *store = '\\f';\n            break;\n          case 'n':\n            *store = '\\n';\n            break;\n          case 'r':\n            *store = '\\r';\n            break;\n          case 't':\n            *store = '\\t';\n            break;\n          case 'v':\n            *store = '\\v';\n            break;\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n            c = (!percent && *fmt == '0') ? 4 : 3;\n            for (value = 0; c-- && *fmt >= '0' && *fmt <= '7'; ++fmt) {\n                value <<= 3;\n                value += *fmt - '0';\n            }\n            --fmt;\n            if (percent && value == '%') {\n                *store++ = '%';\n                *store = '%';\n            } else\n                *store = (char)value;\n            break;\n          default:\n            *store = *fmt;\n            break;\n        }\n    }\n    *store = '\\x00';\n    *len = store - save;\n    return (0);\n}\n","function_prediction":"int escape_name_conflict(char *s, int c, size_t *len) {\n  char *t, *u;\n\n  for (t = s, u = s; *t; t++, u++) {\n    if (*t != '\\\\') {\n      *u = *t;\n      continue;\n    }\n    t++;\n    if (!*t) {\n      *u = '\\\\';\n      u++;\n      break;\n    }\n    switch (*t) {\n    case 'a':\n      *u = '\\a';\n      break;\n    case 'b':\n      *u = '\\b';\n      break;\n    case 'f':\n      *u = '\\f';\n      break;\n    case 'n':\n      *u = '\\n';\n      break;\n    case 'r':\n      *u = '\\r';\n      break;\n    case 't':\n      *u = '\\t';\n      break;\n    case 'v':\n      *u = '\\v';\n      break;\n    case '\\\\':\n    case '\\'':\n      *u = *t;\n      break;\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7': {\n      char *p;\n      int i, n;\n\n      p = c ? NULL : t;\n      n = p && *p == '0' ? 4 : 3;\n      for (i = 0; n && *t > '0' && *t < '8'; t++, n--)\n        i = i * 8 + *t - '0';\n      t--;\n      if (c && i == 37) {\n        *u = '%';\n        u++;\n        *u = '%';\n      } else\n        *u = i;\n      break;\n    }\n    default:\n      *u = *t;\n      break;\n    }\n  }\n  *u = '\\0';\n  *len = u - s;\n  return (!c);\n}","pass":0,"source_file":"C_COMPILE/f1963/main_1963.c"}
{"compilable":1,"function":"char *itoa(int value, char *str, int base) {\n    char *rc;\n    char *ptr;\n    char *low;\n    if (base < 2 || base > 36) {\n        *str = '\\x00';\n        return str;\n    }\n    rc = str;\n    ptr = str;\n    if (value < 0 && base == 10) {\n        *ptr++ = '-';\n    }\n    low = ptr;\n    do {\n        *ptr++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\"[35 + value % base];\n        value /= base;\n    } while (value);\n    *ptr-- = '\\x00';\n    while (low < ptr)\n        {\n            char tmp = *low;\n            *low++ = *ptr;\n            *ptr-- = tmp;\n        }\n    return rc;\n}\n","function_prediction":"char *itoa_name_conflict(int value, char *str, int base) {\n  static char num[] =\n      \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\";\n  char *ptr;\n  char *ptr1;\n  char tmp;\n  char sign;\n\n  if (base < 2 || base > 36) {\n    *str = '\\0';\n    return str;\n  }\n\n  if (value < 0 && base == 10) {\n    sign = '-';\n    value = -value;\n  } else {\n    sign = '\\0';\n  }\n\n  ptr = str;\n  do {\n    *ptr++ = num[value % base];\n    value /= base;\n  } while (value > 0);\n\n  if (sign) {\n    *ptr++ = sign;\n  }\n  *ptr-- = '\\0';\n\n  ptr1 = str;\n  while (ptr1 < ptr) {\n    tmp = *ptr;\n    *ptr-- = *ptr1;\n    *ptr1++ = tmp;\n  }\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/f1082/main_1082.c"}
{"compilable":1,"function":"int strcpy_limit(char *dest, char *src, int limit) {\n    char *sptr = (char *)((void *)0);\n    char *dptr = (char *)((void *)0);\n    int count = 0;\n    for (sptr = src , dptr = dest; *sptr != '\\x00' && count < limit; sptr++ , dptr++ , count++) {\n        *dptr = *sptr;\n    }\n    *dptr = '\\x00';\n    return count;\n}\n","function_prediction":"int strcpy_limit_name_conflict(char *dst, const char *src, int limit) {\n  int i;\n\n  for (i = 0; *src && i < limit; i++)\n    *dst++ = *src++;\n  *dst = '\\0';\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f220/main_220.c"}
{"compilable":1,"function":"int putBuff(char buf[313], int j, char s[]) {\n    int i = 0;\n    for (; s[i]; i++) {\n        buf[j++] = s[i];\n    }\n    buf[j++] = '\\x00';\n    return j;\n}\n","function_prediction":"int putBuff_name_conflict(char *buff, int pos, char *str) {\n  int i;\n  for (i = 0; str[i] != '\\0'; i++) {\n    buff[pos] = str[i];\n    pos++;\n  }\n  buff[pos] = '\\0';\n  return pos + 1;\n}","pass":0,"source_file":"C_COMPILE/f12/main_12.c"}
{"compilable":0,"function":"int compress_worddata(unsigned char *wdata, int wdata_size, int economic) {\n    return wdata_size;\n}\n","function_prediction":"int compress_worddata_name_conflict(struct worddata *wd, int n) { return n; }","pass":0,"source_file":"C_COMPILE/f843/main_843.c"}
{"compilable":1,"function":"char *itoa(char *str, int num) {\n    char *p = str;\n    char ch;\n    int i;\n    int flag = 0;\n    *p++ = '0';\n    *p++ = 'x';\n    if (num == 0) {\n        *p++ = '0';\n    } else {\n        for (i = 28; i >= 0; i -= 4) {\n            ch = (num >> i) & 15;\n            if (flag || (ch > 0)) {\n                flag = 1;\n                ch += '0';\n                if (ch > '9') {\n                    ch += 7;\n                }\n                *p++ = ch;\n            }\n        }\n    }\n    *p = 0;\n    return str;\n}\n","function_prediction":"char *itoa_name_conflict(char *buf, int val) {\n  int i;\n  int j;\n  int k;\n  int c;\n  int first = 0;\n\n  buf[0] = '0';\n  buf[1] = 'x';\n  j = 2;\n\n  if (val == 0) {\n    buf[j++] = '0';\n  } else {\n    for (i = 28; i >= 0; i -= 4) {\n      k = (val >> i) & 0xF;\n      if (first || k != 0) {\n        first = 1;\n        c = k + '0';\n        if (c > '9') {\n          c = c - '0' + 'a' - 10;\n        }\n        buf[j++] = c;\n      }\n    }\n  }\n  buf[j] = '\\0';\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/f103/main_103.c"}
{"compilable":0,"function":"static inline int fetch_and_add(int *variable, int inc) {\n    asm volatile (\"lock; xaddl %%eax, %2;\" : \"=a\" (inc) : \"a\" (inc), \"m\" (*variable) : \"memory\");\n    return inc;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f122/main_122.c"}
{"compilable":0,"function":"static inline int avro_refcount_dec(volatile int *refcount) {\n    if (*refcount != (int)-1) {\n        return (__sync_sub_and_fetch_4(refcount, 1) == 0);\n    }\n    return 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1389/main_1389.c"}
{"compilable":1,"function":"size_t NA_rm_duplicate(size_t *arr, size_t len) {\n    size_t prev = 0;\n    size_t curr = 1;\n    size_t last = len - 1;\n    while (curr <= last)\n        {\n            for (prev = 0; prev < curr && arr[curr] != arr[prev]; ++prev)\n                ;\n            if (prev == curr) {\n                ++curr;\n            } else {\n                arr[curr] = arr[last];\n                --last;\n            }\n        }\n    return curr;\n}\n","function_prediction":"size_t NA_rm_duplicate_name_conflict(void **array, size_t size) {\n  size_t i, j, k;\n\n  for (i = 1, j = size - 1; i <= j; i++) {\n    for (k = 0; k < i; k++) {\n      if (array[i] == array[k])\n        break;\n    }\n    if (k == i)\n      continue;\n    array[i] = array[j];\n    j--;\n  }\n  return i;\n}","pass":1,"source_file":"C_COMPILE/f725/main_725.c"}
{"compilable":1,"function":"long SASAtomicAdd(long *longptr, long delta) {\n    long temp;\n    temp = delta;\n    asm (\"\\tlock;\\txadd\\t%0,(%1);\" : \"+r\" (temp) : \"p\" (longptr) : \"memory\");\n    return temp;\n}\n","function_prediction":"long SASAtomicAdd_name_conflict(volatile long *ptr, long val) {\n  long ret;\n  LOCK();\n  ret = *ptr;\n  *ptr += val;\n  UNLOCK();\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/f2113/main_2113.c"}
{"compilable":0,"function":"static inline int a_fetch_add(volatile int *p, int v) {\n    asm volatile (\"lock ; xadd %0, %1\" : \"=r\" (v), \"=m\" (*p) : \"0\" (v) : \"memory\");\n    return v;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1952/main_1952.c"}
{"compilable":0,"function":"int SDL_imageFilterAddByteMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char C) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterAddByteMMX_name_conflict(Uint8 *dst, const Uint8 *src, int len, int val) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1713/main_1713.c"}
{"compilable":1,"function":"char *ft_strcpy(char *dst, const char *src) {\n    int index;\n    index = 0;\n    while (src[index] != '\\x00')\n        {\n            dst[index] = src[index];\n            index++;\n        }\n    dst[index] = '\\x00';\n    return (dst);\n}\n","function_prediction":"char *ft_strcpy_name_conflict(char *dest, const char *src) {\n  int i;\n\n  i = 0;\n  while (src[i] != '\\0') {\n    dest[i] = src[i];\n    i++;\n  }\n  dest[i] = '\\0';\n  return (dest);\n}","pass":1,"source_file":"C_COMPILE/f1240/main_1240.c"}
{"compilable":1,"function":"static unsigned int uInt16Number(unsigned char buf[2]) {\n    return (buf[1] << 8) | buf[0];\n}\n","function_prediction":"uint16_t uInt16Number_name_conflict(uint8_t *data) { return *(uint16_t *)data; }","pass":1,"source_file":"C_COMPILE/f2068/main_2068.c"}
{"compilable":0,"function":"static inline intptr_t atomic_exchange(intptr_t *object, intptr_t desired) {\n    intptr_t ret = *object;\n    *object = desired;\n    return ret;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f921/main_921.c"}
{"compilable":0,"function":"__attribute__((unused)) static inline unsigned int psnip_builtin_subc(unsigned int x, unsigned int y, unsigned int ci, unsigned int *co) {\n    unsigned int r = x - y;\n    *co = x < y;\n    if (ci) {\n        r--;\n        if (r == 0)\n            *co = 1;\n    }\n    return r;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f268/main_268.c"}
{"compilable":1,"function":"char *my_strcpy_end(char *dest, const char *src) {\n    while (*dest++ = *src++)\n        ;\n    return dest - 1;\n}\n","function_prediction":"char *my_strcpy_end_name_conflict(char *dest, const char *src) {\n  char *d;\n\n  d = dest;\n  while ((*d++ = *src++))\n    ;\n  return (d - 1);\n}","pass":1,"source_file":"C_COMPILE/f951/main_951.c"}
{"compilable":0,"function":"char *sgml_utf8_put_char(char *out, int chr) {\n    if (chr < 128) {\n        *out++ = chr;\n    } else if (chr < 2048) {\n        *out++ = 192 | ((chr >> 6) & 31);\n        *out++ = 128 | (chr & 63);\n    } else if (chr < 65536) {\n        *out++ = 224 | ((chr >> 12) & 15);\n        *out++ = 128 | ((chr >> 6) & 63);\n        *out++ = 128 | (chr & 63);\n    } else if (chr < 2097152) {\n        *out++ = 240 | ((chr >> 18) & 7);\n        *out++ = 128 | ((chr >> 12) & 63);\n        *out++ = 128 | ((chr >> 6) & 63);\n        *out++ = 128 | (chr & 63);\n    } else if (chr < 67108864) {\n        *out++ = 248 | ((chr >> 24) & 3);\n        *out++ = 128 | ((chr >> 18) & 63);\n        *out++ = 128 | ((chr >> 12) & 63);\n        *out++ = 128 | ((chr >> 6) & 63);\n        *out++ = 128 | (chr & 63);\n    } else if ((unsigned int)chr < 2147483648U) {\n        *out++ = 252 | ((chr >> 30) & 1);\n        *out++ = 128 | ((chr >> 24) & 63);\n        *out++ = 128 | ((chr >> 18) & 63);\n        *out++ = 128 | ((chr >> 12) & 63);\n        *out++ = 128 | ((chr >> 6) & 63);\n        *out++ = 128 | (chr & 63);\n    }\n    return out;\n}\n","function_prediction":"char *sgml_utf8_put_char_name_conflict(char *p, int c) {\n  if (c < 0x80)\n    *p++ = c;\n  else if (c < 0x800) {\n    *p++ = (c >> 6) | 0xc0;\n    *p++ = (c & 0x3f) | 0x80;\n  } else if (c < 0x10000) {\n    *p++ = (c >> 12) | 0xe0;\n    *p++ = ((c >> 6) & 0x3f) | 0x80;\n    *p++ = (c & 0x3f) | 0x80;\n  } else if (c < 0x200000) {\n    *p++ = (c >> 18) | 0xf0;\n    *p++ = ((c >> 12) & 0x3f) | 0x80;\n    *p++ = ((c >> 6) & 0x3f) | 0x80;\n    *p++ = (c & 0x3f) | 0x80;\n  } else if (c < 0x4000000) {\n    *p++ = (c >> 24) | 0xf8;\n    *p++ = ((c >> 18) & 0x3f) | 0x80;\n    *p++ = ((c >> 12) & 0x3f) | 0x80;\n    *p++ = ((c >> 6) & 0x3f) | 0x80;\n    *p++ = (c & 0x3f) | 0x80;\n  } else if (c < 0x80000000) {\n    *p++ = (c >> 30) | 0xfc;\n    *p++ = ((c >> 24) & 0x3f) | 0x80;\n  *p++ = ((c >> 18) & 0x3f) | 0x","pass":0,"source_file":"C_COMPILE/f1555/main_1555.c"}
{"compilable":1,"function":"int bitmap_alloc(unsigned int *array, int num_bits) {\n    int bitindex;\n    int wordindex = 0;\n    while (array[wordindex] == 4294967295U)\n        {\n            if (++wordindex == num_bits / 32)\n                return -1;\n        }\n    bitindex = __builtin_clz(~array[wordindex]);\n    array[wordindex] |= 2147483648U >> bitindex;\n    return wordindex * 32 + bitindex;\n}\n","function_prediction":"int bitmap_alloc_name_conflict(int *bitmap, int size) {\n  int i, j, k;\n\n  for (i = 0; i < size / 32; i++) {\n    if (bitmap[i] != -1) {\n      j = 31;\n      k = bitmap[i];\n      while (k >> j == 0)\n        j--;\n      bitmap[i] |= 0x80000000 >> j;\n      return i * 32 + j;\n    }\n  }\n\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1583/main_1583.c"}
{"compilable":1,"function":"char *str_cpy(char *dst, const char *src) {\n    char *p = dst;\n    while (*dst++ = *src++)\n        ;\n    return p;\n}\n","function_prediction":"char *str_cpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f2041/main_2041.c"}
{"compilable":1,"function":"short *f(short *a, int b, int *d) {\n    short c = *a;\n    a++;\n    c = b << c;\n    *d = c;\n    return a;\n}\n","function_prediction":"unsigned char *f_name_conflict(unsigned char *p, int a, int *b) {\n  *b = a << *p;\n  return p + 1;\n}","pass":0,"source_file":"C_COMPILE/f1286/main_1286.c"}
{"compilable":0,"function":"int SDL_imageFilterSubMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterSubMMX_name_conflict(void *src, void *dst, int w, int h, int src_pitch,\n                          int dst_pitch, int r1, int g1, int b1, int a1, int r2,\n                          int g2, int b2, int a2) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1568/main_1568.c"}
{"compilable":0,"function":"static inline long atomic_add(volatile long *ptr, long value) {\n    return __sync_fetch_and_add_8(ptr, value);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f191/main_191.c"}
{"compilable":1,"function":"char *strupr(char *name) {\n    int i;\n    if (!name)\n        return name;\n    for (i = 0; name[i]; i++)\n        if ((name[i] >= 'a') && (name[i] <= 'z'))\n            name[i] -= ('a' - 'A');\n    return name;\n}\n","function_prediction":"char *strupr_name_conflict(char *s) {\n  int i;\n\n  if (s == NULL)\n    return NULL;\n\n  for (i = 0; s[i]; i++)\n    if (s[i] >= 'a' && s[i] <= 'z')\n      s[i] -= 'a' - 'A';\n\n  return s;\n}","pass":1,"source_file":"C_COMPILE/f816/main_816.c"}
{"compilable":1,"function":"static int update_keys(unsigned int *pkeys, const unsigned int *pcrc_32_tab, int c) {\n    (*(pkeys + 0)) = ((*(pcrc_32_tab + (((unsigned int)((*(pkeys + 0))) ^ (c)) & 255))) ^ (((*(pkeys + 0))) >> 8));\n    (*(pkeys + 1)) += (*(pkeys + 0)) & 255;\n    (*(pkeys + 1)) = (*(pkeys + 1)) * 134775813L + 1;\n    {\n        register int keyshift = (int)((*(pkeys + 1)) >> 24);\n        (*(pkeys + 2)) = ((*(pcrc_32_tab + (((unsigned int)((*(pkeys + 2))) ^ (keyshift)) & 255))) ^ (((*(pkeys + 2))) >> 8));\n    }\n    return c;\n}\n","function_prediction":"uint8_t update_keys_name_conflict(uint32_t *keys, uint8_t *sbox, uint8_t byte) {\n  keys[0] = sbox[(keys[0] ^ byte) & 0xff] ^ (keys[0] >> 8);\n  keys[1] = (keys[1] + (keys[0] & 0xff)) * 134775813 + 1;\n  keys[2] = sbox[(keys[2] ^ (keys[1] >> 24)) & 0xff] ^ (keys[2] >> 8);\n  return byte;\n}","pass":0,"source_file":"C_COMPILE/f1535/main_1535.c"}
{"compilable":1,"function":"char *r_strcpy(char *dest, const char *src) {\n    int i;\n    char tmp;\n    for (i = 0; ; i++) {\n        tmp = src[i];\n        dest[i] = tmp;\n        if (src[i] == 0)\n            break;\n    }\n    return dest;\n}\n","function_prediction":"char *r_strcpy_name_conflict(char *dest, const char *src) {\n  int i = 0;\n  while ((dest[i] = src[i]) != '\\0')\n    i++;\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f861/main_861.c"}
{"compilable":1,"function":"static int mean2(int a, int b, int white, int *err) {\n    if (a >= white || b >= white) {\n        if (err)\n            *err = 10000000;\n        return white;\n    }\n    int m = (a + b) / 2;\n    if (err)\n        *err = ((a - b) > 0 ? (a - b) : -(a - b));\n    return m;\n}\n","function_prediction":"int mean2_name_conflict(int a, int b, int c, int *d) {\n  if (a >= c || b >= c) {\n    if (d)\n      *d = 10000000;\n    return c;\n  }\n  c = (a + b) / 2;\n  if (d)\n    *d = (a - b) < 0 ? -(a - b) : (a - b);\n  return c;\n}","pass":1,"source_file":"C_COMPILE/f1370/main_1370.c"}
{"compilable":0,"function":"int mk_MD5Parse(unsigned char in[33], unsigned char out[16]) {\n    int i = 0;\n    for (i = 0; i < 16; i++) {\n        if (in[2 * i] >= '0' && in[2 * i] <= '9')\n            in[2 * i] -= '0';\n        else if (in[2 * i] >= 'A' && in[2 * i] <= 'F')\n            in[2 * i] += 10 - 'A';\n        else if (in[2 * i] >= 'a' && in[2 * i] <= 'f')\n            in[2 * i] += 10 - 'a';\n        else\n            return 1;\n        if (in[1 + (2 * i)] >= '0' && in[1 + (2 * i)] <= '9')\n            in[1 + (2 * i)] -= '0';\n        else if (in[1 + (2 * i)] >= 'A' && in[1 + (2 * i)] <= 'F')\n            in[1 + (2 * i)] += 10 - 'A';\n        else if (in[1 + (2 * i)] >= 'a' && in[1 + (2 * i)] <= 'f')\n            in[1 + (2 * i)] += 10 - 'a';\n        else\n            return 1;\n        out[i] = in[2 * i] << 4 | in[1 + (2 * i)];\n    }\n    return 0;\n}\n","function_prediction":"int mk_MD5Parse_name_conflict(const char *src, unsigned char *digest) {\n  int i;\n\n  for (i = 0; i < 16; i++) {\n    if (src[i * 2] >= '0' && src[i * 2] <= '9')\n      src[i * 2] -= '0';\n    else if (src[i * 2] >= 'A' && src[i * 2] <= 'F')\n      src[i * 2] -= 'A' - 10;\n    else if (src[i * 2] >= 'a' && src[i * 2] <= 'f')\n      src[i * 2] -= 'a' - 10;\n    else\n      return 1;\n\n    if (src[i * 2 + 1] >= '0' && src[i * 2 + 1] <= '9')\n      src[i * 2 + 1] -= '0';\n    else if (src[i * 2 + 1] >= 'A' && src[i * 2 + 1] <= 'F')\n      src[i * 2 + 1] -= 'A' - 10;\n    else if (src[i * 2 + 1] >= 'a' && src[i * 2 + 1] <= 'f')\n      src[i * 2 + 1] -= 'a' - 10;\n    else\n      return 1;\n\n    digest[i] = (src[i * 2] << 4) | src[i * 2 + 1];\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1610/main_1610.c"}
{"compilable":1,"function":"char *itoa(int i, char b[]) {\n    const char digit[] = \"0123456789\";\n    char *p = b;\n    if (i < 0) {\n        *p++ = '-';\n        i *= -1;\n    }\n    int shifter = i;\n    do {\n        ++p;\n        shifter = shifter / 10;\n    } while (shifter);\n    *p = '\\x00';\n    do {\n        *--p = digit[i % 10];\n        i = i / 10;\n    } while (i);\n    return b;\n}\n","function_prediction":"char *itoa_name_conflict(int n, char *s) {\n  char *digits = \"0123456789\";\n  char *p = s;\n  int m;\n\n  if (n < 0) {\n    *p++ = '-';\n    m = -n;\n  } else {\n    m = n;\n  }\n\n  do {\n    *p++ = digits[m % 10];\n    m /= 10;\n  } while (m);\n\n  *p = '\\0';\n\n  char *q = s;\n  char ch;\n  while (q < p) {\n    ch = *q;\n    *q++ = *--p;\n    *p = ch;\n  }\n\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f195/main_195.c"}
{"compilable":1,"function":"char *gkUtf8CharCode(char *str, unsigned int *dstCharCode) {\n    int result = 0, bytesLeft = 0;\n    char *p = str, c = *p;\n    if (!c) {\n        *dstCharCode = 0;\n        return p;\n    }\n    do {\n        if ((c & 192) == 128) {\n            result = (result << 6) | (c & 127);\n        } else {\n            bytesLeft = 0;\n            while (c & 128)\n                {\n                    bytesLeft++;\n                    c = c << 1;\n                }\n            result = c >> bytesLeft;\n        }\n        c = *++p;\n    } while (c && --bytesLeft > 0);\n    *dstCharCode = result;\n    return p;\n}\n","function_prediction":"char *gkUtf8CharCode_name_conflict(char *s, int *code) {\n  int c, i, n;\n\n  c = n = 0;\n  i = 0;\n  while ((c = (unsigned char)*s++) != 0) {\n    if ((c & 0xC0) != 0x80) {\n      for (n = 0; c & 0x80; n++)\n        c <<= 1;\n      c >>= n;\n    } else\n      c = (c & 0x7F) | (c << 6);\n    if (--n <= 0)\n      break;\n  }\n  *code = c;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f197/main_197.c"}
{"compilable":1,"function":"char *strcpy_back(char *to, const char *from) {\n    const char *start_ptr = from - 1;\n    char to_nt_hit = 0;\n    for (; *from != '\\x00'; ++from , ++to)\n        if (*to == '\\x00')\n            to_nt_hit = 1;\n    if (*to == '\\x00' || to_nt_hit)\n        *(to + 1) = '\\x00';\n    for (; from != start_ptr; --from , --to)\n        *to = *from;\n    return (to);\n}\n","function_prediction":"char *strcpy_back_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n  int null_found = 0;\n\n  while (*s) {\n    if (*d == '\\0')\n      null_found = 1;\n    d++;\n    s++;\n  }\n\n  if (*d == '\\0' || null_found)\n    *++d = '\\0';\n\n  while (--s != src - 1)\n    *--d = *s;\n\n  return d;\n}","pass":0,"source_file":"C_COMPILE/f1771/main_1771.c"}
{"compilable":1,"function":"char *trimstr(char *str) {\n    int i = 0;\n    while (str[i] && str[i] != '\\n' && (str[i] == '\\t' || str[i] == ' '))\n        i++;\n    char *res = &str[i];\n    while (str[i] && str[i] != '\\t' && str[i] != ' ' && str[i] != '\\n')\n        i++;\n    str[i] = '\\n';\n    str[i + 1] = 0;\n    return res;\n}\n","function_prediction":"char *trimstr_name_conflict(char *str) {\n  int i;\n\n  for (i = 0; str[i] && str[i] != '\\n' && (str[i] == ' ' || str[i] == '\\t');\n       i++)\n    ;\n  for (; str[i] && str[i] != ' ' && str[i] != '\\t' && str[i] != '\\n'; i++)\n    ;\n  str[i++] = '\\n';\n  str[i] = '\\0';\n  return str + i - 1;\n}","pass":0,"source_file":"C_COMPILE/f1842/main_1842.c"}
{"compilable":1,"function":"int init_receive_buffer(unsigned short *index) {\n    *index = 4;\n    return (*index);\n}\n","function_prediction":"unsigned short init_receive_buffer_name_conflict(unsigned short *receive_buffer) {\n  *receive_buffer = 4;\n  return *receive_buffer;\n}","pass":1,"source_file":"C_COMPILE/f1772/main_1772.c"}
{"compilable":1,"function":"static int equal_nocase(const unsigned char *pattern, size_t pattern_len, const unsigned char *subject, size_t subject_len) {\n    if (pattern_len != subject_len)\n        return 0;\n    while (pattern_len)\n        {\n            unsigned char l = *pattern;\n            unsigned char r = *subject;\n            if (l == 0)\n                return 0;\n            if (l != r) {\n                if ('A' <= l && l <= 'Z')\n                    l = (l - 'A') + 'a';\n                if ('A' <= r && r <= 'Z')\n                    r = (r - 'A') + 'a';\n                if (l != r)\n                    return 0;\n            }\n            ++pattern;\n            ++subject;\n            --pattern_len;\n        }\n    return 1;\n}\n","function_prediction":"int equal_nocase_name_conflict(const char *s1, size_t n1, const char *s2, size_t n2) {\n  if (n1 != n2)\n    return 0;\n\n  while (n1--) {\n    char c1 = *s1++;\n    char c2 = *s2++;\n\n    if (!c1)\n      return 0;\n\n    if (c1 != c2) {\n      if (c1 >= 'A' && c1 <= 'Z')\n        c1 += 0x20;\n      if (c2 >= 'A' && c2 <= 'Z')\n        c2 += 0x20;\n      if (c1 != c2)\n        return 0;\n    }\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f1998/main_1998.c"}
{"compilable":1,"function":"int aux_cmp(char *base, char *conc, int *len) {\n    *len = 0;\n    if (base == 0) {\n        return -2;\n    }\n    while (*base++ == *conc++)\n        {\n            (*len)++;\n            if (*base == 0 && *conc != 0) {\n                return -3;\n            }\n            if (*base == 0 && *conc == 0) {\n                return -1;\n            }\n        }\n    if (*len == 0 && *base == 0) {\n        return 1;\n    }\n    if (*base == 0 && *conc != 0) {\n        return 2;\n    }\n    return 1;\n}\n","function_prediction":"int aux_cmp_name_conflict(char *s1, char *s2, int *len) {\n  *len = 0;\n  if (s1 == NULL)\n    return -2;\n  while (*s1 != '\\0' || *s2 != '\\0') {\n    if (*s1 != *s2) {\n      if (*len == 0 && *(s1 + 1) == '\\0')\n        return 1;\n      if (*(s1 + 1) == '\\0' && *(s2 + 1) != '\\0')\n        return 2;\n      return 1;\n    }\n    (*len)++;\n    if (*(s1 + 1) == '\\0' && *(s2 + 1) != '\\0')\n      return -3;\n    s1++;\n    s2++;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f786/main_786.c"}
{"compilable":0,"function":"inline unsigned int Rand(unsigned int *state) {\n    return (*state = (*state * 214013 + 2531011) & 2147483647U) >> 16;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f976/main_976.c"}
{"compilable":0,"function":"int SDL_imageFilterAddMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length) {\n    return (0);\n}\n","function_prediction":"int SDL_imageFilterAddMMX_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/f819/main_819.c"}
{"compilable":1,"function":"char *mystpncpy(char *dest, char *src, int n) {\n    int i;\n    for (i = 0; i < n && *src; i++)\n        *dest++ = *src++;\n    *dest = '\\x00';\n    return dest;\n}\n","function_prediction":"char *mystpncpy_name_conflict(char *dest, const char *src, int cnt) {\n  int i;\n  for (i = 0; i < cnt && *src != '\\0'; i++)\n    *dest++ = *src++;\n  *dest = '\\0';\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f678/main_678.c"}
{"compilable":1,"function":"int Utf8ToAnsi(char *dest, const char *src, int destLen) {\n    int di, si, si2, si3;\n    int conv;\n    conv = 0;\n    di = 0;\n    si = 0;\n    destLen--;\n    while ((src[si] != '\\x00') && (di < destLen))\n        {\n            si2 = si + 1;\n            si3 = si2 + 1;\n            if ((unsigned char)src[si] <= 127) {\n                dest[di++] = src[si++];\n                conv++;\n            } else if ((unsigned char)src[si] <= 223) {\n                if (((unsigned char)src[si] & 28) == 0) {\n                    dest[di++] = ((src[si] & 3) << 6) | (src[si2] & 63);\n                    conv++;\n                }\n                si += 2;\n            } else if ((unsigned char)src[si] <= 239) {\n                si += 3;\n            } else if ((unsigned char)src[si] <= 247) {\n                si += 4;\n            }\n        }\n    dest[di] = '\\x00';\n    return conv;\n}\n","function_prediction":"int Utf8ToAnsi_name_conflict(char *ansi, const char *utf8, int ansi_size) {\n  int i, j, k;\n\n  i = j = k = 0;\n  while (utf8[i] && j < ansi_size - 1) {\n    if (utf8[i] & 0x80) {\n      if (utf8[i] & 0xe0) {\n        if (utf8[i] & 0xf0) {\n          if (utf8[i] & 0xf8) {\n            i += 4;\n          } else {\n            i += 3;\n          }\n        } else {\n          i += 2;\n        }\n      } else {\n        if (utf8[i] & 0x1c) {\n          i += 2;\n        } else {\n          ansi[j] = (utf8[i] << 6) | (utf8[i + 1] & 0x3f);\n          i += 2;\n          j++;\n        }\n      }\n    } else {\n      ansi[j] = utf8[i];\n      i++;\n      j++;\n    }\n    k++;\n  }\n  ansi[j] = 0;\n  return k;\n}","pass":0,"source_file":"C_COMPILE/f1436/main_1436.c"}
{"compilable":1,"function":"int read_csi_buf(unsigned char *buf_addr, int fd, int BUFSIZE) {\n    int cnt;\n    cnt = read(fd, buf_addr, BUFSIZE);\n    if (cnt)\n        return cnt;\n    else\n        return 0;\n}\n","function_prediction":"int read_csi_buf_name_conflict(void *buf, int fd, int len) {\n  int ret;\n\n  ret = read(fd, buf, len);\n  if (ret == 0)\n    return 0;\n\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/f1341/main_1341.c"}
{"compilable":0,"function":"__attribute__((always_inline)) static inline const char *is_decode16u_msb(const char *p, unsigned short *w) {\n    *w = *(const unsigned char *)(p + 0);\n    *w = *(const unsigned char *)(p + 1) + (*w << 8);\n    p += 2;\n    return p;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1567/main_1567.c"}
{"compilable":1,"function":"const char *jx9ExtractDirName(const char *zPath, int nByte, int *pLen) {\n    const char *zEnd = &zPath[nByte - 1];\n    int c, d;\n    c = d = '/';\n    while (zEnd > zPath && ((int)zEnd[0] != c && (int)zEnd[0] != d))\n        {\n            zEnd--;\n        }\n    *pLen = (int)(zEnd - zPath);\n    if (zEnd == zPath && ((int)zEnd[0] != c && (int)zEnd[0] != d)) {\n        *pLen = sizeof(char);\n        return \".\";\n    }\n    if ((*pLen) == 0) {\n        *pLen = sizeof(char);\n        return \"/\";\n    }\n    return zPath;\n}\n","function_prediction":"const char *jx9ExtractDirName_name_conflict(const char *path, int pathLen, int *dirNameLen) {\n  const char *p;\n\n  p = path + pathLen - 1;\n  while (p > path && *p != '/' && *p != '\\\\')\n    p--;\n  *dirNameLen = p - path;\n  if (p == path && *p != '/' && *p != '\\\\') {\n    *dirNameLen = 1;\n    return \".\";\n  }\n  if (*dirNameLen == 0) {\n    *dirNameLen = 1;\n    return \"/\";\n  }\n  return path;\n}","pass":1,"source_file":"C_COMPILE/f1804/main_1804.c"}
{"compilable":0,"function":"static inline sig_atomic_t atomic_incsa(sig_atomic_t *var) {\n    return __sync_fetch_and_add_4(var, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f265/main_265.c"}
{"compilable":1,"function":"static char *kill_trailingn(char *s, char t, char *e) {\n    if (e == s)\n        *e = '\\x00';\n    else if (e > s) {\n        while (e > s && *--e == t)\n            {\n                ;\n            }\n        e[*e == t ? 0 : 1] = '\\x00';\n    }\n    return s;\n}\n","function_prediction":"char *kill_trailingn_name_conflict(char *end, char c, char *s) {\n  if (s == end)\n    *s = '\\0';\n  else {\n    while (s > end && *--s == c)\n      ;\n    if (*s != c)\n      *++s = '\\0';\n  }\n  return end;\n}","pass":1,"source_file":"C_COMPILE/f57/main_57.c"}
{"compilable":1,"function":"int max_index(int idx[], int a[], int n) {\n    int s = 0, k;\n    int j, max, x = 0;\n    max = a[0];\n    for (j = 0; j < n; j++) {\n        if (max < a[j]) {\n            max = a[j];\n            x = j;\n        }\n    }\n    for (j = 0 , k = 0; j < n; j++)\n        if (max == a[j]) {\n            idx[k] = j;\n            k++ , s++;\n        }\n    return s;\n}\n","function_prediction":"int max_index_name_conflict(int *index, int *array, int n) {\n  int i, max, count, j;\n  max = array[0];\n  for (i = 0; i < n; i++) {\n    if (array[i] > max)\n      max = array[i];\n  }\n  count = 0;\n  for (i = 0; i < n; i++) {\n    if (array[i] == max) {\n      index[count] = i;\n      count++;\n    }\n  }\n  return count;\n}","pass":1,"source_file":"C_COMPILE/f1774/main_1774.c"}
{"compilable":1,"function":"static char *_stpcpy(char *dest, const char *src) {\n    size_t i;\n    for (i = 0; src[i]; ++i)\n        dest[i] = src[i];\n    dest[i] = 0;\n    return dest + i;\n}\n","function_prediction":"char *_stpcpy_name_conflict(char *dest, const char *src) {\n  size_t i;\n\n  for (i = 0; src[i]; i++)\n    dest[i] = src[i];\n  dest[i] = '\\0';\n\n  return dest + i;\n}","pass":1,"source_file":"C_COMPILE/f1051/main_1051.c"}
{"compilable":1,"function":"char *my_strcpy1(char *destination, const char *source) {\n    int i;\n    for (i = 0; source[i] != '\\x00'; i++) {\n        destination[i] = source[i];\n    }\n    destination[i] = '\\x00';\n    return destination;\n}\n","function_prediction":"char *my_strcpy1_name_conflict(char *dest, const char *src) {\n  int i;\n\n  for (i = 0; src[i] != '\\0'; i++)\n    dest[i] = src[i];\n  dest[i] = '\\0';\n  return (dest);\n}","pass":1,"source_file":"C_COMPILE/f2065/main_2065.c"}
{"compilable":0,"function":"static inline int sync_test_and_clear_bit(int nr, volatile unsigned long *addr) {\n    int oldbit;\n    asm volatile (\"lock; btrl %2,%1\\n\\tsbbl %0,%0\" : \"=r\" (oldbit), \"+m\" ((*(volatile long *)addr)) : \"Ir\" (nr) : \"memory\");\n    return oldbit;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1870/main_1870.c"}
{"compilable":0,"function":"static int cleanup_pipes(int *pipes) {\n    if (pipes) {\n        close(pipes[1]);\n        close(pipes[2]);\n        pipes[1] = pipes[3];\n        pipes[2] = -1;\n        pipes[3] = -1;\n    }\n    return 0;\n}\n","function_prediction":"int cleanup_pipes_name_conflict(struct pipes *p) {\n  if (p) {\n    close(p->read_fd);\n    close(p->write_fd);\n    p->read_fd = p->read_fd_alt;\n    p->write_fd = -1;\n    p->read_fd_alt = -1;\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1012/main_1012.c"}
{"compilable":1,"function":"static int find_mem_diff(const char *a, const char *b, size_t n, size_t *offset) {\n    size_t i;\n    if (a == b)\n        return 0;\n    if (!a || !b)\n        return 2;\n    for (i = 0; i < n; i++) {\n        if (a[i] != b[i]) {\n            *offset = i;\n            return 1;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int find_mem_diff_name_conflict(const void *p1, const void *p2, size_t len, size_t *pos) {\n  size_t i;\n  if (p1 == p2)\n    return 0;\n  if (!p1 || !p2)\n    return 2;\n  for (i = 0; i < len; i++) {\n    if (((char *)p1)[i] != ((char *)p2)[i]) {\n      *pos = i;\n      return 1;\n    }\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f205/main_205.c"}
{"compilable":1,"function":"int R90deg(int *x, int *y) {\n    int loc_x = *x, loc_y = *y;\n    *x = -loc_y;\n    *y = loc_x;\n    return 0;\n}\n","function_prediction":"int R90deg_name_conflict(int *x, int *y) {\n  int t;\n\n  t = *x;\n  *x = -*y;\n  *y = t;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f3/main_3.c"}
{"compilable":1,"function":"int SDL_imageFilterShiftRightMMX(unsigned char *Src1, unsigned char *Dest, unsigned int SrcLength, unsigned char N, unsigned char *Mask) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterShiftRightMMX_name_conflict(void *A, void *B, int Ai, int Bi, int len) {\n  return -1;\n}","pass":1,"source_file":"C_COMPILE/f909/main_909.c"}
{"compilable":1,"function":"size_t utoa(char *str, unsigned int u) {\n    char tmp[12];\n    char *end = tmp + sizeof (tmp);\n    char *p = end - 1;\n    char *s = str;\n    do {\n        *p-- = '0' + (u % 10);\n        u /= 10;\n    } while (u != 0);\n    for (++p; p < end; p++)\n        *s++ = *p;\n    *s = 0;\n    return (size_t)(s - str);\n}\n","function_prediction":"size_t utoa_name_conflict(char *buf, unsigned int n) {\n  char *p = buf;\n  char tmp[10];\n  char *t = tmp + 10;\n\n  do {\n    *--t = n % 10 + '0';\n    n /= 10;\n  } while (n);\n\n  while (t < tmp + 10)\n    *p++ = *t++;\n\n  *p = '\\0';\n\n  return p - buf;\n}","pass":1,"source_file":"C_COMPILE/f1862/main_1862.c"}
{"compilable":1,"function":"int unpack_int(unsigned char bytes[4]) {\n    int output = 0;\n    output += bytes[0];\n    output += bytes[1] << 8;\n    output += bytes[2] << 16;\n    output += bytes[3] << 24;\n    return output;\n}\n","function_prediction":"int unpack_int_name_conflict(const unsigned char *buf) {\n  return (buf[0] + (buf[1] << 8) + (buf[2] << 16) + (buf[3] << 24));\n}","pass":1,"source_file":"C_COMPILE/f1910/main_1910.c"}
{"compilable":0,"function":"__attribute__((unused)) static inline unsigned int psnip_builtin_addc(unsigned int x, unsigned int y, unsigned int ci, unsigned int *co) {\n    unsigned int max = 0;\n    unsigned int r = (unsigned int)x + y;\n    max = ~max;\n    *co = (unsigned int)(x > (max - y));\n    if (ci) {\n        if (r == max)\n            *co = 1;\n        r += ci;\n    }\n    return r;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1762/main_1762.c"}
{"compilable":1,"function":"int compare(int *min, int *mid, int *max) {\n    int temp;\n    if (*min > *mid) {\n        temp = *min;\n        *min = *mid;\n        *mid = temp;\n    }\n    if (*min > *max) {\n        temp = *min;\n        *min = *max;\n        *max = temp;\n    }\n    if (*mid > *max) {\n        temp = *mid;\n        *mid = *max;\n        *max = temp;\n    }\n    return 0;\n}\n","function_prediction":"int compare_name_conflict(int *a, int *b, int *c) {\n  if (*a > *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n  }\n  if (*a > *c) {\n    int temp = *a;\n    *a = *c;\n    *c = temp;\n  }\n  if (*b > *c) {\n    int temp = *b;\n    *b = *c;\n    *c = temp;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f581/main_581.c"}
{"compilable":0,"function":"__attribute__((always_inline)) static inline short _InterlockedXor16(volatile short *const value, const short mask) {\n    return __sync_fetch_and_xor_2(value, mask);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f275/main_275.c"}
{"compilable":1,"function":"static char *pfSignedDec(char *parseBuffer, long value) {\n    parseBuffer[23] = 0;\n    char *current = parseBuffer + 22;\n    int runningValue = value;\n    if (runningValue < 0)\n        runningValue *= -1;\n    do {\n        int digit = runningValue % 10;\n        runningValue /= 10;\n        *current-- = '0' + digit;\n    } while (runningValue);\n    if (value < 0)\n        *current-- = '-';\n    return current + 1;\n}\n","function_prediction":"char *pfSignedDec_name_conflict(char *buf, int32_t val) {\n  char *p = buf + 23;\n  *p = '\\0';\n  if (val < 0)\n    val = -val;\n  do {\n    *--p = '0' + val % 10;\n    val /= 10;\n  } while (val);\n  if (val < 0)\n    *--p = '-';\n  return p + 1;\n}","pass":0,"source_file":"C_COMPILE/f1309/main_1309.c"}
{"compilable":1,"function":"static int wordsnum(const char *s, int *l, char c) {\n    int words;\n    *l = -1;\n    words = 0;\n    while (s && s[++*l])\n        if ((*l == 0 || s[*l - 1] == c) && s[*l] != c)\n            words++;\n    return (words);\n}\n","function_prediction":"int wordsnum_name_conflict(char *str, int *i, char c) {\n  int n;\n\n  *i = -1;\n  n = 0;\n  while (str && str[++(*i)])\n    if (!*i || str[*i - 1] == c && str[*i] != c)\n      n++;\n  return (n);\n}","pass":0,"source_file":"C_COMPILE/f225/main_225.c"}
{"compilable":0,"function":"int to_verify(int *arr) {\n    return arr[3]++;\n}\n","function_prediction":"void to_verify_name_conflict(struct test_struct *ts) { ts->a++; }","pass":0,"source_file":"C_COMPILE/f1897/main_1897.c"}
{"compilable":0,"function":"char *encrypt(char *senha) {\n    while (*senha)\n        {\n            *senha = *senha ^ 31;\n            senha++;\n        }\n    return senha;\n}\n","function_prediction":"void encrypt_name_conflict(char *str) {\n  char *p = str;\n  while (*p) {\n    *p++ ^= 0x1f;\n  }\n}","pass":0,"source_file":"C_COMPILE/f298/main_298.c"}
{"compilable":1,"function":"char *strdchr(char *p) {\n    char *t;\n    if (p != ((void *)0)) {\n        for (t = p; *t; t++) {\n            *t = *(t + 1);\n        }\n    }\n    return (p);\n}\n","function_prediction":"char *strdchr_name_conflict(char *s) {\n  if (s) {\n    while (*s) {\n      *s = *(s + 1);\n      s++;\n    }\n  }\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f2052/main_2052.c"}
{"compilable":0,"function":"static int printf_binary_arginfo(const struct printf_info *info, size_t n, int *types, int *sizes) {\n    if (n < 1)\n        return -1;\n    (void)sizes;\n    types[0] = info->is_long_double ? PA_INT | (1 << 8) : info->is_long ? PA_INT | (1 << 9) : info->is_char ? PA_CHAR : info->is_short ? PA_INT | (1 << 10) : PA_INT;\n    return 1;\n}\n","function_prediction":"int printf_binary_arginfo_name_conflict(const struct printf_info *pi, size_t n,\n                          int *argtypes) {\n  if (n > 0) {\n    if (pi->is_long)\n      argtypes[0] = 256;\n    else if (pi->is_short)\n      argtypes[0] = 512;\n    else if (pi->is_char)\n      argtypes[0] = 1;\n    else\n      argtypes[0] = 256;\n    return 1;\n  }\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f2056/main_2056.c"}
{"compilable":0,"function":"int SDL_imageFilterMultNorASM(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterMultNorASM_name_conflict(void *A, void *B, void *C, int hA, int wA, int hB,\n                              int wB, int hC, int wC) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1480/main_1480.c"}
{"compilable":0,"function":"int file_packet_DATA_ACK(unsigned char *data, int dataLen) {\n}\n","function_prediction":"void file_packet_DATA_ACK_name_conflict(uint8_t *data, uint16_t len) {}","pass":0,"source_file":"C_COMPILE/f1518/main_1518.c"}
{"compilable":1,"function":"int connectToServer(int *pSockConnection, int serverPort) {\n    struct sockaddr_in sAddr;\n    if ((*pSockConnection = socket(2, SOCK_DGRAM, IPPROTO_UDP)) == -1) {\n        return -1;\n    }\n    sAddr.sin_family = 2;\n    sAddr.sin_port = htons(serverPort);\n    if (connect(*pSockConnection, (struct sockaddr *)&sAddr, sizeof (sAddr)) == -1) {\n        close(*pSockConnection);\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int connectToServer_name_conflict(int *sock, int port) {\n  struct sockaddr_in server;\n\n  *sock = socket(2, 2, 17);\n  if (*sock == -1)\n    return -1;\n\n  server.sin_family = 2;\n  server.sin_port = htons(port);\n\n  if (connect(*sock, (struct sockaddr *)&server, sizeof(server)) == -1) {\n    close(*sock);\n    return -1;\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f2112/main_2112.c"}
{"compilable":1,"function":"int ident_codon(char *codon) {\n    int icode = 0;\n    int x;\n    for (x = 0; x < 3; x++) {\n        switch (codon[x]) {\n          case 'T':\n          case 't':\n          case 'U':\n          case 'u':\n            codon[x] = (char)1;\n            continue;\n          case 'C':\n          case 'c':\n            codon[x] = (char)2;\n            continue;\n          case 'A':\n          case 'a':\n            codon[x] = (char)3;\n            continue;\n          case 'G':\n          case 'g':\n            codon[x] = (char)4;\n            continue;\n          case '\\x00':\n            return 0;\n          default:\n            codon[x] = (char)0;\n            break;\n        }\n    }\n    if (codon[0] * codon[1] * codon[2] != 0)\n        icode = (codon[0] - 1) * 16 + codon[1] + (codon[2] - 1) * 4;\n    else\n        icode = 0;\n    return icode;\n}\n","function_prediction":"int ident_codon_name_conflict(char *codon) {\n  int i, aa;\n\n  for (i = 0; i < 3; i++) {\n    if (codon[i] == '\\0')\n      return 0;\n    switch (codon[i]) {\n    case 'A':\n    case 'a':\n      codon[i] = 3;\n      break;\n    case 'C':\n    case 'c':\n      codon[i] = 2;\n      break;\n    case 'G':\n    case 'g':\n      codon[i] = 4;\n      break;\n    case 'T':\n    case 'U':\n    case 't':\n    case 'u':\n      codon[i] = 1;\n      break;\n    default:\n      codon[i] = '\\0';\n    }\n  }\n  if (codon[0] * codon[1] * codon[2] == 0)\n    return 0;\n  aa = (codon[0] - 1) * 16 + (codon[1] - 1) * 4 + codon[2];\n  return aa;\n}","pass":0,"source_file":"C_COMPILE/f1877/main_1877.c"}
{"compilable":1,"function":"int endian_swap(unsigned int *x) {\n    *x = (*x >> 24) | ((*x << 8) & 16711680) | ((*x >> 8) & 65280) | (*x << 24);\n    return *x;\n}\n","function_prediction":"uint32_t endian_swap_name_conflict(uint32_t *x) {\n  uint32_t y = *x;\n  *x = (y & 0x000000FFU) << 24 | (y & 0x0000FF00U) << 8 |\n       (y & 0x00FF0000U) >> 8 | (y & 0xFF000000U) >> 24;\n  return *x;\n}","pass":1,"source_file":"C_COMPILE/f413/main_413.c"}
{"compilable":0,"function":"int file_perms_parse_group(const unsigned char *group) {\n    return -1;\n}\n","function_prediction":"int file_perms_parse_group_name_conflict(const char *str, int *perms) { return -1; }","pass":0,"source_file":"C_COMPILE/f1961/main_1961.c"}
{"compilable":0,"function":"static int smtp_si_sub_size_t(const size_t a, const size_t b, size_t *const result) {\n    int wraps;\n    if (a < b) {\n        wraps = 1;\n    } else {\n        wraps = 0;\n    }\n    if (result) {\n        *result = a - b;\n    }\n    return wraps;\n}\n","function_prediction":"int smtp_si_sub_size_t_name_conflict(size_t a, size_t b, size_t *r) {\n  if (r)\n    *r = a - b;\n  return a < b;\n}","pass":0,"source_file":"C_COMPILE/f463/main_463.c"}
{"compilable":1,"function":"int MPI_Cart_create(int comm_old, int ndims, int *dims, int *periods, int reorder, int *comm_cart) {\n    *comm_cart = comm_old;\n    return 0;\n}\n","function_prediction":"int MPI_Cart_create_name_conflict(int comm_old, int ndims, int *dims, int *periods,\n                    int reorder, int *comm_cart) {\n  *comm_cart = comm_old;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f950/main_950.c"}
{"compilable":1,"function":"static char *get_name(char *old_name, char string[12]) {\n    int c;\n    char *np, *rnp;\n    np = string;\n    rnp = old_name;\n    while ((c = *rnp) == '/')\n        rnp++;\n    while (rnp < &old_name[128] && c != '/' && c != '\\x00')\n        {\n            if (np < &string[12])\n                *np++ = c;\n            c = *++rnp;\n        }\n    while (c == '/' && rnp < &old_name[128])\n        c = *++rnp;\n    if (np < &string[12])\n        *np = '\\x00';\n    return (rnp);\n}\n","function_prediction":"char *get_name_name_conflict(char *path, char *name) {\n  char *p, *q;\n\n  for (p = path; *p == '/'; p++)\n    ;\n\n  for (q = name; p < path + 128 && *p != '/' && *p != '\\0'; p++) {\n    if (q < name + 12)\n      *q++ = *p;\n  }\n\n  while (*p == '/' && p < path + 128)\n    p++;\n\n  if (q < name + 12)\n    *q = '\\0';\n\n  return p;\n}","pass":0,"source_file":"C_COMPILE/f1027/main_1027.c"}
{"compilable":1,"function":"int copys(char to[], char from[]) {\n    int i = 0;\n    while ((to[i] = from[i]) != '\\x00')\n        {\n            ++i;\n        }\n    return 0;\n}\n","function_prediction":"int copys_name_conflict(char *s, char *t) {\n  int i;\n\n  for (i = 0; *(s + i) = *(t + i); i++)\n    if (*(s + i) == '\\0')\n      break;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1970/main_1970.c"}
{"compilable":1,"function":"static int Pack_Tag(char *tags, char *qvs, int rlen, int rchar) {\n    int j, k;\n    j = 0;\n    for (k = 0; k < rlen; k++)\n        if (qvs[k] != rchar)\n            tags[j++] = tags[k];\n    tags[j] = '\\x00';\n    return (j);\n}\n","function_prediction":"int Pack_Tag_name_conflict(char *tag, char *mask, int len, int delim) {\n  int i, j;\n\n  for (i = j = 0; i < len; i++)\n    if (mask[i] != delim)\n      tag[j++] = tag[i];\n  tag[j] = '\\0';\n  return j;\n}","pass":1,"source_file":"C_COMPILE/f1823/main_1823.c"}
{"compilable":1,"function":"char *do_door(int *door, int *movement, int operation) {\n    if (!operation) {\n        if (!*door && *movement) {\n            *door = 1;\n            *movement = 0;\n            return \"OPEN\";\n        }\n        if (*door && *movement) {\n            *door = 0;\n            *movement = 0;\n            return \"CLOSED\";\n        }\n    }\n    if (!*door && !*movement && operation) {\n        *movement = 1;\n        return \"OPENING\";\n    }\n    if (*door && !*movement && operation) {\n        *movement = 1;\n        return \"CLOSING\";\n    }\n    if (*door && *movement && operation) {\n        *movement = 0;\n        *door = 0;\n        return \"STOPPED_WHILE_CLOSING\";\n    }\n    if (!*door && *movement && operation) {\n        *movement = 0;\n        *door = 1;\n        return \"STOPPED_WHILE_OPENING\";\n    }\n    return \"ERROR\";\n}\n","function_prediction":"char *do_door_name_conflict(int *door_open, int *door_open_request,\n              int door_open_request_value) {\n  if (door_open_request_value == 0) {\n    if (*door_open == 0 && *door_open_request != 0) {\n      *door_open = 1;\n      *door_open_request = 0;\n      return \"OPEN\";\n    }\n    if (*door_open != 0 && *door_open_request != 0) {\n      *door_open = 0;\n      *door_open_request = 0;\n      return \"CLOSED\";\n    }\n  }\n  if (*door_open == 0 && *door_open_request == 0 &&\n      door_open_request_value != 0) {\n    *door_open_request = 1;\n    return \"OPENING\";\n  }\n  if (*door_open == 0 || *door_open_request != 0 ||\n      door_open_request_value == 0) {\n    if (*door_open == 0 || *door_open_request == 0 ||\n        door_open_request_value == 0) {\n      if (*door_open == 0 && *door_open_request != 0 &&\n          door_open_request_value != 0) {\n        *door_open_request = 0;\n        *door_open = 1;\n        return \"STOPPED_WHILE_OPENING\";\n      }\n      return \"ERROR\";\n    }\n    *door_open_request = 0;\n    *door_open = 0;\n    return \"STOPPED_WHILE_CLOSING\";\n  }\n  *door_open_request = 1;\n  return \"CLOSING\";\n}","pass":1,"source_file":"C_COMPILE/f2099/main_2099.c"}
{"compilable":1,"function":"unsigned int _scan_un(const char *s, unsigned char *d) {\n    const char *t = s;\n    register unsigned char n = 0;\n    unsigned char c;\n    for (; (c = *t - '0') < 10; ++t)\n        n += ((n * 10) + c);\n    if (t - s)\n        *d = n;\n    return t - s;\n}\n","function_prediction":"size_t _scan_un_name_conflict(const char *s, unsigned *v) {\n  const char *p = s;\n  unsigned val = 0;\n\n  while (*p >= '0' && *p <= '9')\n    val = val * 10 + *p++ - '0';\n\n  if (p != s)\n    *v = val;\n\n  return p - s;\n}","pass":0,"source_file":"C_COMPILE/f542/main_542.c"}
{"compilable":1,"function":"int mem_getversion(int *version) {\n    *version = 10;\n    return (0);\n}\n","function_prediction":"int mem_getversion_name_conflict(int *version) {\n  *version = 10;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1262/main_1262.c"}
{"compilable":0,"function":"static inline short atomic_inc_short(short *v) {\n    asm (\"addw $1, %0\" : \"+m\" (*v));\n    return *v;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f722/main_722.c"}
{"compilable":1,"function":"int ok_smul3(int x, int y, int *dest) {\n    int result;\n    *dest = x * y;\n    asm (\"setae %%bl; movzbl %%bl,%0\" : \"=r\" (result) :  : \"%ebx\");\n    return result;\n}\n","function_prediction":"int ok_smul3_name_conflict(int a, int b, int *c) {\n  *c = a * b;\n  return (long long)*c == (long long)a * b;\n}","pass":0,"source_file":"C_COMPILE/f1932/main_1932.c"}
{"compilable":1,"function":"int userHashFunctionDJB2(char *pKey, unsigned int size, unsigned int *pResult, unsigned int tableSize) {\n    unsigned long hash = 5381;\n    int c;\n    while ((c = *pKey++))\n        {\n            hash = ((hash << 5) + hash) + c;\n        }\n    *pResult = hash % tableSize;\n    return 1;\n}\n","function_prediction":"int userHashFunctionDJB2_name_conflict(char *key, int keyLength, int *hashValue,\n                         int hashTableSize) {\n  unsigned long hash = 5381;\n  int c;\n\n  while ((c = *key++))\n    hash = ((hash << 5) + hash) + c;\n\n  *hashValue = hash % hashTableSize;\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f1700/main_1700.c"}
{"compilable":0,"function":"int MPI_Comm_split(int comm, int color, int key, int *comm_out) {\n    *comm_out = comm;\n    return 0;\n}\n","function_prediction":"int MPI_Comm_split_name_conflict(MPI_Comm comm, int color, int key, MPI_Comm *newcomm) {\n  *newcomm = comm;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f367/main_367.c"}
{"compilable":0,"function":"static unsigned long xchg(unsigned long *p, unsigned long val) {\n    return __atomic_exchange_n(p, val, 5);\n}\n","function_prediction":"void *xchg_name_conflict(void **ptr, void *val) {\n  void *old;\n\n  LOCK();\n  old = *ptr;\n  *ptr = val;\n  UNLOCK();\n\n  return old;\n}","pass":0,"source_file":"C_COMPILE/f68/main_68.c"}
{"compilable":1,"function":"static unsigned short BitMaskDetails(unsigned long mask, unsigned short *left_shift, unsigned short *right_shift) {\n    unsigned short i;\n    unsigned long m = mask;\n    if (mask == 0) {\n        *left_shift = 0;\n        *right_shift = 0;\n        return 0;\n    }\n    for (i = 0; i < 32; i++) {\n        if ((((m << 1) & 4294967295U) >> 1) != m)\n            break;\n        else\n            m <<= 1;\n    }\n    *left_shift = i;\n    m = mask;\n    for (i = 0; i < 32; i++) {\n        if (((m >> 1) << 1) != m)\n            break;\n        else\n            m >>= 1;\n    }\n    *right_shift = i;\n    return (unsigned short)m;\n}\n","function_prediction":"unsigned long BitMaskDetails_name_conflict(unsigned long mask, unsigned short *leading,\n                             unsigned short *trailing) {\n  unsigned short i;\n\n  if (mask == 0) {\n    *leading = 0;\n    *trailing = 0;\n    return 0;\n  }\n\n  for (i = 0; i < 32; i++) {\n    if ((mask & 0x80000000) == 0)\n      break;\n    mask <<= 1;\n  }\n  *leading = i;\n\n  for (i = 0; i < 32; i++) {\n    if ((mask & 1) == 0)\n      break;\n    mask >>= 1;\n  }\n  *trailing = i;\n\n  return mask;\n}","pass":0,"source_file":"C_COMPILE/f1759/main_1759.c"}
{"compilable":1,"function":"char *cat_str(char *dest, char *src) {\n    char *ptr = (char *)((void *)0);\n    char *dptr = (char *)((void *)0);\n    for (ptr = src , dptr = dest; *ptr != '\\x00'; ptr++) {\n        *dptr = *ptr;\n        dptr++;\n    }\n    *dptr = '\\x00';\n    return dptr;\n}\n","function_prediction":"char *cat_str_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  while (*s)\n    *d++ = *s++;\n  *d = '\\0';\n\n  return d;\n}","pass":1,"source_file":"C_COMPILE/f1438/main_1438.c"}
{"compilable":0,"function":"static inline unsigned int to_http_js_string(char *buffer, const char *value) {\n    unsigned int offset = 0;\n    while (*value)\n        {\n            if ((*value == '\\\\') || (*value == '\\''))\n                buffer[offset++] = '\\\\';\n            buffer[offset++] = *value++;\n        }\n    buffer[offset] = 0;\n    return offset;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1351/main_1351.c"}
{"compilable":0,"function":"static int atomic_add_return(int *v, int i) {\n    int rc;\n    asm (\"lock\\n\\txaddl %0,(%1)\" : \"=r\" (rc) : \"r\" (v), \"0\" (i) : \"memory\");\n    return rc + i;\n}\n","function_prediction":"int atomic_add_return_name_conflict(atomic_t *v, int a) {\n  int ret;\n\n  LOCK();\n  ret = v->counter + a;\n  v->counter = ret;\n  UNLOCK();\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/f99/main_99.c"}
{"compilable":0,"function":"char *inet_ntoa_r(struct in_addr in, char *buffer) {\n    unsigned char *bytes = (unsigned char *)&in;\n    __snprintf(buffer, sizeof (buffer), \"%d.%d.%d.%d\", bytes[0], bytes[1], bytes[2], bytes[3]);\n    return buffer;\n}\n","function_prediction":"char *inet_ntoa_r_name_conflict(uint32_t ip, char *buf) {\n  uint8_t *ip_bytes = (uint8_t *)&ip;\n  __snprintf(buf, 8, \"%d.%d.%d.%d\", ip_bytes[0], ip_bytes[1], ip_bytes[2],\n             ip_bytes[3]);\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/f2014/main_2014.c"}
{"compilable":1,"function":"char *ft_strcpy(char *dest, char *src) {\n    int i;\n    i = 0;\n    while (src[i] != '\\x00')\n        {\n            dest[i] = src[i];\n            i++;\n        }\n    return (dest);\n}\n","function_prediction":"char *ft_strcpy_name_conflict(char *dest, const char *src) {\n  int i;\n\n  i = 0;\n  while (src[i] != '\\0') {\n    dest[i] = src[i];\n    i++;\n  }\n  return (dest);\n}","pass":1,"source_file":"C_COMPILE/f467/main_467.c"}
{"compilable":1,"function":"int Media_DVD_SPUCTRL(int size, unsigned char *data) {\n    return 0;\n}\n","function_prediction":"int Media_DVD_SPUCTRL_name_conflict(int fd, int mode) { return 0; }","pass":1,"source_file":"C_COMPILE/f1194/main_1194.c"}
{"compilable":1,"function":"static int EncodeInt32LE(char *output, int nVal) {\n    output[0] = nVal;\n    nVal >>= 8;\n    output[1] = nVal;\n    nVal >>= 8;\n    output[2] = nVal;\n    nVal >>= 8;\n    output[3] = nVal;\n    return 4;\n}\n","function_prediction":"int EncodeInt32LE_name_conflict(char *buf, int32_t val) {\n  buf[0] = (char)val;\n  buf[1] = (char)(val >> 8);\n  buf[2] = (char)(val >> 16);\n  buf[3] = (char)(val >> 24);\n  return 4;\n}","pass":1,"source_file":"C_COMPILE/f724/main_724.c"}
{"compilable":1,"function":"int str2int(char *str, int *num) {\n    int i = 0;\n    *num = 0;\n    while (str[i] != 0)\n        {\n            if (str[i] <= '9' && str[i] >= '0') {\n                *num *= 10;\n                *num += str[i++] - '0';\n            } else\n                return 1;\n        }\n    return 0;\n}\n","function_prediction":"int str2int_name_conflict(char *str, int *num) {\n  int i;\n\n  *num = 0;\n  for (i = 0; str[i] != '\\0'; i++) {\n    if (str[i] > '9' || str[i] < '0')\n      return 1;\n    *num *= 10;\n    *num += str[i] - '0';\n  }\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f688/main_688.c"}
{"compilable":1,"function":"int my_max(int *x, int *y) {\n    *x = *x > *y ? *x : *y;\n    *y = 0;\n    return *x;\n}\n","function_prediction":"int my_max_name_conflict(int *a, int *b) {\n  *a = (*a > *b) ? *a : *b;\n  *b = 0;\n  return *a;\n}","pass":1,"source_file":"C_COMPILE/f537/main_537.c"}
{"compilable":1,"function":"int test(char *s, char *t) {\n    int i = 0;\n    int j = 0;\n    int flag = 0;\n    for (; s[j] != '\\x00'; j++) {\n        flag = 0;\n        for (i = 0; t[i] != '\\x00'; i++) {\n            if (s[j] == t[i]) {\n                flag = 1;\n                t[i] = '+';\n                break;\n            }\n        }\n        if (t[i] == '\\x00' && flag == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"int test_name_conflict(char *s, char *p) {\n  int i, j, flag;\n\n  for (i = 0; s[i]; i++) {\n    flag = 0;\n    for (j = 0; p[j]; j++) {\n      if (s[i] == p[j]) {\n        flag = 1;\n        p[j] = '+';\n        break;\n      }\n    }\n    if (!p[j] && !flag)\n      return 0;\n  }\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/f1843/main_1843.c"}
{"compilable":0,"function":"static inline int _hclib_atomic_inc_acq_rel(volatile int *target) {\n    return __sync_add_and_fetch_4(target, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1527/main_1527.c"}
{"compilable":1,"function":"int force_read(int fd, unsigned char *buf, int sz) {\n    int got = 0, rd;\n    while (sz > 0)\n        {\n            rd = read(fd, buf, sz);\n            if (rd <= 0)\n                break;\n            got += rd;\n            buf += rd;\n            sz -= rd;\n        }\n    return got;\n}\n","function_prediction":"int force_read_name_conflict(int fd, void *buf, int len) {\n  int n, total = 0;\n\n  while (len > 0) {\n    n = read(fd, buf, len);\n    if (n <= 0)\n      break;\n    total += n;\n    buf += n;\n    len -= n;\n  }\n\n  return total;\n}","pass":1,"source_file":"C_COMPILE/f482/main_482.c"}
{"compilable":1,"function":"char *RowColumnConvert(char *matrix) {\n    for (int row = 0; row < 4; row++) {\n        for (int col = row + 1; col < 5 - 1; col++) {\n            ((matrix[row * 5 + col]) = (matrix[row * 5 + col]) ^ (matrix[col * 5 + row]) ^ (matrix[col * 5 + row] = matrix[row * 5 + col]));\n        }\n    }\n    return matrix;\n}\n","function_prediction":"unsigned char *RowColumnConvert_name_conflict(unsigned char *p) {\n  int i, j;\n  unsigned char t;\n\n  for (i = 0; i < 4; i++)\n    for (j = i + 1; j < 4; j++) {\n      t = p[i * 5 + j];\n      p[i * 5 + j] = p[j * 5 + i];\n      p[j * 5 + i] = t ^ p[i * 5 + j];\n    }\n\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f1918/main_1918.c"}
{"compilable":0,"function":"static inline int a_fetch_add(volatile int *x, int v) {\n    asm (\"lock ; xadd %0, %1\" : \"=r\" (v), \"=m\" (*x) : \"0\" (v) : \"memory\");\n    return v;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f352/main_352.c"}
{"compilable":1,"function":"char *strCpy(char *dest, char *source) {\n    char *ptr = dest;\n    while ((*ptr++ = *source++) != '\\x00')\n        ;\n    return dest;\n}\n","function_prediction":"char *strCpy_name_conflict(char *dest, const char *src) {\n  char *s = dest;\n  while ((*s++ = *src++) != '\\0')\n    ;\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f2030/main_2030.c"}
{"compilable":1,"function":"int manos_socket_close(int fd, int *err) {\n    int result = close(fd);\n    *err = (*__errno_location());\n    return result;\n}\n","function_prediction":"int manos_socket_close_name_conflict(int fd, int *err) {\n  int ret = close(fd);\n  *err = *__errno_location();\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/f1087/main_1087.c"}
{"compilable":1,"function":"int _cfsetispeed(struct termios *termios_p, speed_t speed) {\n    termios_p->c_ispeed = speed;\n    return 0;\n}\n","function_prediction":"int _cfsetispeed_name_conflict(struct termios *t, speed_t s) {\n  t->c_ispeed = s;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1521/main_1521.c"}
{"compilable":1,"function":"char *ft_strcpy(char *copy, const char *src) {\n    unsigned int index;\n    index = 0;\n    while (src[index] != 0)\n        {\n            copy[index] = src[index];\n            index++;\n        }\n    copy[index] = 0;\n    return (copy);\n}\n","function_prediction":"char *ft_strcpy_name_conflict(char *dest, const char *src) {\n  unsigned int i;\n\n  i = 0;\n  while (src[i] != '\\0') {\n    dest[i] = src[i];\n    i++;\n  }\n  dest[i] = '\\0';\n  return (dest);\n}","pass":1,"source_file":"C_COMPILE/f578/main_578.c"}
{"compilable":1,"function":"char *ft_strcpy(char *dest, char *src) {\n    int i;\n    i = 0;\n    while (src[i])\n        {\n            dest[i] = src[i];\n            i++;\n        }\n    dest[i] = src[i];\n    dest[i + 1] = '\\x00';\n    return (dest);\n}\n","function_prediction":"char *ft_strcpy_name_conflict(char *dest, const char *src) {\n  int i;\n\n  i = 0;\n  while (src[i] != '\\0') {\n    dest[i] = src[i];\n    i++;\n  }\n  dest[i] = src[i];\n  dest[i + 1] = '\\0';\n  return (dest);\n}","pass":1,"source_file":"C_COMPILE/f110/main_110.c"}
{"compilable":0,"function":"static inline unsigned short str2s(const char *s, unsigned int len, int *err) {\n    unsigned short ret;\n    int i;\n    unsigned char *limit;\n    unsigned char *str;\n    str = (unsigned char *)s;\n    ret = i = 0;\n    limit = str + len;\n    for (; str < limit; str++) {\n        if ((*str <= '9') && (*str >= '0')) {\n            ret = ret * 10 + *str - '0';\n            i++;\n            if (i > 5)\n                goto error_digits;\n        } else {\n            goto error_char;\n        }\n    }\n    if (err)\n        *err = 0;\n    return ret;\n  error_digits:\n    if (err)\n        *err = 1;\n    return 0;\n  error_char:\n    if (err)\n        *err = 1;\n    return 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1858/main_1858.c"}
{"compilable":0,"function":"static inline int test_and_set_bit(long nr, volatile unsigned long *addr) {\n    do {\n        char c;\n        asm volatile (\"bts %2, %0; setc %1\" : \"+m\" (*addr), \"=qm\" (c) : \"Ir\" (nr) : \"memory\");\n        return c != 0;\n    } while (0);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f177/main_177.c"}
{"compilable":1,"function":"static unsigned int integer_to_ascii(char *destination, unsigned int source) {\n    unsigned int temp = source;\n    unsigned int length = 0;\n    if (source >= 100) {\n        *destination++ = temp / 100 + '0';\n        temp = temp % 100;\n        ++length;\n    }\n    if (source >= 10) {\n        *destination++ = temp / 10 + '0';\n        temp = temp % 10;\n        ++length;\n    }\n    *destination++ = temp + '0';\n    return length + 1;\n}\n","function_prediction":"int integer_to_ascii_name_conflict(char *out, int n) {\n  int i = 0;\n  if (n >= 100) {\n    *out++ = '0' + n / 100;\n    n %= 100;\n    i++;\n  }\n  if (n >= 10) {\n    *out++ = '0' + n / 10;\n    n %= 10;\n    i++;\n  }\n  *out++ = '0' + n;\n  i++;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f899/main_899.c"}
{"compilable":0,"function":"unsigned int and_peep2_hi(unsigned int y, unsigned int *x) {\n    *x = y & 2047;\n    return y;\n}\n","function_prediction":"uint32_t and_peep2_hi_name_conflict(uint32_t insn, struct match *match) {\n  match[0].u.reg = insn & 0x7ff;\n  return insn;\n}","pass":0,"source_file":"C_COMPILE/f460/main_460.c"}
{"compilable":0,"function":"inline _Bool SHAREMIND_MAP_KEY_COPY_long(long *const dest, const long src) {\n    return (((*dest) = src) , 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f636/main_636.c"}
{"compilable":1,"function":"static char *ft_saveitoa(int size, unsigned int n, char *nb, int neg) {\n    int j;\n    j = 0;\n    if (neg) {\n        nb[j] = '-';\n        j++;\n    }\n    while (size > 0)\n        {\n            nb[j] = (n / size) + '0';\n            n = n % size;\n            size = size / 10;\n            j++;\n        }\n    nb[j] = '\\x00';\n    return (nb);\n}\n","function_prediction":"char *ft_saveitoa_name_conflict(int n, int nb, char *str, int neg) {\n  int i;\n\n  i = 0;\n  if (neg) {\n    str[i] = '-';\n    i++;\n  }\n  while (n > 0) {\n    str[i] = (nb / n) + '0';\n    nb = nb % n;\n    n = n / 10;\n    i++;\n  }\n  str[i] = '\\0';\n  return (str);\n}","pass":0,"source_file":"C_COMPILE/f33/main_33.c"}
{"compilable":1,"function":"int Q_strlcpy(char *dst, const char *src, int size) {\n    const char *s = src;\n    while (*s)\n        {\n            if (size > 1) {\n                *dst++ = *s;\n                size--;\n            }\n            s++;\n        }\n    if (size > 0) {\n        *dst = '\\x00';\n    }\n    return s - src;\n}\n","function_prediction":"size_t Q_strlcpy_name_conflict(char *dst, const char *src, size_t siz) {\n  char *d = dst;\n  const char *s = src;\n  size_t n = siz;\n\n  while (*s != '\\0') {\n    if (n != 1) {\n      *d++ = *s++;\n      n--;\n    }\n  }\n  if (n > 0)\n    *d = '\\0';\n  return s - src;\n}","pass":0,"source_file":"C_COMPILE/f500/main_500.c"}
{"compilable":1,"function":"int read_hci_event(int fd, unsigned char *buf, int size) {\n    int remain, r;\n    int count = 0;\n    if (size <= 0)\n        return -1;\n    while (1)\n        {\n            r = read(fd, buf, 1);\n            if (r <= 0)\n                return -1;\n            if (buf[0] == 4)\n                break;\n        }\n    count++;\n    while (count < 3)\n        {\n            r = read(fd, buf + count, 3 - count);\n            if (r <= 0)\n                return -1;\n            count += r;\n        }\n    if (buf[2] < (size - 3))\n        remain = buf[2];\n    else\n        remain = size - 3;\n    while ((count - 3) < remain)\n        {\n            r = read(fd, buf + count, remain - (count - 3));\n            if (r <= 0)\n                return -1;\n            count += r;\n        }\n    return count;\n}\n","function_prediction":"int read_hci_event_name_conflict(int fd, char *buf, int len) {\n  int i, n;\n\n  if (len <= 0)\n    return -1;\n\n  do {\n    n = read(fd, buf, 1);\n    if (n <= 0)\n      return -1;\n  } while (buf[0] != 0x04);\n\n  for (i = 1; i < 3; i += n) {\n    n = read(fd, buf + i, 3 - i);\n    if (n <= 0)\n      return -1;\n  }\n\n  if (buf[2] > len - 3)\n    n = len - 3;\n  else\n    n = buf[2];\n\n  while (i - 2 <= n) {\n    n = read(fd, buf + i, n - (i - 3));\n    if (n <= 0)\n      return -1;\n    i += n;\n  }\n\n  return i;\n}","pass":1,"source_file":"C_COMPILE/f1828/main_1828.c"}
{"compilable":0,"function":"char foo(int *p) {\n    int ret = *(char *)p;\n    *p = 26;\n    return ret;\n}\n","function_prediction":"int foo_name_conflict(struct S *s) {\n  char c = s->c;\n  s->c = 26;\n  return c;\n}","pass":0,"source_file":"C_COMPILE/f141/main_141.c"}
{"compilable":1,"function":"char *outnum(char *p, int n) {\n    if (n >= 10)\n        p = outnum(p, n / 10);\n    *p++ = n % 10 + '0';\n    return p;\n}\n","function_prediction":"char *outnum_name_conflict(char *s, int n) {\n  if (n >= 10)\n    s = outnum_name_conflict(s, n / 10);\n  *s++ = n % 10 + '0';\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f208/main_208.c"}
{"compilable":1,"function":"int ismymac(const unsigned char *mac) {\n    return 1;\n}\n","function_prediction":"int ismymac_name_conflict(char *mac) { return 1; }","pass":1,"source_file":"C_COMPILE/f1424/main_1424.c"}
{"compilable":1,"function":"char add(char x, char y, int *c) {\n    int a = x - '0';\n    int b = y - '0';\n    int res = a ^ b;\n    if (*c == 1) {\n        res = *c ^ res;\n        *c = res & (*c);\n    } else {\n        *c = a & b;\n    }\n    return '0' + res;\n}\n","function_prediction":"char add_name_conflict(char a, char b, int *carry) {\n  int sum = a - '0' ^ b - '0';\n  if (*carry == 1) {\n    sum ^= *carry;\n    *carry &= sum;\n  } else {\n    *carry = (a - '0') & (b - '0');\n  }\n  return sum + '0';\n}","pass":1,"source_file":"C_COMPILE/f647/main_647.c"}
{"compilable":1,"function":"__attribute__((noinline)) int foo(unsigned long *p, unsigned long *q) {\n    int ret;\n    asm volatile (\"\" : \"=r\" (ret), \"=r\" (*p), \"=r\" (*q) : \"0\" (1), \"1\" (2), \"2\" (3));\n    return ret;\n}\n","function_prediction":"int foo_name_conflict(int *a, int *b) {\n  *a = 2;\n  *b = 3;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/f1282/main_1282.c"}
{"compilable":1,"function":"int power_two(int x, int *pow) {\n    if (x < 1) {\n        return 2;\n    } else if (x == 1) {\n        (*pow) = 0;\n        return 0;\n    } else {\n        int ret = 1;\n        (*pow) = 0;\n        double y = (double)x;\n        while (y >= 2.)\n            {\n                (*pow)++;\n                if (y == 2.) {\n                    ret = 0;\n                }\n                y /= 2.;\n            }\n        return ret;\n    }\n}\n","function_prediction":"int power_two_name_conflict(int n, int *p) {\n  double d;\n  int r;\n\n  if (n <= 0)\n    return 2;\n  if (n == 1) {\n    *p = 0;\n    return 0;\n  }\n  r = 1;\n  *p = 0;\n  d = (double)n;\n  while (d >= 2.0) {\n    d /= 2.0;\n    (*p)++;\n    if (d == 2.0)\n      r = 0;\n  }\n  return r;\n}","pass":1,"source_file":"C_COMPILE/f289/main_289.c"}
{"compilable":1,"function":"static int parseCastling(const char *line, int *len) {\n    int nrOh = 0;\n    int ix = 0;\n    int oh = line[ix];\n    if (oh == 'O' || oh == 'o' || oh == '0') {\n        do {\n            nrOh++;\n            if (line[++ix] == '-')\n                ix++;\n        } while (line[ix] == oh);\n    }\n    if (ix != nrOh && ix != 2 * nrOh - 1) {\n        nrOh = 0;\n        ix = 0;\n    }\n    *len = ix;\n    return nrOh;\n}\n","function_prediction":"int parseCastling_name_conflict(char *s, int *i) {\n  int n = 0;\n  int j = 0;\n  char c = s[0];\n\n  if (c == 'O' || c == 'o' || c == '0') {\n    do {\n      n++;\n      j++;\n      if (s[j] == '-')\n        j++;\n    } while (s[j] == c);\n  }\n\n  if (j != n && j != n * 2 - 1) {\n    n = 0;\n    j = 0;\n  }\n\n  *i = j;\n  return n;\n}","pass":0,"source_file":"C_COMPILE/f370/main_370.c"}
{"compilable":0,"function":"int srand_id_get(char *buf, int *srand_id) {\n    *srand_id = *(int *)(buf + sizeof(int) * 4);\n    return 0;\n}\n","function_prediction":"int srand_id_get_name_conflict(const void *data, uint32_t *id) {\n  const struct srand_data *d = data;\n\n  *id = d->id;\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1985/main_1985.c"}
{"compilable":1,"function":"char *osip_str_append(char *dst, const char *src) {\n    while (*src != '\\x00')\n        {\n            *dst = *src;\n            src++;\n            dst++;\n        }\n    *dst = '\\x00';\n    return dst;\n}\n","function_prediction":"char *osip_str_append_name_conflict(char *dst, const char *src) {\n  char *d = dst;\n  const char *s = src;\n  while (*s) {\n    *d = *s;\n    d++;\n    s++;\n  }\n  *d = '\\0';\n  return d;\n}","pass":1,"source_file":"C_COMPILE/f1111/main_1111.c"}
{"compilable":1,"function":"unsigned int btl_reg(unsigned int reg_in, int bitno, unsigned int *reg_out_p) {\n    unsigned char res;\n    unsigned int reg_out;\n    asm volatile (\"movl\\t%3, %%eax\\n\\tbtl\\t%2, %%eax\\n\\tmovl\\t%%eax, %1\\n\\tsetc\\t%0\" : \"=q\" (res), \"=r\" (reg_out) : \"r\" (bitno), \"r\" (reg_in) : \"cc\", \"eax\");\n    *reg_out_p = reg_out;\n    return res;\n}\n","function_prediction":"int btl_reg_name_conflict(uint32_t reg, uint32_t bit, uint32_t *val) {\n  *val = reg;\n  return (reg & (1 << bit)) != 0;\n}","pass":1,"source_file":"C_COMPILE/f405/main_405.c"}
{"compilable":1,"function":"static int acl_chk_string(const char *s, unsigned int max_len, unsigned int *out_len) {\n    unsigned int len;\n    if (!s)\n        return 1;\n    for (len = 0; len < max_len; len++)\n        if (*s++ == '\\x00') {\n            if (out_len)\n                *out_len = len;\n            return 0;\n        }\n    return 1;\n}\n","function_prediction":"int acl_chk_string_name_conflict(const char *str, unsigned int len, unsigned int *pos) {\n  unsigned int i;\n\n  if (str == NULL)\n    return 1;\n\n  for (i = 0; i < len; i++) {\n    if (str[i] == '\\0') {\n      if (pos != NULL)\n        *pos = i;\n      return 0;\n    }\n  }\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f683/main_683.c"}
{"compilable":1,"function":"char *my_strcpy2(char *destination, const char *source) {\n    *destination = *source;\n    if (*source == '\\x00')\n        return destination;\n    else\n        return my_strcpy2(destination + 1, source + 1) - 1;\n}\n","function_prediction":"char *my_strcpy2_name_conflict(char *dest, const char *src) {\n  *dest = *src;\n  if (*src == '\\0')\n    return dest;\n  return my_strcpy2_name_conflict(dest + 1, src + 1) - 1;\n}","pass":1,"source_file":"C_COMPILE/f54/main_54.c"}
{"compilable":1,"function":"int util_str_copy(char *dest, char *src, int max_count) {\n    int cnt = 0;\n    if (max_count <= 0)\n        return cnt;\n    while (*src != '\\x00')\n        {\n            *(dest++) = *(src++);\n            cnt++;\n            if (cnt >= max_count)\n                break;\n        }\n    *dest = '\\x00';\n    return cnt;\n}\n","function_prediction":"int util_str_copy_name_conflict(char *dst, const char *src, int max_len) {\n  int i;\n\n  for (i = 0; i < max_len; i++) {\n    if (*src == '\\0') {\n      break;\n    }\n    *dst++ = *src++;\n  }\n  *dst = '\\0';\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f1840/main_1840.c"}
{"compilable":1,"function":"int *fun(int *a) {\n    (*a)++;\n    return a;\n}\n","function_prediction":"int *fun_name_conflict(int *p) {\n  *p += 1;\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f1383/main_1383.c"}
{"compilable":1,"function":"static char *ft_revers(char *str) {\n    int i;\n    int e;\n    char buff;\n    i = 0;\n    e = 0;\n    while (str[e])\n        e++;\n    e--;\n    while (i < e)\n        {\n            buff = str[i];\n            str[i] = str[e];\n            str[e] = buff;\n            i++;\n            e--;\n        }\n    return (str);\n}\n","function_prediction":"char *ft_revers_name_conflict(char *str) {\n  int i;\n  int j;\n  char c;\n\n  i = 0;\n  j = 0;\n  while (str[i] != '\\0')\n    i++;\n  while (j < --i) {\n    c = str[j];\n    str[j] = str[i];\n    str[i] = c;\n    j++;\n  }\n  return (str);\n}","pass":0,"source_file":"C_COMPILE/f1694/main_1694.c"}
{"compilable":0,"function":"static int privsep_set_family(int *lport, int family) {\n    if (family > 65535)\n        return (-1);\n    *lport |= (family << 16);\n    return (0);\n}\n","function_prediction":"int privsep_set_family_name_conflict(struct privsep_client *client, int family) {\n\n  if (family > 0xffff)\n    return (-1);\n  client->client_family = (client->client_family & 0xffff) | (family << 16);\n  return (0);\n}","pass":0,"source_file":"C_COMPILE/f451/main_451.c"}
{"compilable":1,"function":"static int Xstrncpy(XML_Char *a, const XML_Char *b, int len) {\n    int x;\n    for (x = 0; b[x] != 0 && x < len; x++) {\n        a[x] = b[x];\n    }\n    a[x] = 0;\n    return x;\n}\n","function_prediction":"int Xstrncpy_name_conflict(char *dst, const char *src, int maxlen) {\n  int i;\n\n  for (i = 0; src[i] && i < maxlen; i++)\n    dst[i] = src[i];\n  dst[i] = 0;\n  return i;\n}","pass":1,"source_file":"C_COMPILE/f1734/main_1734.c"}
{"compilable":0,"function":"static unsigned long hashval(const unsigned char hash[16], const size_t nbits) {\n    unsigned long u;\n    size_t i;\n    for (i = 0 , u = 0; i < 4; ++i)\n        u |= ((unsigned long)hash[i]) << (i * 8);\n    return u & ((1 << nbits) - 1);\n}\n","function_prediction":"uint32_t hashval_name_conflict(const uint8_t *key, uint8_t len) {\n  uint32_t hash = 0;\n  for (uint8_t i = 0; i < 4; i++)\n    hash |= (uint32_t)key[i] << (i * 8);\n  return hash & ((1 << len) - 1);\n}","pass":0,"source_file":"C_COMPILE/f343/main_343.c"}
{"compilable":0,"function":"int dlpi_get_physaddr(int fd, unsigned char *hwaddr, int length) {\n    return -1;\n}\n","function_prediction":"unsigned long dlpi_get_physaddr_name_conflict(void) { return -1; }","pass":0,"source_file":"C_COMPILE/f1937/main_1937.c"}
{"compilable":0,"function":"int SDL_imageFilterMultMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterMultMMX_name_conflict(void) {\n# 108 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/g-Fulcrum/Fulcrum-SDL/refs/heads/master/SDL_imageFilter.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f924/main_924.c"}
{"compilable":1,"function":"int premcce_replace(char *sto, char *pattern) {\n    int i;\n    for (i = 0; i < 14; i++) {\n        if (pattern[i] == '*')\n            continue;\n        else\n            sto[i] = pattern[i];\n    }\n    return 0;\n}\n","function_prediction":"int premcce_replace_name_conflict(char *dst, const char *src) {\n  int i;\n\n  for (i = 0; i < 14; i++) {\n    if (src[i] != '*')\n      dst[i] = src[i];\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1714/main_1714.c"}
{"compilable":1,"function":"static const char *unquote_in_place(char *s, const char *e) {\n    const char *r = s;\n    while (r < e)\n        {\n            if (*r == '\\\\' && r + 1 < e)\n                r++;\n            *s++ = *r++;\n        }\n    *s = '\\x00';\n    return s;\n}\n","function_prediction":"char *unquote_in_place_name_conflict(char *dst, const char *src) {\n  char *dst_start = dst;\n  const char *src_start = src;\n\n  while (src < src_start + strlen(src_start)) {\n    if (*src == '\\\\' && src + 1 < src_start + strlen(src_start)) {\n      src++;\n    }\n    *dst++ = *src++;\n  }\n  *dst = '\\0';\n\n  return dst_start;\n}","pass":0,"source_file":"C_COMPILE/f200/main_200.c"}
{"compilable":1,"function":"int update_keys(unsigned long *pkeys, const unsigned long *pcrc_32_tab, int c) {\n    (*(pkeys + 0)) = ((*(pcrc_32_tab + (((int)((*(pkeys + 0))) ^ (c)) & 255))) ^ (((*(pkeys + 0))) >> 8));\n    (*(pkeys + 1)) += (*(pkeys + 0)) & 255;\n    (*(pkeys + 1)) = (*(pkeys + 1)) * 134775813L + 1;\n    {\n        register int keyshift = (int)((*(pkeys + 1)) >> 24);\n        (*(pkeys + 2)) = ((*(pcrc_32_tab + (((int)((*(pkeys + 2))) ^ (keyshift)) & 255))) ^ (((*(pkeys + 2))) >> 8));\n    }\n    return c;\n}\n","function_prediction":"uint8_t update_keys_name_conflict(uint32_t *keys, uint8_t *sbox, uint8_t byte) {\n  keys[0] = sbox[(keys[0] ^ byte) & 0xff] ^ (keys[0] >> 8);\n  keys[1] += (keys[0] & 0xff);\n  keys[1] = (keys[1] << 1) + (keys[1] << 6) + (keys[1] << 16) + (keys[1] << 24);\n  keys[2] = sbox[(keys[2] ^ (keys[1] >> 24)) & 0xff] ^ (keys[2] >> 8);\n  return byte;\n}","pass":0,"source_file":"C_COMPILE/f1133/main_1133.c"}
{"compilable":1,"function":"static char *CG_FetchHitPartName(int *hitLocation) {\n    if (*hitLocation & 1) {\n        *hitLocation &= ~1;\n        return \"^1head\";\n    } else if (*hitLocation & 2) {\n        *hitLocation &= ~2;\n        return \"^4chest\";\n    } else if (*hitLocation & 4) {\n        *hitLocation &= ~4;\n        return \"^4back\";\n    } else if (*hitLocation & 8) {\n        *hitLocation &= ~8;\n        return \"^4left arm\";\n    } else if (*hitLocation & 16) {\n        *hitLocation &= ~16;\n        return \"^4right arm\";\n    } else if (*hitLocation & 32) {\n        *hitLocation &= ~32;\n        return \"^2leg\";\n    } else {\n        *hitLocation = 0;\n        return \"error!\";\n    }\n}\n","function_prediction":"const char *CG_FetchHitPartName_name_conflict(int *part) {\n  if (*part & 1) {\n    *part &= ~1;\n    return \"^1head\";\n  }\n  if (*part & 2) {\n    *part &= ~2;\n    return \"^4chest\";\n  }\n  if (*part & 4) {\n    *part &= ~4;\n    return \"^4back\";\n  }\n  if (*part & 8) {\n    *part &= ~8;\n    return \"^4left arm\";\n  }\n  if (*part & 16) {\n    *part &= ~16;\n    return \"^4right arm\";\n  }\n  if (*part & 32) {\n    *part &= ~32;\n    return \"^2leg\";\n  }\n  *part = 0;\n  return \"error!\";\n}","pass":1,"source_file":"C_COMPILE/f833/main_833.c"}
{"compilable":1,"function":"int imcomp_nullvaluesi2(short *idata, long tilelen, short nullflagval, short nullval, int *status) {\n    long ii;\n    for (ii = 0; ii < tilelen; ii++) {\n        if (idata[ii] == nullflagval)\n            idata[ii] = nullval;\n    }\n    return (*status);\n}\n","function_prediction":"int imcomp_nullvaluesi2_name_conflict(short *data, long ntodo, short nullval, short newval,\n                        int *status)\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/joezuntz/cmbview/refs/heads/master/src/imcomp.c\"\n{\n  long ii;\n\n  for (ii = 0; ii < ntodo; ii++)\n    if (data[ii] == nullval)\n      data[ii] = newval;\n\n  return (*status);\n}","pass":1,"source_file":"C_COMPILE/f728/main_728.c"}
{"compilable":0,"function":"static inline char *stpcpy_x86_64_fast(char *restrict s1, const char *restrict s2) {\n    int rsrc, rdst;\n    asm volatile (\"1: \\tlodsb\\n\\t;stosb\\n\\t;testb %%al,%%al\\n\\t;jne 1b;\" : \"=&S\" (rsrc), \"=&D\" (rdst) : \"0\" (s2), \"1\" (s1));\n    asm volatile (\"\\t movq %%rdi,%0\" : \"=r\" (s1));\n    return --s1;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1260/main_1260.c"}
{"compilable":0,"function":"long ff_atomic_inc_long(volatile long *val) {\n    return __sync_add_and_fetch_8(val, 1);\n}\n","function_prediction":"long ff_atomic_inc_long_name_conflict(ff_atomic_long *counter) {\n  long value;\n  LOCK();\n  value = (*counter)++;\n  UNLOCK();\n  return value + 1;\n}","pass":0,"source_file":"C_COMPILE/f518/main_518.c"}
{"compilable":1,"function":"static int seek_and_read(int chan, unsigned char *buf, int offset, int nbytes) {\n    if (offset < 0)\n        return (-1);\n    lseek(chan, offset, 0);\n    return (read(chan, buf, nbytes));\n}\n","function_prediction":"int seek_and_read_name_conflict(int fd, void *buf, int offset, int size) {\n  if (offset < 0)\n    return -1;\n\n  lseek(fd, offset, 0);\n  return read(fd, buf, size);\n}","pass":1,"source_file":"C_COMPILE/f176/main_176.c"}
{"compilable":1,"function":"int salta_espacio(char *buf, int size, int *index, int *old_index) {\n    *old_index = *index;\n    while ((*index < size) && ((buf[*index] == ' ') || (buf[*index] == '\\n')))\n        {\n            (*index)++;\n        }\n    if (*index == size)\n        return -1;\n    else\n        return 0;\n}\n","function_prediction":"int salta_espacio_name_conflict(char *linea, int tam, int *pos, int *pos_anterior) {\n  *pos_anterior = *pos;\n  while (*pos < tam && (linea[*pos] == ' ' || linea[*pos] == '\\n'))\n    (*pos)++;\n  if (*pos == tam)\n    return -1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1068/main_1068.c"}
{"compilable":1,"function":"char *mfm_write_single_item(char *dest, char *item) {\n    *dest++ = '\"';\n    for (char *c = item; *c; c++) {\n        switch (*c) {\n          case '\\\\':\n            *dest++ = '\\\\';\n            *dest++ = '\\\\';\n            break;\n          case '\"':\n            *dest++ = '\\\\';\n            *dest++ = '\"';\n            break;\n          default:\n            *dest++ = *c;\n            break;\n        }\n    }\n    *dest++ = '\"';\n    *dest++ = ' ';\n    return dest;\n}\n","function_prediction":"char *mfm_write_single_item_name_conflict(char *buf, const char *str) {\n  char *p = buf;\n  const char *s;\n\n  *p++ = '\"';\n  for (s = str; *s; s++) {\n    if (*s == '\"') {\n      *p++ = '\\\\';\n      *p++ = '\"';\n    } else if (*s == '\\\\') {\n      *p++ = '\\\\';\n      *p++ = '\\\\';\n    } else {\n      *p++ = *s;\n    }\n  }\n  *p++ = '\"';\n  *p++ = ' ';\n  return p;\n}","pass":0,"source_file":"C_COMPILE/f1364/main_1364.c"}
{"compilable":0,"function":"static inline char *utf8_code_convert_code(unsigned int code, char *pos) {\n    switch (code) {\n      case 65536 ... 131071:\n        *pos = 240 + ((code >> 18) & 7);\n        pos++;\n        *pos = 128 + ((code >> 12) & 63);\n        pos++;\n        *pos = 128 + ((code >> 6) & 63);\n        pos++;\n        *pos = 128 + ((code >> 0) & 63);\n        pos++;\n        break;\n      case 2048 ... 65535:\n        *pos = 224 + ((code >> 12) & 15);\n        pos++;\n        *pos = 128 + ((code >> 6) & 63);\n        pos++;\n        *pos = 128 + ((code >> 0) & 63) , pos++;\n        break;\n      case 128 ... 2047:\n        *pos = 192 | ((code >> 6) & 31);\n        pos++;\n        *pos = 128 | ((code >> 0) & 63);\n        pos++;\n        break;\n      case 0 ... 127:\n        *pos = 0 | ((code >> 0) & 127);\n        pos++;\n        break;\n    }\n    return pos;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f2107/main_2107.c"}
{"compilable":1,"function":"int poly1305_tagcmp(const unsigned char tag1[16], const unsigned char tag2[16]) {\n    unsigned int d = 0;\n    d |= tag1[0] ^ tag2[0];\n    d |= tag1[1] ^ tag2[1];\n    d |= tag1[2] ^ tag2[2];\n    d |= tag1[3] ^ tag2[3];\n    d |= tag1[4] ^ tag2[4];\n    d |= tag1[5] ^ tag2[5];\n    d |= tag1[6] ^ tag2[6];\n    d |= tag1[7] ^ tag2[7];\n    d |= tag1[8] ^ tag2[8];\n    d |= tag1[9] ^ tag2[9];\n    d |= tag1[10] ^ tag2[10];\n    d |= tag1[11] ^ tag2[11];\n    d |= tag1[12] ^ tag2[12];\n    d |= tag1[13] ^ tag2[13];\n    d |= tag1[14] ^ tag2[14];\n    d |= tag1[15] ^ tag2[15];\n    return d;\n}\n","function_prediction":"int poly1305_tagcmp_name_conflict(const unsigned char *a, const unsigned char *b) {\n  int i;\n  unsigned int d = 0;\n\n  for (i = 0; i < 16; i++)\n    d |= a[i] ^ b[i];\n\n  return d;\n}","pass":0,"source_file":"C_COMPILE/f1750/main_1750.c"}
{"compilable":0,"function":"short ipv4_get_broadcast(unsigned long ip, unsigned long mask, unsigned long *broadcast) {\n    *broadcast = (ip & mask) | (mask ^ 4294967295U);\n    return 0;\n}\n","function_prediction":"int ipv4_get_broadcast_name_conflict(ipv4_addr_t addr, ipv4_addr_t mask,\n                       ipv4_addr_t *broadcast) {\n  *broadcast = addr | (mask ^ 0xffffffff);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1431/main_1431.c"}
{"compilable":0,"function":"__attribute__((always_inline)) static inline long _InterlockedXor(volatile long *const value, const long mask) {\n    return __sync_fetch_and_xor_8(value, mask);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1221/main_1221.c"}
{"compilable":0,"function":"unsigned char CC1101TimeoutEvent(unsigned int *tick) {\n    if (*tick < 2000) {\n        (*tick)++;\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"bool CC1101TimeoutEvent_name_conflict(CC1101_t *cc1101) {\n  if (cc1101->timeoutCounter < 2000) {\n    cc1101->timeoutCounter++;\n    return false;\n  } else {\n    return true;\n  }\n}","pass":0,"source_file":"C_COMPILE/f1284/main_1284.c"}
{"compilable":0,"function":"int nand_secure_storage_write(int item, unsigned char *buf, unsigned int len) {\n    return 0;\n}\n","function_prediction":"int nand_secure_storage_write_name_conflict(struct nand_chip *chip, int page, int page_offset,\n                              void *buf, int len) {\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1711/main_1711.c"}
{"compilable":1,"function":"int adfs_readname(char *buf, char *ptr, int maxlen) {\n    int size = 0;\n    while (*ptr >= ' ' && maxlen--)\n        {\n            switch (*ptr) {\n              case '/':\n                *buf++ = '.';\n                break;\n              default:\n                *buf++ = *ptr;\n                break;\n            }\n            ptr++;\n            size++;\n        }\n    *buf = '\\x00';\n    return size;\n}\n","function_prediction":"int adfs_readname_name_conflict(char *dst, char *src, int maxlen) {\n  int len = 0;\n\n  while (*src > ' ' && maxlen) {\n    if (*src == '/')\n      *dst = '.';\n    else\n      *dst = *src;\n    dst++;\n    src++;\n    len++;\n    maxlen--;\n  }\n  *dst = '\\0';\n  return len;\n}","pass":0,"source_file":"C_COMPILE/f2090/main_2090.c"}
{"compilable":1,"function":"static int find_overlaps(int w, int h, int placement, int *set) {\n    int x, y, n;\n    n = 0;\n    x = placement / 2;\n    y = x / w;\n    x %= w;\n    if (placement & 1) {\n        if (x > 0)\n            set[n++] = placement - 2;\n        if (y > 0)\n            set[n++] = placement - 2 * w - 1;\n        if (y + 1 < h)\n            set[n++] = placement - 1;\n        if (x + 2 < w)\n            set[n++] = placement + 2;\n        if (y > 0)\n            set[n++] = placement - 2 * w + 2 - 1;\n        if (y + 1 < h)\n            set[n++] = placement + 2 - 1;\n    } else {\n        if (y > 0)\n            set[n++] = placement - 2 * w;\n        if (x > 0)\n            set[n++] = placement - 2 + 1;\n        if (x + 1 < w)\n            set[n++] = placement + 1;\n        if (y + 2 < h)\n            set[n++] = placement + 2 * w;\n        if (x > 0)\n            set[n++] = placement - 2 + 2 * w + 1;\n        if (x + 1 < w)\n            set[n++] = placement + 2 * w + 1;\n    }\n    return n;\n}\n","function_prediction":"int find_overlaps_name_conflict(int nx, int ny, int i, int *overlaps) {\n  int nx2 = nx / 2;\n  int ny2 = ny / 2;\n  int nx2_mod = nx % 2;\n  int ny2_mod = ny % 2;\n  int n = 0;\n\n  if (nx2_mod) {\n    if (ny2) {\n      overlaps[n++] = i - 2;\n    }\n    if (ny2 < ny) {\n      overlaps[n++] = i - 1;\n    }\n    if (ny2 + 2 < ny) {\n      overlaps[n++] = i + 2;\n    }\n    if (ny2) {\n      overlaps[n++] = i - 2 * nx + 1;\n    }\n    if (ny2 + 1 < ny) {\n      overlaps[n++] = i - nx + 1;\n    }\n  } else {\n    if (ny2) {\n      overlaps[n++] = i - 2 * nx;\n    }\n    if (ny2 < ny) {\n      overlaps[n++] = i - nx - 1;\n    }\n    if (ny2 + 1 < ny) {\n      overlaps[n++] = i - nx + 1;\n    }\n    if (ny2 + 2 < ny) {\n      overlaps[n++] = i + 2 * nx;\n    }\n    if (ny2) {\n      overlaps[n++] = i - 2 * nx + 1;\n    }\n    if (ny2 + 1 < ny) {\n      overlaps[n++] = i - nx + 1;\n    }\n  }\n\n  return n;\n}","pass":0,"source_file":"C_COMPILE/f736/main_736.c"}
{"compilable":0,"function":"static inline int atomicExchange(volatile int *var, int nv) {\n    int ov;\n    asm volatile (\"xchgl %0, %1\" : \"=r\" (ov), \"=m\" (*var) : \"0\" (nv), \"m\" (*var));\n    return ov;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1690/main_1690.c"}
{"compilable":0,"function":"static inline unsigned long atomic_add(volatile unsigned long *ptr, long amount) {\n    return __sync_fetch_and_add_8(ptr, amount);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f771/main_771.c"}
{"compilable":0,"function":"static inline long atomic_add(volatile long *ptr, long value) {\n    long old = *ptr;\n    *ptr += value;\n    return old;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1813/main_1813.c"}
{"compilable":0,"function":"int file_packet_EOF_PACKET(unsigned char *data, int dataLen) {\n}\n","function_prediction":"void file_packet_EOF_PACKET_name_conflict(FILE_PACKET *packet) {}","pass":0,"source_file":"C_COMPILE/f982/main_982.c"}
{"compilable":0,"function":"int RGB8toI420(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"int RGB8toI420_name_conflict(const uint8_t *src_rgb, int src_stride_rgb, uint8_t *dst_y,\n               int dst_stride_y, uint8_t *dst_u, int dst_stride_u,\n               uint8_t *dst_v, int dst_stride_v, int width, int height) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f156/main_156.c"}
{"compilable":1,"function":"static int ones(int *v) {\n    int ret = 0;\n    switch (*v) {\n      case 9:\n        ret = 4;\n        break;\n      case 8:\n        ret = 5;\n        break;\n      case 7:\n        ret = 5;\n        break;\n      case 6:\n        ret = 3;\n        break;\n      case 5:\n        ret = 4;\n        break;\n      case 4:\n        ret = 4;\n        break;\n      case 3:\n        ret = 5;\n        break;\n      case 2:\n        ret = 3;\n        break;\n      case 1:\n        ret = 3;\n        break;\n      case 0:\n        return 0;\n    }\n    *v = 0;\n    return ret;\n}\n","function_prediction":"int ones_name_conflict(int *n) {\n  int ret = 0;\n  switch (*n) {\n  case 0:\n    ret = 0;\n    break;\n  case 1:\n    ret = 3;\n    break;\n  case 2:\n    ret = 3;\n    break;\n  case 3:\n    ret = 5;\n    break;\n  case 4:\n    ret = 4;\n    break;\n  case 5:\n    ret = 4;\n    break;\n  case 6:\n    ret = 3;\n    break;\n  case 7:\n    ret = 5;\n    break;\n  case 8:\n    ret = 5;\n    break;\n  case 9:\n    ret = 4;\n    break;\n  }\n  *n = 0;\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/f1556/main_1556.c"}
{"compilable":1,"function":"int FMOVS(unsigned long *rd, unsigned long *rs2) {\n    rd[0] = rs2[0];\n    return 0;\n}\n","function_prediction":"int FMOVS_name_conflict(uint32_t *dest, uint32_t *src) {\n  *dest = *src;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f902/main_902.c"}
{"compilable":0,"function":"int MPI_Cart_get(int comm, int maxdims, int *dims, int *periods, int *coords) {\n    dims[0] = dims[1] = dims[2] = 1;\n    periods[0] = periods[1] = periods[2] = 1;\n    coords[0] = coords[1] = coords[2] = 0;\n    return 0;\n}\n","function_prediction":"int MPI_Cart_get_name_conflict(MPI_Comm comm, int maxdims, int dims[], int periods[],\n                 int coords[]) {\n  dims[0] = dims[1] = dims[2] = 1;\n  periods[0] = periods[1] = periods[2] = 1;\n  coords[0] = coords[1] = coords[2] = 0;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1911/main_1911.c"}
{"compilable":1,"function":"char *usize_as_string(size_t number, char ibuf[65], size_t *psize) {\n    char *p, *e;\n    size_t quotient;\n    e = p = (ibuf + 65 - 1);\n    *p = '\\x00';\n    do {\n        quotient = number;\n        number /= 10;\n        *--p = (char)(quotient - (((number) << 1) + ((number) << 3))) + '0';\n    } while (number);\n    *psize = (size_t)(e - p);\n    return p;\n}\n","function_prediction":"char *usize_as_string_name_conflict(size_t value, char *buffer, size_t *len) {\n  char *p = buffer + 64;\n  *p = '\\0';\n  do {\n    *--p = '0' + (value % 10);\n    value /= 10;\n  } while (value);\n  *len = p - buffer;\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f1936/main_1936.c"}
{"compilable":1,"function":"char *strconv_int_dec(int n, char *string) {\n    if (n == 0) {\n        string[0] = '0';\n        string[1] = '\\x00';\n    } else {\n        int i;\n        int cpt;\n        int start = 0;\n        if (n < 0) {\n            start = 1;\n            string[0] = '-';\n            n *= -1;\n        }\n        for (i = 1 , cpt = 1; n / i >= 10; i *= 10 , cpt++)\n            ;\n        for (cpt = start; i; cpt++ , i /= 10)\n            string[cpt] = (n / i) % 10 + '0';\n        string[cpt] = '\\x00';\n    }\n    return string;\n}\n","function_prediction":"char *strconv_int_dec_name_conflict(int value, char *buf) {\n  int i, j, k, sign;\n\n  if (value == 0) {\n    buf[0] = '0';\n    buf[1] = '\\0';\n    return buf;\n  }\n\n  if (value < 0) {\n    buf[0] = '-';\n    sign = 1;\n    value = -value;\n  } else {\n    sign = 0;\n  }\n\n  for (i = 1; value / i >= 10; i *= 10)\n    ;\n\n  j = sign;\n  for (k = i; k != 0; k /= 10) {\n    buf[j++] = '0' + value / k % 10;\n  }\n  buf[j] = '\\0';\n\n  return buf;\n}","pass":1,"source_file":"C_COMPILE/f548/main_548.c"}
{"compilable":0,"function":"int RGB8toRGB555(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"uint16_t RGB8toRGB555_name_conflict(uint8_t r, uint8_t g, uint8_t b) { return 0xFFFF; }","pass":0,"source_file":"C_COMPILE/f1922/main_1922.c"}
{"compilable":1,"function":"char *remove_duplicates(char *str) {\n    int bin_hash[256] = {0};\n    int input_index = 0;\n    int result_index = 0;\n    char temp;\n    while (*(str + input_index))\n        {\n            temp = *(str + input_index);\n            if (bin_hash[temp] == 0) {\n                bin_hash[temp] = 1;\n                *(str + result_index) = *(str + input_index);\n                result_index++;\n            }\n            input_index++;\n        }\n    *(str + result_index) = '\\x00';\n    return str;\n}\n","function_prediction":"char *remove_duplicates_name_conflict(char *str) {\n  int i, j;\n  int hash[256] = {0};\n\n  for (i = 0, j = 0; str[i] != '\\0'; i++) {\n    char c = str[i];\n    if (hash[c] == 0) {\n      hash[c] = 1;\n      str[j++] = str[i];\n    }\n  }\n  str[j] = '\\0';\n  return str;\n}","pass":0,"source_file":"C_COMPILE/f1230/main_1230.c"}
{"compilable":1,"function":"int read_line(int fd, char *buf, int maxlen) {\n    int i, n;\n    char ch;\n    for (i = 0; i < maxlen;) {\n        n = read(fd, &ch, 1);\n        if (n == 1) {\n            buf[i++] = ch;\n            if (ch == '\\n')\n                break;\n        } else if (n < 0)\n            return (-1);\n        else\n            break;\n    }\n    buf[i] = '\\x00';\n    return (i);\n}\n","function_prediction":"int read_line_name_conflict(int fd, char *buf, int maxlen) {\n  int n, rc;\n  char c;\n\n  for (n = 0; n < maxlen; n++) {\n    if ((rc = read(fd, &c, 1)) == 1) {\n      buf[n] = c;\n      if (c == '\\n')\n        break;\n    } else if (rc < 0) {\n      return -1;\n    } else {\n      break;\n    }\n  }\n  buf[n] = '\\0';\n  return n;\n}","pass":1,"source_file":"C_COMPILE/f1152/main_1152.c"}
{"compilable":0,"function":"static inline int test_and_clear_bit(unsigned int nr, unsigned long *bitmap) {\n    unsigned long offset = nr / (sizeof(unsigned long) * 8);\n    unsigned long bit = nr & ((sizeof(unsigned long) * 8) - 1);\n    unsigned long old = bitmap[offset];\n    unsigned long mask = 1UL << bit;\n    bitmap[offset] = old & ~mask;\n    return (old & mask) != 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1300/main_1300.c"}
{"compilable":0,"function":"char *strcpy2(char *dst, const char *src) {\n    char *dst_save = dst;\n    if (dst == '\\x00' || src == '\\x00')\n        return;\n    while ((*dst++ = *src++) != '\\x00')\n        ;\n    return dst_save;\n}\n","function_prediction":"char *strcpy2_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  if (d == NULL || s == NULL)\n    return dest;\n\n  while ((*d++ = *s++) != '\\0')\n    ;\n\n  return dest;\n}","pass":0,"source_file":"C_COMPILE/f893/main_893.c"}
{"compilable":0,"function":"static inline int Cilk_xchg(volatile int *ptr, int x) {\n    asm (\"xchgl %0,%1\" : \"=r\" (x) : \"m\" (*(ptr)), \"0\" (x) : \"memory\");\n    return x;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f810/main_810.c"}
{"compilable":0,"function":"static inline sig_atomic_t atomic_decsa(sig_atomic_t *var) {\n    return __sync_fetch_and_sub_4(var, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f625/main_625.c"}
{"compilable":1,"function":"char *unix_normalize(char *ans, char *name, char *ext) {\n    char *a;\n    int j;\n    for (a = ans , j = 0; (j < 8) && (name[j] > ' '); ++j , ++a)\n        *a = name[j];\n    if (*ext > ' ') {\n        *a++ = '.';\n        for (j = 0; j < 3 && ext[j] > ' '; ++j , ++a)\n            *a = ext[j];\n    }\n    *a++ = '\\x00';\n    return ans;\n}\n","function_prediction":"char *unix_normalize_name_conflict(char *dst, const char *name, const char *ext) {\n  char *d = dst;\n  int i;\n\n  for (i = 0; i < 8 && name[i] > ' '; i++)\n    *d++ = name[i];\n  if (ext[0] > ' ') {\n    *d++ = '.';\n    for (i = 0; i < 3 && ext[i] > ' '; i++)\n      *d++ = ext[i];\n  }\n  *d = '\\0';\n  return dst;\n}","pass":1,"source_file":"C_COMPILE/f1652/main_1652.c"}
{"compilable":1,"function":"int dquote_check(char *str, int *i) {\n    int count;\n    count = 1;\n    ++*i;\n    while (str[*i] != '\"' && str[*i])\n        {\n            if (str[*i] == '\\\\')\n                ++*i;\n            ++*i;\n        }\n    if (str[*i] == '\"')\n        count = 0;\n    return (count);\n}\n","function_prediction":"int dquote_check_name_conflict(char *str, int *i) {\n  (*i)++;\n  while (str[*i] != '\\\"' && str[*i] != '\\0') {\n    if (str[*i] == '\\\\')\n      (*i)++;\n    (*i)++;\n  }\n  if (str[*i] == '\\\"')\n    return (0);\n  return (1);\n}","pass":1,"source_file":"C_COMPILE/f1741/main_1741.c"}
{"compilable":1,"function":"int comp(int *arg1, unsigned int *arg2, int length1, int length2) {\n    int i, j;\n    for (i = 0; i < length1; i++) {\n        int icur = arg1[i];\n        for (j = 0; j < length2; j++) {\n            int jcur = arg2[j];\n            if (jcur == icur) {\n                arg2[j] = 0;\n            }\n        }\n    }\n    for (i = 0; i < length2; i++) {\n        if (arg2[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n","function_prediction":"int comp_name_conflict(int *a, int *b, int n, int m) {\n  int i, j;\n  for (i = 0; i < n; i++)\n    for (j = 0; j < m; j++)\n      if (a[i] == b[j])\n        b[j] = 0;\n  for (i = 0; i < m; i++)\n    if (b[i] != 0)\n      return 0;\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f782/main_782.c"}
{"compilable":0,"function":"__attribute__((always_inline)) static inline char _InterlockedAnd8(volatile char *const value, const char mask) {\n    return __sync_fetch_and_and_1(value, mask);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f949/main_949.c"}
{"compilable":0,"function":"char *translate_ore_emu(unsigned char *buf, unsigned char *sunchanged, int *launchp) {\n    return \"\";\n}\n","function_prediction":"const char *translate_ore_emu_name_conflict(uint32_t opcode) {\n  switch (opcode) {\n  case 0x00000000:\n    return \"or\";\n  case 0x00000001:\n    return \"ore\";\n  case 0x00000002:\n    return \"orh\";\n  case 0x00000003:\n    return \"orhe\";\n  case 0x00000004:\n    return \"orw\";\n  case 0x00000005:\n    return \"orwe\";\n  case 0x00000006:\n    return \"orx\";\n  case 0x00000007:\n    return \"orxe\";\n  default:\n    return \"inv\";\n  }\n}","pass":0,"source_file":"C_COMPILE/f368/main_368.c"}
{"compilable":1,"function":"char *hugo_strcpy(char *s, const char *t) {\n    char *r = s;\n    while ((*s++ = *t++) != 0)\n        ;\n    return r;\n}\n","function_prediction":"char *hugo_strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f171/main_171.c"}
{"compilable":1,"function":"bool plaza_scroll_offset(int boxS, int contentS, int *offset, int delta) {\n    int value;\n    int maxoffset;\n    int orig;\n    if (contentS <= boxS)\n        value = 0;\n    else {\n        maxoffset = contentS - boxS;\n        if (*offset + delta < 0)\n            value = 0;\n        else if (*offset + delta >= maxoffset)\n            value = maxoffset;\n        else\n            value = *offset + delta;\n    }\n    orig = *offset;\n    *offset = value;\n    if (orig != value)\n        return 1;\n    else\n        return 0;\n}\n","function_prediction":"int plaza_scroll_offset_name_conflict(int old_offset, int new_offset, int *offset,\n                        int max_offset) {\n  int delta;\n\n  if (new_offset > old_offset) {\n    delta = new_offset - old_offset;\n    if (*offset < 0)\n      delta = 0;\n    else if (delta > *offset)\n      delta = *offset;\n  } else\n    delta = 0;\n\n  if (*offset == delta)\n    return 0;\n\n  *offset = delta;\n  return 1;\n}","pass":0,"source_file":"C_COMPILE/f1430/main_1430.c"}
{"compilable":1,"function":"static int get_delim(char *dest, const char *p) {\n    if (p[0] == '\\x00' || p[1] == '\\x00') {\n        dest[0] = '\\x00';\n        return 0;\n    }\n    dest[0] = *(p + 1);\n    if (p[2] == '|' && p[3] != '\\x00') {\n        dest[1] = *(p + 3);\n        return 1;\n    }\n    return 0;\n}\n","function_prediction":"int get_delim_name_conflict(char *delim, char *str) {\n  if (str[0] == '\\0' || str[1] == '\\0') {\n    delim[0] = '\\0';\n    return 0;\n  }\n  delim[0] = str[1];\n  if (str[2] != '|' || str[3] == '\\0')\n    return 0;\n  delim[1] = str[3];\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f1254/main_1254.c"}
{"compilable":0,"function":"int nand_secure_storage_read(int item, unsigned char *buf, unsigned int len) {\n    return 0;\n}\n","function_prediction":"int nand_secure_storage_read_name_conflict(struct nand_chip *chip, int page, int offset,\n                             void *buf, int len) {\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f522/main_522.c"}
{"compilable":1,"function":"char *AppendNumber(char *target, int num) {\n    int n = 0, i = 0;\n    do {\n        target[n++] = (num % 10) + '0';\n        num /= 10;\n    } while (num);\n    target[n] = 0;\n    while ((n - 1) > i)\n        {\n            char x = target[--n];\n            target[n] = target[i];\n            target[i++] = x;\n        }\n    return target + i + n;\n}\n","function_prediction":"char *AppendNumber_name_conflict(char *str, int num) {\n  int i = 0, j = 0;\n  char temp;\n\n  do {\n    str[i++] = num % 10 + '0';\n    num /= 10;\n  } while (num);\n\n  str[i] = '\\0';\n\n  while (j < i - 1) {\n    temp = str[i - 1];\n    str[i - 1] = str[j];\n    str[j++] = temp;\n  }\n\n  return str + j + i;\n}","pass":0,"source_file":"C_COMPILE/f1378/main_1378.c"}
{"compilable":1,"function":"int String_Copy(char *dst, char *src) {\n    if (dst == ((void *)0) || src == ((void *)0))\n        return 0;\n    while (*src != '\\x00')\n        *dst++ = *src++;\n    *dst = '\\x00';\n    return 1;\n}\n","function_prediction":"int String_Copy_name_conflict(char *dest, const char *src) {\n  if (dest == NULL || src == NULL)\n    return 0;\n\n  while (*src != '\\0')\n    *dest++ = *src++;\n\n  *dest = '\\0';\n\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f1704/main_1704.c"}
{"compilable":1,"function":"int filter_string(char *string, char filters_array[]) {\n    char *result = string;\n    char *end = string;\n    while (*end)\n        {\n            char *pos;\n            for (pos = filters_array; *pos && (*pos != *end); pos++)\n                ;\n            if (!*pos) {\n                *result++ = *end;\n            }\n            end++;\n        }\n    *result = '\\x00';\n    return result - string;\n}\n","function_prediction":"size_t filter_string_name_conflict(char *dst, const char *src) {\n  char *dst_start = dst;\n  const char *src_start = src;\n\n  while (*src) {\n    src = src_start;\n    while (*src && *src != *dst)\n      src++;\n    if (*src)\n      dst++;\n    else\n      *dst++ = *src_start++;\n  }\n  *dst = '\\0';\n\n  return dst - dst_start;\n}","pass":0,"source_file":"C_COMPILE/f1021/main_1021.c"}
{"compilable":0,"function":"int uudecode(const char *str, unsigned char *data, int max) {\n    int num = 0;\n    int i, n;\n    unsigned int val;\n    if (*str == '\\x00') {\n        return 0;\n    }\n    num = *str++ - 32;\n    if (num < 1 || num > 45) {\n        return 0;\n    }\n    n = (num + 2) / 3;\n    for (i = 0; i < n; i++) {\n        if (str[0] < 32 || str[0] > 96) {\n            return 0;\n        }\n        if (str[1] < 32 || str[1] > 96) {\n            return 0;\n        }\n        if (str[2] < 32 || str[2] > 96) {\n            return 0;\n        }\n        if (str[3] < 32 || str[3] > 96) {\n            return 0;\n        }\n        val = (((str[0] - 32) & 63) << 18) | (((str[1] - 32) & 63) << 12) | (((str[2] - 32) & 63) << 6) | (((str[3] - 32) & 63) << 0);\n        *data++ = (val >> 16) & 255;\n        *data++ = (val >> 8) & 255;\n        *data++ = (val >> 0) & 255;\n        str += 4;\n    }\n    return num;\n}\n","function_prediction":"int uudecode_name_conflict(char *in, char *out) {\n  int i, j, k, l;\n  char *p;\n  unsigned char *q;\n\n  if (*in == '\\0')\n    return 0;\n  p = in + 1;\n  l = *p++ - ' ';\n  if (l < 1 || l > 45)\n    return 0;\n  q = (unsigned char *)out;\n  for (i = 0; i < (l - 3) / 3; i++) {\n    if (*p < ' ' || *p > '~')\n      return 0;\n    j = *p++ - ' ';\n    if (*p < ' ' || *p > '~')\n      return 0;\n    k = *p++ - ' ';\n    if (*p < ' ' || *p > '~')\n      return 0;\n    l = *p++ - ' ';\n    if (*p < ' ' || *p > '~')\n      return 0;\n    *q++ = (j << 18) >> 16;\n    *q++ = ((j << 18) & 0xff00) | (k << 12) >> 16;\n    *q++ = ((k << 12) & 0xff00) | (l << 6) >> 16;\n    *q++ = l << 6 & 0xff00;\n  }\n  return l;\n}","pass":0,"source_file":"C_COMPILE/f2126/main_2126.c"}
{"compilable":1,"function":"char *strcpy(char *destination, const char *source) {\n    int i = 0;\n    while ((destination[i] = source[i]) != '\\x00')\n        i++;\n    return destination;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  int i;\n\n  for (i = 0; dest[i] = src[i]; i++)\n    ;\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f928/main_928.c"}
{"compilable":0,"function":"int meat_time_which_day_of_week(const unsigned char *const p_arg, const size_t i_arg_len) {\n    static const unsigned char a_ref_wday[7][3] = {{'s', 'u', 'n'}, {'m', 'o', 'n'}, {'t', 'u', 'e'}, {'w', 'e', 'd'}, {'t', 'h', 'u'}, {'f', 'r', 'i'}, {'s', 'a', 't'}};\n    int i_wday;\n    char b_found;\n    i_wday = 0;\n    b_found = 0;\n    if (3U == i_arg_len) {\n        while (!b_found && (i_wday < 7))\n            {\n                if ((p_arg[0U] == a_ref_wday[i_wday][0U]) && (p_arg[1U] == a_ref_wday[i_wday][1U]) && (p_arg[2U] == a_ref_wday[i_wday][2U])) {\n                    b_found = 1;\n                } else {\n                    i_wday++;\n                }\n            }\n    }\n    if (!b_found) {\n        i_wday = -1;\n    }\n    return i_wday;\n}\n","function_prediction":"int meat_time_which_day_of_week_name_conflict(const char *day_of_week,\n                                size_t day_of_week_len) {\n  int i;\n  int found = 0;\n\n  if (day_of_week_len != 3)\n    return -1;\n\n  for (i = 0; i < 7 && !found; i++) {\n    if (day_of_week[0] == a_ref_wday_0[i * 3] &&\n        day_of_week[1] == a_ref_wday_0[i * 3 + 1] &&\n        day_of_week[2] == a_ref_wday_0[i * 3 + 2]) {\n      found = 1;\n    }\n  }\n\n  if (!found)\n    return -1;\n\n  return i - 1;\n}","pass":0,"source_file":"C_COMPILE/f997/main_997.c"}
{"compilable":1,"function":"int sendbyte(int port, unsigned char *data) {\n    write(port, data, 1);\n    return 0;\n}\n","function_prediction":"int sendbyte_name_conflict(int fd, unsigned char *byte) {\n  write(fd, byte, 1);\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1248/main_1248.c"}
{"compilable":1,"function":"__attribute__((noinline)) unsigned char fn3(unsigned char x, unsigned char y, int *ovf) {\n    unsigned char res;\n    x = (x & 63) + ((unsigned char)~0 - 65);\n    y = (y & 3);\n    *ovf = __builtin_add_overflow(x, y, &res);\n    return res;\n}\n","function_prediction":"unsigned char fn3_name_conflict(unsigned char a, unsigned char b, unsigned char *c) {\n  unsigned char d;\n  d = (a & 0x3f) + 0xbe;\n  *c = CARRY1(d, b & 0x03);\n  return d + (b & 0x03);\n}","pass":1,"source_file":"C_COMPILE/f1971/main_1971.c"}
{"compilable":1,"function":"int check_par(char *str, int *i) {\n    int opar;\n    int cpar;\n    opar = 0;\n    cpar = 0;\n    while (str[*i])\n        {\n            if (str[*i] == '(')\n                opar++;\n            if (str[*i] == ')')\n                cpar++;\n            ++*i;\n        }\n    if (opar > cpar)\n        return (1);\n    else if (cpar > opar)\n        return (2);\n    else\n        return (0);\n}\n","function_prediction":"int check_par_name_conflict(char *str, int *i) {\n  int par_open = 0;\n  int par_close = 0;\n\n  while (str[*i] != '\\0') {\n    if (str[*i] == '(')\n      par_open++;\n    if (str[*i] == ')')\n      par_close++;\n    (*i)++;\n  }\n  if (par_open > par_close)\n    return (1);\n  else if (par_open < par_close)\n    return (2);\n  return (0);\n}","pass":0,"source_file":"C_COMPILE/f1098/main_1098.c"}
{"compilable":0,"function":"int SDL_imageFilterShiftLeftMMX(unsigned char *Src1, unsigned char *Dest, int length, unsigned char N) {\n    return (0);\n}\n","function_prediction":"int SDL_imageFilterShiftLeftMMX_name_conflict(void *A, int A_pitch, void *B, int B_pitch,\n                                int w, int h) {\n# 103 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/g-Fulcrum/SDL_gfx/refs/heads/master/SDL_imageFilter.c\"\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f401/main_401.c"}
{"compilable":1,"function":"char *ft_str_toupper(char *str) {\n    char *res;\n    res = str;\n    while (*str)\n        {\n            if (*str <= 'z' && *str >= 'a')\n                *str -= 32;\n            str++;\n        }\n    return (res);\n}\n","function_prediction":"char *ft_str_toupper_name_conflict(char *str) {\n  char *ptr;\n\n  ptr = str;\n  while (*ptr) {\n    if (*ptr >= 'a' && *ptr <= 'z')\n      *ptr -= 32;\n    ptr++;\n  }\n  return (str);\n}","pass":1,"source_file":"C_COMPILE/f862/main_862.c"}
{"compilable":0,"function":"size_t utf8_get_next(const char *utf8, int *utf32) {\n    const unsigned char *p = (unsigned char *)utf8;\n    if (p[0] < 128) {\n        if (utf32 != ((void *)0)) {\n            *utf32 = p[0];\n        }\n        return 1;\n    } else if (p[0] < 194) {\n        if (utf32 != ((void *)0)) {\n            *utf32 = -p[0];\n        }\n        return 1;\n    } else if (p[0] < 224) {\n        if (p[1] < 128 || 191 < p[1]) {\n            if (utf32 != ((void *)0)) {\n                *utf32 = -p[0];\n            }\n            return 1;\n        }\n        if (utf32 != ((void *)0)) {\n            *utf32 = ((p[0] & 31) << 6) | (p[1] & 63);\n        }\n        return 2;\n    } else if (p[0] < 240) {\n        if (p[1] < (p[0] == 224 ? 160 : 128) || (p[0] == 237 ? 159 : 191) < p[1]) {\n            if (utf32 != ((void *)0)) {\n                *utf32 = -p[0];\n            }\n            return 1;\n        }\n        if (p[2] < 128 || 191 < p[2]) {\n            if (utf32 != ((void *)0)) {\n                *utf32 = -p[0];\n            }\n            return 1;\n        }\n        if (utf32 != ((void *)0)) {\n            *utf32 = ((p[0] & 15) << 12) | ((p[1] & 63) << 6) | (p[2] & 63);\n        }\n        return 3;\n    } else if (p[0] < 245) {\n        if (p[1] < (p[0] == 240 ? 144 : 128) || (p[0] == 244 ? 143 : 191) < p[1]) {\n            if (utf32 != ((void *)0)) {\n                *utf32 = -p[0];\n            }\n            return 1;\n        }\n        if (p[2] < 128 || 191 < p[2]) {\n            if (utf32 != ((void *)0)) {\n                *utf32 = -p[0];\n            }\n            return 1;\n        }\n        if (p[3] < 128 || 191 < p[3]) {\n            if (utf32 != ((void *)0)) {\n                *utf32 = -p[0];\n            }\n            return 1;\n        }\n        if (utf32 != ((void *)0)) {\n            *utf32 = ((p[0] & 7) << 18) | ((p[1] & 63) << 12) | ((p[2] & 63) << 6) | (p[3] & 63);\n        }\n        return 4;\n    } else {\n        if (utf32 != ((void *)0)) {\n            *utf32 = -p[0];\n        }\n        return 1;\n    }\n}\n","function_prediction":"int utf8_get_next_name_conflict(const char *s, int *c) {\n  if (*s < 0x80) {\n    if (c)\n      *c = *s;\n    return 1;\n  }\n  if (*s < 0xc2) {\n    if (c)\n      *c = -*s;\n    return 1;\n  }\n  if (*s < 0xe0) {\n    if (s[1] < 0x80) {\n      if (c)\n        *c = ((*s & 0x1f) << 6) | (s[1] & 0x3f);\n      return 2;\n    }\n    if (c)\n      *c = -*s;\n    return 1;\n  }\n  if (*s < 0xf0) {\n    if (*s == 0xe0) {\n      if (s[1] < 0xa0) {\n        if (c)\n          *c = -*s;\n        return 1;\n      }\n      if (*s == 0xed) {\n        if (s[1] > 0x9f) {\n          if (c)\n            *c = -*s;\n          return 1;\n        }\n      } else {\n        if (s[1] > 0xbf) {\n          if (c)\n            *c = -*s;\n          return 1;\n        }\n      }\n    } else {\n      if (s[1] < 0x80) {\n        if (c)\n          *c = -*s;\n        return 1;\n      }\n    }\n    if (s[2] < 0x80) {\n      if (c)\n        *c = ((*s & 0x0f) << 12) | ((s[1] & 0x3f) << 6) | (s[2] & 0x3f);\n      return 3;\n    }\n    if (c)\n      *c = -*s;\n    return 1;\n  }\n  if (*s < 0xf5) {\n    if (*s == 0xf0) {\n      if (s[1] < 0x90) {\n                if (c","pass":0,"source_file":"C_COMPILE/f541/main_541.c"}
{"compilable":1,"function":"int add_char_to_buffer(int *len, char *buf, int maxlen, char c) {\n    if (*len >= maxlen)\n        return 0;\n    buf[(*len)++] = c;\n    return 1;\n}\n","function_prediction":"int add_char_to_buffer_name_conflict(int *buffer_index, char *buffer, int buffer_size,\n                       char c) {\n  if (*buffer_index < buffer_size) {\n    buffer[(*buffer_index)++] = c;\n    return 1;\n  }\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1549/main_1549.c"}
{"compilable":1,"function":"char *strcpy(char *dest, const char *src) {\n    char *p = dest;\n    while ((*(p++) = *(src++)) != '\\x00')\n        ;\n    return dest;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f814/main_814.c"}
{"compilable":1,"function":"int get_hex(char *buf, int start_position, unsigned int *address, unsigned int *length) {\n    int cpos = 0, done = 0;\n    cpos = start_position;\n    done = 0;\n    *address = 0;\n    while (done == 0)\n        {\n            if (buf[cpos] >= '0' && buf[cpos] <= '9') {\n                *address = *address << 4;\n                *address = *address + buf[cpos] - '0';\n            } else if (buf[cpos] >= 'A' && buf[cpos] <= 'F') {\n                *address = *address << 4;\n                *address = *address + buf[cpos] - 'A' + 10;\n            } else if (buf[cpos] >= 'a' && buf[cpos] <= 'f') {\n                *address = *address << 4;\n                *address = *address + buf[cpos] - 'a' + 10;\n            } else {\n                done = 1;\n                *length = cpos - start_position;\n            }\n            if (cpos >= 8 + start_position) {\n                done = 1;\n                *length = 8;\n            }\n            cpos++;\n        }\n    if (cpos > start_position + 1)\n        return 1;\n    else\n        return 0;\n}\n","function_prediction":"int get_hex_name_conflict(char *str, int pos, int *val, int *len) {\n  int i;\n  int done = 0;\n\n  *val = 0;\n\n  for (i = pos; !done; i++) {\n    if (str[i] >= '0' && str[i] <= '9') {\n      *val <<= 4;\n      *val += str[i] - '0';\n    } else if (str[i] >= 'A' && str[i] <= 'F') {\n      *val <<= 4;\n      *val += str[i] - 'A' + 10;\n    } else if (str[i] >= 'a' && str[i] <= 'f') {\n      *val <<= 4;\n      *val += str[i] - 'a' + 10;\n    } else {\n      done = 1;\n      *len = i - pos;\n    }\n\n    if (i > pos + 7) {\n      done = 1;\n      *len = 8;\n    }\n  }\n\n  return (i > pos + 1);\n}","pass":1,"source_file":"C_COMPILE/f797/main_797.c"}
{"compilable":1,"function":"int foo(int a, int b, int *p, int *q) {\n    a = p[2] + p[3];\n    *q = a;\n    *p = a;\n    return a;\n}\n","function_prediction":"int foo_name_conflict(int a, int b, int *c, int *d) {\n  *d = *c + a;\n  *c = *d;\n  return *d;\n}","pass":0,"source_file":"C_COMPILE/f659/main_659.c"}
{"compilable":1,"function":"static int i2a(char *dest, unsigned int x) {\n    register unsigned int tmp = x;\n    register int len = 0;\n    if (x >= 100) {\n        *dest++ = tmp / 100 + '0';\n        tmp = tmp % 100;\n        ++len;\n    }\n    if (x >= 10) {\n        *dest++ = tmp / 10 + '0';\n        tmp = tmp % 10;\n        ++len;\n    }\n    *dest++ = tmp + '0';\n    return len + 1;\n}\n","function_prediction":"int i2a_name_conflict(char *s, int i) {\n  char *p = s;\n  int n = 0;\n\n  if (i >= 100) {\n    *p++ = '0' + i / 100;\n    i %= 100;\n    n++;\n  }\n  if (i >= 10) {\n    *p++ = '0' + i / 10;\n    i %= 10;\n    n++;\n  }\n  *p++ = '0' + i;\n  n++;\n  return n;\n}","pass":0,"source_file":"C_COMPILE/f358/main_358.c"}
{"compilable":0,"function":"static int smtp_si_mul_size_t(const size_t a, const size_t b, size_t *const result) {\n    int wraps;\n    if (b != 0 && a > ((size_t)(-1)) / b) {\n        wraps = 1;\n    } else {\n        wraps = 0;\n    }\n    if (result) {\n        *result = a * b;\n    }\n    return wraps;\n}\n","function_prediction":"int smtp_si_mul_size_t_name_conflict(size_t a, size_t b, size_t *c) {\n  int ret = 0;\n\n  if (b == 0)\n    goto out;\n\n  if (a > (((size_t)-1) / b))\n    goto out;\n\n  ret = 1;\n\nout:\n  if (c)\n    *c = a * b;\n\n  return ret;\n}","pass":0,"source_file":"C_COMPILE/f85/main_85.c"}
{"compilable":0,"function":"int MPI_Comm_rank(int comm, int *me) {\n    *me = 0;\n    return 0;\n}\n","function_prediction":"int MPI_Comm_rank_name_conflict(MPI_Comm comm, int *rank) {\n  *rank = 0;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1462/main_1462.c"}
{"compilable":1,"function":"int init_gap_qual_window(int *window, char *quals, int seq_len) {\n    int i;\n    for (i = 0; i < 4; i++) {\n        window[i] = -1;\n    }\n    i = 4;\n    int win_edge = -1;\n    int quals_added = 0;\n    while (quals_added < 4)\n        {\n            win_edge++;\n            if (win_edge >= seq_len) {\n                win_edge = seq_len;\n                window[i] = -1;\n                i++;\n                quals_added++;\n            } else if (quals[win_edge] != ' ') {\n                window[i] = quals[win_edge];\n                i++;\n                quals_added++;\n            }\n        }\n    return win_edge;\n}\n","function_prediction":"int init_gap_qual_window_name_conflict(int *window, char *qual, int len) {\n  int i, j, k;\n\n  for (i = 0; i < 4; i++)\n    window[i] = -1;\n\n  i = 4;\n  j = -1;\n  k = 0;\n  while (k < 4) {\n    j++;\n    if (j < len) {\n      if (qual[j] != ' ') {\n        window[i] = qual[j];\n        i++;\n        k++;\n      }\n    } else {\n      window[i] = -1;\n      i++;\n      k++;\n      j = len;\n    }\n  }\n\n  return j;\n}","pass":1,"source_file":"C_COMPILE/f773/main_773.c"}
{"compilable":1,"function":"char jsonny_pop(char *s, size_t *len) {\n    char c;\n    if (*len > 0) {\n        (*len)--;\n        c = s[*len];\n        s[*len] = '\\x00';\n        return c;\n    }\n}\n","function_prediction":"char jsonny_pop_name_conflict(char *stack, size_t *stack_size) {\n  if (*stack_size == 0)\n    return 0;\n\n  char c = stack[--(*stack_size)];\n  stack[*stack_size] = 0;\n  return c;\n}","pass":1,"source_file":"C_COMPILE/f939/main_939.c"}
{"compilable":0,"function":"int SDL_imageFilterNormalizeLinearMMX(unsigned char *Src1, unsigned char *Dest, int length, int Cmin, int Cmax, int Nmin, int Nmax) {\n    return (0);\n}\n","function_prediction":"int SDL_imageFilterNormalizeLinearMMX_name_conflict(void *A, int aPitch, int aX, int aY,\n                                      int aW, int aH, void *B, int bPitch,\n                                      int bX, int bY, int bW, int bH) {\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1191/main_1191.c"}
{"compilable":0,"function":"int cipher(char *text, int lkey, int nkey) {\n    int textLength;\n    int x, offset, lkeyHash, nkeyHash, decryptFlag;\n    int lastQuad;\n    int i;\n    char temp;\n    textLength = 0;\n    while (text[textLength] != '\\x00')\n        {\n            ++textLength;\n        }\n    textLength += 1;\n    if (textLength > 1025) {\n        textLength = 1025;\n        text[textLength] = '\\x00';\n    }\n    lkeyHash = (lkey % 26) + 26;\n    nkeyHash = (nkey % 10) + 10;\n    decryptFlag = ((lkey < 0) && (lkey & 1));\n    for (i = 0; i < textLength; i++) {\n        if (text[i] >= 'A' && text[i] <= 'Z') {\n            x = (text[i] - 'A' + lkeyHash) % 26;\n            if (decryptFlag)\n                offset = ((x - 'A') & 1) ? 'A' : 'a';\n            else\n                offset = ((x - 'A') & 1) ? 'a' : 'A';\n            text[i] = x + offset;\n        } else if (text[i] >= 'a' && text[i] <= 'z') {\n            x = (text[i] - 'a' + lkeyHash) % 26;\n            offset = (decryptFlag) ? (((x - 'A') & 1) ? 'a' : 'A') : (((x - 'A') & 1) ? 'A' : 'a');\n            text[i] = x + offset;\n        } else if (text[i] >= '0' && text[i] <= '9') {\n            text[i] = ((text[i] - '0' + nkeyHash) % 10) + '0';\n        } else\n            continue;\n    }\n    lastQuad = textLength % 4;\n    for (i = 0; i < (textLength - lastQuad); i += 4) {\n        temp = text[i];\n        text[i] = text[i + 2];\n        text[i + 2] = temp;\n        temp = text[i + 1];\n        text[i + 1] = text[i + 3];\n        text[i + 3] = temp;\n    }\n    if (lastQuad != 0)\n        switch (lastQuad) {\n          case 1:\n            break;\n          case 2:\n            temp = text[i];\n            text[i] = text[i + 1];\n            text[i + 1] = temp;\n            break;\n          case 3:\n            temp = text[i];\n            text[i] = text[i + 2];\n            text[i + 2] = temp;\n            break;\n        }\n    return textLength;\n}\n","function_prediction":"int cipher_name_conflict(char *str, int key, int seed) {\n  int i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int len;\n\n  for (i = 0; str[i] != '\\0'; i++)\n    ;\n  len = i + 1;\n  if (len > 1024) {\n    len = 1024;\n    str[1024] = '\\0';\n  }\n\n  key = (key % 26) + 26;\n  if (key < 0) {\n    if (key % 2)\n      k = 1;\n    else\n      k = 0;\n  } else\n    k = 0;\n\n  for (i = 0; i < len; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      j = (str[i] - 'A' + key) % 26;\n      if (k) {\n        if (j % 2)\n          str[i] = 'a' + j;\n        else\n          str[i] = 'A' + j;\n      } else {\n        if (j % 2)\n          str[i] = 'A' + j;\n        else\n          str[i] = 'a' + j;\n      }\n    } else if (str[i] >= 'a' && str[i] <= 'z') {\n      j = (str[i] - 'a' + key) % 26;\n      if (k) {\n        if (j % 2)\n          str[i] = 'a' + j;\n        else\n          str[i] = 'A' + j;\n      } else {\n        if (j % 2)\n          str[i] = 'a' + j;\n        else\n          str[i] = 'A' + j;\n      }\n    } else if (str[i] >= '0' && str[i] <= '9') {\n            j = (str[i] - '0'","pass":0,"source_file":"C_COMPILE/f1820/main_1820.c"}
{"compilable":0,"function":"short goertzel_output_power_v1(short *delay, short b_RE, short b_IM) {\n    int goertzel_power;\n    long real;\n    long imag;\n    real = delay[1] + (b_RE + delay[1] >> 15);\n    imag = (delay[1] * b_IM) >> 15;\n    goertzel_power = real * real + imag * imag;\n    delay[1] = 0;\n    delay[2] = 0;\n    return goertzel_power;\n}\n","function_prediction":"int goertzel_output_power_v1_name_conflict(goertzel_state_t *state, short re, short im) {\n  int power;\n\n  re += state->q1;\n  re = (re >> 15) + re;\n  im = (state->q2 * im) >> 15;\n  state->q1 = 0;\n  state->q2 = 0;\n  power = (re * re) + (im * im);\n\n  return power;\n}","pass":0,"source_file":"C_COMPILE/f2031/main_2031.c"}
{"compilable":0,"function":"int SDL_imageFilterMeanMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length, unsigned char *Mask) {\n    return (0);\n}\n","function_prediction":"int SDL_imageFilterMeanMMX_name_conflict(void) {\n# 110 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/g-Fulcrum/SDL_gfx/refs/heads/master/SDL_imageFilter.c\"\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f490/main_490.c"}
{"compilable":0,"function":"int SDL_imageFilterMultDivby2MMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterMultDivby2MMX_name_conflict(Uint8 *src, Uint8 *dst, int length) {\n# 110 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/g-Fulcrum/SDL_gfx/refs/heads/master/SDL_imageFilter.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f2021/main_2021.c"}
{"compilable":1,"function":"int *sort(int *arr) {\n    int len = 0;\n    while (arr[len++])\n        ;\n    int flag = 1;\n    while (flag)\n        {\n            flag = 0;\n            for (int i = 0; i < len - 2; i++)\n                if (arr[i] > arr[i + 1]) {\n                    int r = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = r;\n                    flag = 1;\n                }\n        }\n    return arr;\n}\n","function_prediction":"int *sort_name_conflict(int *array) {\n  int i, j, temp;\n  int size = 0;\n  while (array[size++] != 0)\n    ;\n  for (i = 0; i < size - 1; i++) {\n    for (j = 0; j < size - 1; j++) {\n      if (array[j] > array[j + 1]) {\n        temp = array[j];\n        array[j] = array[j + 1];\n        array[j + 1] = temp;\n      }\n    }\n  }\n  return array;\n}","pass":0,"source_file":"C_COMPILE/f1763/main_1763.c"}
{"compilable":1,"function":"int fun(int *x) {\n    *x = *x + 1;\n    return 0;\n}\n","function_prediction":"int fun_name_conflict(int *a) {\n  *a = *a + 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1779/main_1779.c"}
{"compilable":0,"function":"int RGB555toI420(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"int RGB555toI420_name_conflict(unsigned char *src, unsigned char *dst, int width,\n                 int height) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1683/main_1683.c"}
{"compilable":0,"function":"static const char *findchar_fast(const char *buf, const char *buf_end, const char *ranges, size_t ranges_size, int *found) {\n    *found = 0;\n    return buf;\n}\n","function_prediction":"char *findchar_fast_name_conflict(char *s, char *t, int *pos) {\n  *pos = 0;\n  return s;\n}","pass":0,"source_file":"C_COMPILE/f427/main_427.c"}
{"compilable":0,"function":"static inline int mac_not_zero(const unsigned char mac[6]) {\n    int i;\n    for (i = 0; i < 6; i++) {\n        if (mac[i] != 0)\n            return 1;\n    }\n    return 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1066/main_1066.c"}
{"compilable":1,"function":"static unsigned long _dl_div(unsigned long num, unsigned long den, unsigned long *rem) {\n    unsigned long quot = 0, qbit = 1;\n    if (den == 0)\n        return 0;\n    while ((int)den >= 0)\n        {\n            den <<= 1;\n            qbit <<= 1;\n        }\n    while (qbit)\n        {\n            if (den <= num) {\n                num -= den;\n                quot += qbit;\n            }\n            den >>= 1;\n            qbit >>= 1;\n        }\n    if (rem)\n        *rem = num;\n    return quot;\n}\n","function_prediction":"unsigned long _dl_div_name_conflict(unsigned long num, unsigned long den,\n                      unsigned long *rem_ptr) {\n  unsigned long quot = 0, qbit = 1;\n  unsigned long remainder;\n\n  if (den == 0)\n    return 0;\n\n  remainder = num;\n\n  while ((int)den >= 0) {\n    den <<= 1;\n    qbit <<= 1;\n  }\n\n  while (qbit != 0) {\n    if (remainder >= den) {\n      remainder -= den;\n      quot += qbit;\n    }\n    den >>= 1;\n    qbit >>= 1;\n  }\n\n  if (rem_ptr != NULL)\n    *rem_ptr = remainder;\n\n  return quot;\n}","pass":1,"source_file":"C_COMPILE/f875/main_875.c"}
{"compilable":0,"function":"int RGB555toRGB32(unsigned char *dest_ptr, int dest_width, int dest_height, int dest_pitch, int dest_x, int dest_y, int dest_dx, int dest_dy, unsigned char *src_ptr, int src_width, int src_height, int src_pitch, int src_x, int src_y, int src_dx, int src_dy) {\n    return -1;\n}\n","function_prediction":"int RGB555toRGB32_name_conflict(unsigned short int *src, unsigned int *dst, int width,\n                  int height) {\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f554/main_554.c"}
{"compilable":1,"function":"char *replaceChar(char *str, char oldChar, char newChar) {\n    char *strPtr = str;\n    while ((strPtr = strchr(strPtr, oldChar)) != ((void *)0))\n        *strPtr++ = newChar;\n    return str;\n}\n","function_prediction":"char *replaceChar_name_conflict(char *str, char find, char replace) {\n  char *c = str;\n  while ((c = strchr(c, find)) != NULL)\n    *c++ = replace;\n  return str;\n}","pass":1,"source_file":"C_COMPILE/f1212/main_1212.c"}
{"compilable":0,"function":"static inline intptr_t atomic_fetch_sub(intptr_t *object, intptr_t operand) {\n    intptr_t ret;\n    ret = *object;\n    *object = *object - operand;\n    return ret;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f67/main_67.c"}
{"compilable":1,"function":"int writepng(char *name, int xres, int yres, unsigned char *imgdata) {\n    return 2;\n}\n","function_prediction":"int writepng_name_conflict(char *filename, int width, int height, int *data) { return 2; }","pass":1,"source_file":"C_COMPILE/f79/main_79.c"}
{"compilable":0,"function":"int scc_setval(int *i, int mask, int val) {\n    *i = (*i & (mask ^ 4294967295U));\n    *i = (*i ^ val);\n    return (0);\n}\n","function_prediction":"int scc_setval_name_conflict(scc_t *scc, unsigned int mask, unsigned int val) {\n  scc->reg &= ~mask;\n  scc->reg ^= val;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1291/main_1291.c"}
{"compilable":1,"function":"int init_inotify(const char *filename, int *ifd, int *iwfd) {\n    if ((*ifd = inotify_init()) < 0) {\n        return -1;\n    }\n    if ((*iwfd = inotify_add_watch(*ifd, filename, 2 | 1024 | 2048 | 8192)) < 0) {\n        return -1;\n    }\n    return 0;\n}\n","function_prediction":"int init_inotify_name_conflict(char *path, int *inotify_fd, int *watch_descriptor) {\n  *inotify_fd = inotify_init();\n  if (*inotify_fd < 0)\n    return -1;\n\n  *watch_descriptor =\n      inotify_add_watch(*inotify_fd, path, 0x02 | 0x04 | 0x20 | 0x01);\n  if (*watch_descriptor < 0)\n    return -1;\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f288/main_288.c"}
{"compilable":1,"function":"int bad_guy(int *i) {\n    *i = 9;\n    return *i;\n}\n","function_prediction":"int bad_guy_name_conflict(int *x) {\n  *x = 9;\n  return *x;\n}","pass":1,"source_file":"C_COMPILE/f879/main_879.c"}
{"compilable":1,"function":"int conv_hstring(char *string, unsigned int *addr) {\n    int pos = 0;\n    *addr = 0;\n    while (((string[pos] >= '0' && string[pos] <= '9') || (string[pos] >= 'a' && string[pos] <= 'f')) && pos < 9)\n        {\n            if (string[pos] >= '0' && string[pos] <= '9')\n                *addr = (*addr << 4) + (string[pos++] - '0');\n            else\n                *addr = (*addr << 4) + (string[pos++] - 'a') + 10;\n        }\n    return pos;\n}\n","function_prediction":"int conv_hstring_name_conflict(char *str, int *val) {\n  int i;\n\n  *val = 0;\n  for (i = 0; i < 9; i++) {\n    if (((str[i] >= '0') && (str[i] <= '9')) ||\n        ((str[i] >= 'a') && (str[i] <= 'f')) ||\n        ((str[i] >= 'A') && (str[i] <= 'F'))) {\n      if ((str[i] >= '0') && (str[i] <= '9'))\n        *val = (*val << 4) + str[i] - '0';\n      else if ((str[i] >= 'a') && (str[i] <= 'f'))\n        *val = (*val << 4) + str[i] - 'a' + 10;\n      else if ((str[i] >= 'A') && (str[i] <= 'F'))\n        *val = (*val << 4) + str[i] - 'A' + 10;\n    } else\n      break;\n  }\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f2038/main_2038.c"}
{"compilable":1,"function":"unsigned int fmt_str(char *s, const char *t) {\n    unsigned int len;\n    char ch;\n    len = 0;\n    if (s) {\n        while ((ch = t[len]) != 0)\n            s[len++] = ch;\n    } else\n        while (t[len])\n            len++;\n    return len;\n}\n","function_prediction":"int fmt_str_name_conflict(char *dst, const char *src) {\n  int i;\n\n  if (dst) {\n    for (i = 0; src[i]; i++)\n      dst[i] = src[i];\n  } else {\n    for (i = 0; src[i]; i++)\n      ;\n  }\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f1193/main_1193.c"}
{"compilable":1,"function":"static char *sh_escape_string(char *dest, char *src) {\n    *dest++ = '\\'';\n    while (1)\n        {\n            char x = *src++;\n            if (x == '\\'') {\n                *dest++ = '\\'';\n                *dest++ = '\\\\';\n                *dest++ = '\\'';\n            } else if (x == '\\x00') {\n                *dest++ = '\\'';\n                break;\n            }\n            *dest++ = x;\n        }\n    *dest = '\\x00';\n    return dest;\n}\n","function_prediction":"char *sh_escape_string_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  *d++ = '\\'';\n  while (*s) {\n    if (*s == '\\'') {\n      *d++ = '\\'';\n      *d++ = '\\\\';\n      *d++ = '\\'';\n    } else {\n      *d++ = *s;\n    }\n    s++;\n  }\n  *d++ = '\\'';\n  *d = '\\0';\n\n  return d;\n}","pass":1,"source_file":"C_COMPILE/f1315/main_1315.c"}
{"compilable":0,"function":"int file_perms_parse_mode(const unsigned char *mode) {\n    return -1;\n}\n","function_prediction":"int file_perms_parse_mode_name_conflict(const char *mode, mode_t *out) {\n# 101 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/jhbsz/libfile/refs/heads/master/src/file_perms.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f477/main_477.c"}
{"compilable":0,"function":"static char is_pack_letter(short *c, unsigned short *mask) {\n    if (((*c == '?') || (*c == '!') || (*c == ':') || (*c == '=') || (*c == ')') || (*c == ']') || (*c == '/') || (*c == ','))) {\n        switch (*c) {\n          case '?':\n            *mask = ((unsigned short)4);\n            break;\n          case '!':\n            *mask = ((unsigned short)8);\n            break;\n          case ':':\n            *mask = ((unsigned short)32);\n            break;\n          case ')':\n            *mask = ((unsigned short)2);\n            break;\n          case ']':\n            *mask = ((unsigned short)1);\n            break;\n          case '/':\n            *mask = ((unsigned short)64);\n            break;\n          case '=':\n            *mask = ((unsigned short)128);\n            break;\n          case ',':\n            *mask = ((unsigned short)256);\n            break;\n        }\n        *c = '*';\n        return (1);\n    }\n    return (((*c >= 'a') && (*c <= 'z')) || (*c == '\\x1b') || (*c == '*'));\n}\n","function_prediction":"int is_pack_letter_name_conflict(unsigned short *c, unsigned short *pack) {\n  if (*c == '?' || *c == '!' || *c == ':' || *c == '=' || *c == ')' ||\n      *c == ']' || *c == '/' || *c == ',') {\n    switch (*c) {\n    case '?':\n      *pack = 0x0004;\n      break;\n    case '=':\n      *pack = 0x0080;\n      break;\n    case ')':\n      *pack = 0x0002;\n      break;\n    case ']':\n      *pack = 0x0001;\n      break;\n    case ':':\n      *pack = 0x0020;\n      break;\n    case '!/':\n      *pack = 0x0040;\n      break;\n    case '!/':\n      *pack = 0x0040;\n      break;\n    case ',':\n      *pack = 0x0100;\n      break;\n    }\n    *c = '*';\n    return 1;\n  }\n  if ((*c >= 'a' && *c <= 'z') || *c == '\\033' || *c == '*')\n    return 1;\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1697/main_1697.c"}
{"compilable":1,"function":"char *strupr(char *text) {\n    char *origtext = text;\n    while (*text != '\\x00')\n        {\n            if ((*text > 96) && (*text < 123))\n                *text -= 32;\n            text++;\n        }\n    return (origtext);\n}\n","function_prediction":"char *strupr_name_conflict(char *s) {\n  char *p = s;\n\n  while (*p) {\n    if (*p >= 'a' && *p <= 'z')\n      *p -= 'a' - 'A';\n    p++;\n  }\n  return s;\n}","pass":1,"source_file":"C_COMPILE/f1903/main_1903.c"}
{"compilable":1,"function":"static int to_upper_n(char *str, int len) {\n    int i = 0;\n    for (i = 0; i < len; i++) {\n        if (('a' <= str[i]) && (str[i] <= 'z')) {\n            str[i] = str[i] - ('a' - 'A');\n        }\n    }\n    return 0;\n}\n","function_prediction":"int to_upper_n_name_conflict(char *s, int n) {\n  int i;\n\n  for (i = 0; i < n; i++) {\n    if (s[i] >= 'a' && s[i] <= 'z')\n      s[i] -= 'a' - 'A';\n  }\n\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f922/main_922.c"}
{"compilable":1,"function":"static int GetHostAddress(char *hostname, unsigned int *number) {\n    struct hostent *hp;\n    if ((hp = gethostbyname(hostname))) {\n        *number = ((struct in_addr *)(hp->h_addr_list[0]))->s_addr;\n        return 0;\n    }\n    *number = -1;\n    return -1;\n}\n","function_prediction":"int GetHostAddress_name_conflict(char *hostname, int *address) {\n  struct hostent *host;\n\n  host = gethostbyname(hostname);\n  if (host == NULL) {\n    *address = -1;\n    return -1;\n  }\n\n  *address = *(int *)host->h_addr_list[0];\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f390/main_390.c"}
{"compilable":1,"function":"__attribute__((noinline)) signed char fn2(long x, long y, int *ovf) {\n    signed char res;\n    x = (x & 63) + (127 / 4);\n    y = (y & 3) + 4;\n    *ovf = __builtin_mul_overflow(x, y, &res);\n    return res;\n}\n","function_prediction":"unsigned char fn2_name_conflict(unsigned int a, unsigned int b, unsigned int *c) {\n  unsigned long long d = (a & 63) * (b & 3) + 4;\n  *c = (d >> 32) != (a & 63) * (b & 3);\n  return d & 0xff;\n}","pass":0,"source_file":"C_COMPILE/f324/main_324.c"}
{"compilable":1,"function":"int itoa_fn(int n, char *s) {\n    if (n > 0) {\n        int len = 1;\n        if (n / 10 > 0)\n            len += itoa_fn(n / 10, s);\n        s[len - 1] = (n % 10) + '0';\n        return len;\n    }\n    return 0;\n}\n","function_prediction":"int itoa_fn_name_conflict(int n, char s[]) {\n  int i;\n\n  if (n / 10)\n    i = itoa_fn_name_conflict(n / 10, s);\n  else\n    i = 0;\n  s[i++] = n % 10 + '0';\n\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f1214/main_1214.c"}
{"compilable":0,"function":"static inline int _hclib_atomic_inc_acquire(volatile int *target) {\n    return __sync_add_and_fetch_4(target, 1);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1359/main_1359.c"}
{"compilable":0,"function":"int wlan_cmd_send_recv(unsigned char vif_id, unsigned char *pData, int len, int subtype, int timeout) {\n    return 0;\n}\n","function_prediction":"int wlan_cmd_send_recv_name_conflict(struct wlan_dev *wlandev, struct wlan_cmd_req *cmd_req,\n                       struct wlan_cmd_resp *cmd_resp) {\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1927/main_1927.c"}
{"compilable":1,"function":"int swap_add(int *xp, int *yp) {\n    int x = *xp;\n    int y = *yp;\n    *xp = y;\n    *yp = x;\n    return x + y;\n}\n","function_prediction":"int swap_add_name_conflict(int *a, int *b) {\n  int tmp = *a;\n  *a = *b;\n  *b = tmp;\n  return *a + *b;\n}","pass":1,"source_file":"C_COMPILE/f135/main_135.c"}
{"compilable":1,"function":"int make_int(int *a_int, long a_long) {\n    *a_int = (int)(a_long);\n    long a2 = (long)(*a_int);\n    if (a2 != a_long)\n        return 1;\n    return 0;\n}\n","function_prediction":"int make_int_name_conflict(int *p, long l) {\n  *p = l;\n  return *p != l;\n}","pass":1,"source_file":"C_COMPILE/f2077/main_2077.c"}
{"compilable":1,"function":"char *mb_strupr(char *s) {\n    char *t = s;\n    while (*s)\n        {\n            *s = ((((*s) >= 'a' && (*s) <= 'z')) ? ((*s) - 'a' + 'A') : (*s));\n            ++s;\n        }\n    return t;\n}\n","function_prediction":"char *mb_strupr_name_conflict(char *str) {\n  char *p = str;\n  while (*p) {\n    *p = (*p >= 'a' && *p <= 'z') ? *p - 0x20 : *p;\n    p++;\n  }\n  return str;\n}","pass":1,"source_file":"C_COMPILE/f245/main_245.c"}
{"compilable":1,"function":"int get_val_impl(int *p, int x) {\n    if (x > 0) {\n        *p = x;\n        return 0;\n    }\n    return 1;\n}\n","function_prediction":"int get_val_impl_name_conflict(int *val, int v) {\n  if (v >= 1)\n    *val = v;\n  return v < 1;\n}","pass":1,"source_file":"C_COMPILE/f1930/main_1930.c"}
{"compilable":1,"function":"static size_t nrt_testing_atomic_dec(size_t *ptr) {\n    size_t out = *ptr;\n    out -= 1;\n    *ptr = out;\n    return out;\n}\n","function_prediction":"uint32_t nrt_testing_atomic_dec_name_conflict(volatile uint32_t *value) { return --(*value); }","pass":0,"source_file":"C_COMPILE/f1465/main_1465.c"}
{"compilable":1,"function":"int writeData(int fd, unsigned char *buf, int nChars) {\n    int written = 0;\n    while (nChars > 0)\n        {\n            written = write(fd, buf, nChars);\n            if (written < 0) {\n                return 0;\n            } else {\n                nChars -= written;\n                buf += written;\n            }\n            usleep(1000);\n        }\n    return 1;\n}\n","function_prediction":"int writeData_name_conflict(int fd, char *buf, int len) {\n  int n;\n  while (len > 0) {\n    n = write(fd, buf, len);\n    if (n < 0)\n      return 0;\n    len -= n;\n    buf += n;\n    usleep(1000);\n  }\n  return 1;\n}","pass":1,"source_file":"C_COMPILE/f2084/main_2084.c"}
{"compilable":1,"function":"int put_char_bare_utf8(char *_dst, int _ch) {\n    unsigned int ch = (unsigned int)_ch;\n    unsigned char *dst = (unsigned char *)_dst;\n    int len = 0;\n    if (ch <= 127) {\n        *dst++ = ch;\n        len = 1;\n    } else if (ch <= 2047) {\n        *dst = 192;\n        *dst++ |= (ch >> 6) & 31;\n        *dst = 128;\n        *dst++ |= (ch & 63);\n        len = 2;\n    } else if (ch <= 65535) {\n        *dst = 224;\n        *dst++ |= (ch >> 12) & 15;\n        *dst = 128;\n        *dst++ |= (ch >> 6) & 63;\n        *dst = 128;\n        *dst++ |= ch & 63;\n        len = 3;\n    } else if (ch <= 2097151) {\n        *dst = 224;\n        *dst++ |= (ch >> 18) & 7;\n        *dst = 128;\n        *dst++ |= (ch >> 12) & 63;\n        *dst = 128;\n        *dst++ |= (ch >> 6) & 63;\n        *dst = 128;\n        *dst++ |= ch & 63;\n        len = 4;\n    }\n    return len;\n}\n","function_prediction":"int put_char_bare_utf8_name_conflict(char *buf, int c) {\n  int n = 0;\n  if (c < 0x80) {\n    buf[n++] = c;\n  } else if (c < 0x800) {\n    buf[n++] = 0xc0 | (c >> 6);\n    buf[n++] = 0x80 | (c & 0x3f);\n  } else if (c < 0x10000) {\n    buf[n++] = 0xe0 | (c >> 12);\n    buf[n++] = 0x80 | ((c >> 6) & 0x3f);\n    buf[n++] = 0x80 | (c & 0x3f);\n  } else if (c < 0x200000) {\n    buf[n++] = 0xf0 | (c >> 18);\n    buf[n++] = 0x80 | ((c >> 12) & 0x3f);\n    buf[n++] = 0x80 | ((c >> 6) & 0x3f);\n    buf[n++] = 0x80 | (c & 0x3f);\n  }\n  return n;\n}","pass":0,"source_file":"C_COMPILE/f1966/main_1966.c"}
{"compilable":1,"function":"char *strset(char *s, int ch) {\n    unsigned char c;\n    for (c = 0; s[c] != 0; c++)\n        s[c] = ch;\n    return s;\n}\n","function_prediction":"char *strset_name_conflict(char *s, char c) {\n  unsigned char i;\n  for (i = 0; s[i]; i++)\n    s[i] = c;\n  return s;\n}","pass":1,"source_file":"C_COMPILE/f616/main_616.c"}
{"compilable":1,"function":"static int read_attr(char *buf, int len, int fd) {\n    int n;\n    if (fd < 0) {\n        buf[0] = 0;\n        return 0;\n    }\n    lseek(fd, 0, 0);\n    n = read(fd, buf, len - 1);\n    if (n <= 0) {\n        buf[0] = 0;\n        return 0;\n    }\n    buf[n] = 0;\n    if (buf[n - 1] == '\\n')\n        buf[n - 1] = 0;\n    return n;\n}\n","function_prediction":"int read_attr_name_conflict(char *buf, int size, int fd) {\n  int len;\n\n  if (fd < 0) {\n    buf[0] = 0;\n    return 0;\n  }\n\n  lseek(fd, 0, 0);\n  len = read(fd, buf, size - 1);\n  if (len <= 0) {\n    buf[0] = 0;\n    return 0;\n  }\n  buf[len] = 0;\n  if (buf[len - 1] == '\\n')\n    buf[len - 1] = 0;\n  return len;\n}","pass":1,"source_file":"C_COMPILE/f1453/main_1453.c"}
{"compilable":0,"function":"static inline int _evas_stringshare_hash_gen(const char *str, int *len) {\n    unsigned int hash_num = 5381;\n    const unsigned char *ptr;\n    for (ptr = (const unsigned char *)str; *ptr; ptr++) {\n        hash_num = (hash_num * 33) ^ *ptr;\n    }\n    hash_num &= 1023;\n    *len = ptr - (const unsigned char *)str;\n    return (int)hash_num;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1616/main_1616.c"}
{"compilable":1,"function":"static unsigned int calcSDSize(unsigned char *csd, int type) {\n    unsigned int result = 0;\n    if (type == -1)\n        type = csd[14] >> 6;\n    switch (type) {\n      case 0:\n        {\n            unsigned int block_len = csd[9] & 15;\n            block_len = 1 << block_len;\n            unsigned int mult = (csd[4] >> 7) | ((csd[5] & 3) << 1);\n            mult = 1 << (mult + 2);\n            result = csd[8] & 3;\n            result = (result << 8) | csd[7];\n            result = (result << 2) | (csd[6] >> 6);\n            result = (result + 1) * mult * block_len / 512;\n        }\n        break;\n      case 1:\n        result = csd[7] & 63;\n        result = (result << 8) | csd[6];\n        result = (result << 8) | csd[5];\n        result = (result + 1) * 1024;\n        break;\n    }\n    return result;\n}\n","function_prediction":"uint32_t calcSDSize_name_conflict(uint8_t *buf, uint32_t size) {\n  uint32_t sdsize = 0;\n\n  if (size == 0xFFFFFFFF)\n    size = (buf[14] >> 6);\n\n  switch (size) {\n  case 0:\n    sdsize = ((((buf[5] & 0x03) << 1) + (buf[6] >> 6)) + 1) *\n                 ((((buf[4] & 0x80) >> 7) + ((buf[5] & 0x0C) << 1)) + 2) *\n                 (1 << (buf[9] & 0x0F)) >>\n             9;\n    break;\n  case 1:\n    sdsize = (((buf[5] << 8) + (buf[6] << 8) + buf[7] + 1) * 1024);\n    break;\n  }\n\n  return sdsize;\n}","pass":1,"source_file":"C_COMPILE/f801/main_801.c"}
{"compilable":1,"function":"int max(int a, int b, int *p) {\n    if (a > b) {\n        *p = 0;\n        return a;\n    } else {\n        *p = 1;\n        return b;\n    }\n}\n","function_prediction":"int max_name_conflict(int a, int b, int *index) {\n  if (a > b) {\n    *index = 0;\n    return a;\n  } else {\n    *index = 1;\n    return b;\n  }\n}","pass":1,"source_file":"C_COMPILE/f981/main_981.c"}
{"compilable":1,"function":"int _encode_remaining_length(char *buffer, int length) {\n    char d;\n    int num = 0;\n    do {\n        d = length % 128;\n        length /= 128;\n        if (length > 0)\n            d |= 128;\n        buffer[num++] = d;\n    } while (length > 0);\n    return num;\n}\n","function_prediction":"int _encode_remaining_length_name_conflict(char *buf, int length) {\n  int i = 0;\n  do {\n    char c = length % 128;\n    length /= 128;\n    if (length > 0) {\n      c |= 0x80;\n    }\n    buf[i++] = c;\n  } while (length > 0);\n  return i;\n}","pass":1,"source_file":"C_COMPILE/f1888/main_1888.c"}
{"compilable":0,"function":"int ringbuffer(unsigned char rw, unsigned char *data, unsigned int count) {\n    static volatile unsigned char buffer[384];\n    static volatile unsigned int read_pointer, write_pointer;\n    static volatile unsigned int content = 0;\n    unsigned int p = 0;\n    unsigned int p2 = 0;\n    if (rw == 1) {\n        if (count < 384 - content) {\n            while (p < count)\n                {\n                    buffer[write_pointer++] = data[p++];\n                }\n            content += count;\n            return (1);\n        }\n    } else if (rw == 0) {\n        if (content >= count) {\n            while (p2 < count)\n                {\n                    data[p2++] = buffer[read_pointer++];\n                }\n            content -= count;\n            if (!content) {\n                write_pointer = 0;\n                read_pointer = 0;\n            }\n            return (1);\n        }\n    } else if (rw == 2) {\n        if (content)\n            return 0;\n        else\n            return (384 - 11);\n    }\n    return (0);\n}\n","function_prediction":"int ringbuffer_name_conflict(char mode, char *data, unsigned int length) {\n  unsigned int i = 0;\n  unsigned int j = 0;\n\n  if (mode == 1) {\n    if (length > (384 - content_3)) {\n      return 0;\n    } else {\n      while (i < length) {\n        buffer_1[write_pointer_2] = data[i];\n        write_pointer_2++;\n        i++;\n      }\n      content_3 += length;\n      return 1;\n    }\n  } else if (mode == 0) {\n    if (length > content_3) {\n      return 0;\n    } else {\n      while (j < length) {\n        data[j] = buffer_1[read_pointer_0];\n        read_pointer_0++;\n        j++;\n      }\n      if (content_3 - length == 0) {\n        write_pointer_2 = 0;\n        read_pointer_0 = 0;\n      }\n      content_3 -= length;\n      return 1;\n    }\n  } else if (mode == 2) {\n    if (content_3 == 0) {\n      return 373;\n    } else {\n      return 0;\n    }\n  } else {\n    return 0;\n  }\n}","pass":0,"source_file":"C_COMPILE/f1233/main_1233.c"}
{"compilable":0,"function":"static int wdl_atomic_decr(int *v) {\n    return __sync_add_and_fetch_4(v, ~0);\n}\n","function_prediction":"int wdl_atomic_decr_name_conflict(wdl_atomic_t *v) {\n  int ret;\n  LOCK();\n  ret = --(*v);\n  UNLOCK();\n  return ret - 1;\n}","pass":0,"source_file":"C_COMPILE/f1508/main_1508.c"}
{"compilable":1,"function":"static int endIG(char *s, int *addend) {\n    *addend = 1;\n    return ((strchr(s, '1') != ((void *)0)) || (strchr(s, '2') != ((void *)0)));\n}\n","function_prediction":"int endIG_name_conflict(char *s, int *end) {\n  *end = 1;\n  if (strchr(s, '1') || strchr(s, '2'))\n    return 1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1994/main_1994.c"}
{"compilable":1,"function":"int unicoder_utf32_encode(unsigned char *p, unsigned int x, unsigned int endianness) {\n    int i, index;\n    unsigned int temp;\n    const int debug_utf32_encode = 1;\n    if (endianness != 2 && endianness != 1)\n        return -4;\n    if (p == ((void *)0))\n        return -1;\n    if (x > 1114111)\n        return -16;\n    if (55296 <= x && x <= 57343)\n        return -16;\n    for (i = 0; i < 4; i++) {\n        temp = (x << (i * 8)) & 4278190080U;\n        if (endianness == 2)\n            index = i;\n        else\n            index = 3 - i;\n        *(p + index) = (unsigned char)((temp >> 24) & 255);\n    }\n    return 4;\n}\n","function_prediction":"int unicoder_utf32_encode_name_conflict(char *buf, uint32_t code, int endian) {\n  int i;\n  if (endian != 1 && endian != 2)\n    return -4;\n  if (buf == NULL)\n    return -1;\n  if (code > 0x10FFFF)\n    return -15;\n  if (code >= 0xD800 && code <= 0xDFFF)\n    return -15;\n  for (i = 0; i < 4; i++) {\n    int j = endian == 2 ? i : 3 - i;\n    buf[j] = (code << (i * 8)) >> 24;\n  }\n  return 4;\n}","pass":0,"source_file":"C_COMPILE/f1146/main_1146.c"}
{"compilable":1,"function":"int Sequential_Search2(int *a, int n, int key) {\n    int i;\n    a[0] = key;\n    i = n;\n    while (a[i] != key)\n        {\n            i--;\n        }\n    return i;\n}\n","function_prediction":"int Sequential_Search2_name_conflict(int *a, int n, int key) {\n  int i;\n  a[0] = key;\n  for (i = n; a[i] != key; i--)\n    ;\n  return i;\n}","pass":0,"source_file":"C_COMPILE/f521/main_521.c"}
{"compilable":0,"function":"unsigned short PLS_QueryStatus(unsigned char *pSrc, unsigned char *pDest, unsigned char *pType) {\n    unsigned short nLen = 0;\n    return nLen;\n}\n","function_prediction":"int PLS_QueryStatus_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/f155/main_155.c"}
{"compilable":1,"function":"char *safestrcpy(char *s, const char *t, int n) {\n    char *os;\n    os = s;\n    if (n <= 0)\n        return os;\n    while (--n > 0 && (*s++ = *t++) != 0)\n        ;\n    *s = 0;\n    return os;\n}\n","function_prediction":"char *safestrcpy_name_conflict(char *dest, const char *src, int maxlen) {\n  char *d = dest;\n  const char *s = src;\n\n  while (maxlen-- > 0 && *d != '\\0')\n    *d++ = *s++;\n  *d = '\\0';\n  return dest;\n}","pass":0,"source_file":"C_COMPILE/f501/main_501.c"}
{"compilable":1,"function":"int g2(int *p) {\n    *p = 10;\n    return 0;\n}\n","function_prediction":"int g2_name_conflict(int *p) {\n  *p = 10;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f1178/main_1178.c"}
{"compilable":1,"function":"char *chcopy(char *p, char *q) {\n    while ((*p = *q++) != 0)\n        ++p;\n    return (p);\n}\n","function_prediction":"char *chcopy_name_conflict(char *dst, const char *src) {\n  while ((*dst++ = *src++))\n    ;\n  return dst - 1;\n}","pass":1,"source_file":"C_COMPILE/f968/main_968.c"}
{"compilable":0,"function":"int SDL_imageFilterMultDivby4MMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, unsigned int SrcLength) {\n    return (-1);\n}\n","function_prediction":"int SDL_imageFilterMultDivby4MMX_name_conflict(Uint8 *src, Uint8 *dst, int length) {\n# 100 \"/scratch/repos/new/home/jordi_armengol_estape/c-scraper/outputs/2022-01-22/02-19-57/repos/g-Fulcrum/SDL_gfx/refs/heads/master/SDL_imageFilter.c\"\n  return -1;\n}","pass":0,"source_file":"C_COMPILE/f1810/main_1810.c"}
{"compilable":1,"function":"char *strcpy(char *dest, const char *src) {\n    char *tmp = dest;\n    while ((*dest++ = *src++) != '\\x00')\n        ;\n    return tmp;\n}\n","function_prediction":"char *strcpy_name_conflict(char *dest, const char *src) {\n  char *d = dest;\n  const char *s = src;\n\n  do {\n    *d = *s;\n  } while (*d++ = *s++);\n\n  return dest;\n}","pass":1,"source_file":"C_COMPILE/f1474/main_1474.c"}
{"compilable":0,"function":"static inline intptr_t atomic_fetch_or(intptr_t *object, intptr_t operand) {\n    intptr_t ret;\n    ret = *object;\n    *object = *object | operand;\n    return ret;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1703/main_1703.c"}
{"compilable":0,"function":"int SDL_imageFilterSubMMX(unsigned char *Src1, unsigned char *Src2, unsigned char *Dest, int length) {\n    return (0);\n}\n","function_prediction":"int SDL_imageFilterSubMMX_name_conflict(void) { return 0; }","pass":0,"source_file":"C_COMPILE/f1110/main_1110.c"}
{"compilable":1,"function":"int sum10(int values[10]) {\n    int i;\n    int sum = 0;\n    for (i = 0; i < 10; ++i) {\n        sum += values[i];\n    }\n    values[0] = 342;\n    return sum;\n}\n","function_prediction":"int sum10_name_conflict(int *a) {\n  int i, sum = 0;\n\n  for (i = 0; i < 10; i++)\n    sum += a[i];\n\n  a[0] = 342;\n\n  return sum;\n}","pass":1,"source_file":"C_COMPILE/f1832/main_1832.c"}
{"compilable":1,"function":"int vxy(int *x, int *y) {\n    int flag = 0;\n    if (*x < 0) {\n        *x = 0;\n        flag++;\n    }\n    if (*y < 0) {\n        *y = 0;\n        flag++;\n    }\n    if (*x >= 67) {\n        *x = 67 - 1;\n        flag++;\n    }\n    if (*y >= 17) {\n        *y = 17 - 1;\n        flag++;\n    }\n    return (flag);\n}\n","function_prediction":"int vxy_name_conflict(int *x, int *y) {\n  int ret = 0;\n  if (*x < 0) {\n    *x = 0;\n    ret++;\n  }\n  if (*y < 0) {\n    *y = 0;\n    ret++;\n  }\n  if (*x > 66) {\n    *x = 66;\n    ret++;\n  }\n  if (*y > 16) {\n    *y = 16;\n    ret++;\n  }\n  return ret;\n}","pass":1,"source_file":"C_COMPILE/f1257/main_1257.c"}
{"compilable":1,"function":"char *AppendString(char *target, const char *source) {\n    while ((*target = *source))\n        source++ , target++;\n    return target;\n}\n","function_prediction":"char *AppendString_name_conflict(char *dest, char *src) {\n  char *p = dest;\n\n  while (*p = *src) {\n    if (*p == '\\0')\n      break;\n    p++;\n    src++;\n  }\n\n  return p;\n}","pass":1,"source_file":"C_COMPILE/f1345/main_1345.c"}
{"compilable":0,"function":"static inline int atomic_compare_exchange_strong(intptr_t *object, intptr_t *expected, intptr_t desired) {\n    int ret;\n    if (*object == *expected) {\n        *object = desired;\n        ret = 1;\n    } else {\n        *expected = *object;\n        ret = 0;\n    }\n    return ret;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1176/main_1176.c"}
{"compilable":1,"function":"int bar(int *pnum, char *ptr) {\n    int i = 0;\n    int *invalid = ((void *)0);\n    int **pp = &invalid;\n    *pp = &i;\n    i = *ptr - 'a';\n    i = (i + 1) % 26;\n    *ptr = 'a' + i;\n    *pnum += 1;\n    return *pnum;\n}\n","function_prediction":"int bar_name_conflict(int *a, char *b) {\n  *b = (*b - 'a' + 1) % 26 + 'a';\n  return ++*a;\n}","pass":1,"source_file":"C_COMPILE/f1086/main_1086.c"}
{"compilable":0,"function":"static inline int _HXMutexSetBit(volatile int *volatile pLock) {\n    volatile int nOldBit;\n    asm volatile (\"xchg %%eax, (%%rbx)\" : \"=a\" (nOldBit) : \"a\" (1), \"b\" (pLock));\n    return nOldBit;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f209/main_209.c"}
{"compilable":1,"function":"int exgcd(int a, int b, int *x, int *y) {\n    if (b == 0) {\n        *x = 1;\n        *y = 0;\n        return a;\n    }\n    int r = exgcd(b, a % b, y, x);\n    *y -= (*x) * (a / b);\n    return r;\n}\n","function_prediction":"int exgcd_name_conflict(int a, int b, int *x, int *y) {\n  if (b == 0) {\n    *x = 1;\n    *y = 0;\n    return a;\n  }\n  int gcd = exgcd_name_conflict(b, a % b, y, x);\n  *y -= a / b * (*x);\n  return gcd;\n}","pass":1,"source_file":"C_COMPILE/f604/main_604.c"}
{"compilable":1,"function":"char *string_proper(char *argument) {\n    char *s;\n    s = argument;\n    while (*s != '\\x00')\n        {\n            if (*s != ' ') {\n                *s = ((*s) >= 'a' && (*s) <= 'z' ? (*s) + 'A' - 'a' : (*s));\n                while (*s != ' ' && *s != '\\x00')\n                    s++;\n            } else {\n                s++;\n            }\n        }\n    return argument;\n}\n","function_prediction":"char *string_proper_name_conflict(char *s) {\n  char *p;\n\n  p = s;\n  while (*p) {\n    if (*p != ' ') {\n      *p = (*p >= 'a' && *p <= 'z') ? *p - 'a' + 'A' : *p;\n      while (*p != ' ' && *p)\n        p++;\n    } else\n      p++;\n  }\n  return s;\n}","pass":1,"source_file":"C_COMPILE/f1301/main_1301.c"}
{"compilable":0,"function":"static inline int thread_xadd(int *var, int n) {\n    int v = *var;\n    *var += n;\n    return (v);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f168/main_168.c"}
{"compilable":1,"function":"char *reverser(char *s) {\n    unsigned int e, max;\n    char temp;\n    for (e = 0; s[e] != '\\x00'; ++e)\n        ;\n    max = e;\n    for (e = 0; e < max / 2; ++e) {\n        temp = s[e];\n        s[e] = s[max - (e + 1)];\n        s[max - (e + 1)] = temp;\n    }\n    return s;\n}\n","function_prediction":"char *reverser_name_conflict(char *str) {\n  int i, j, len;\n  char temp;\n\n  for (len = 0; str[len] != '\\0'; len++)\n    ;\n\n  for (i = 0, j = len - 1; i < len / 2; i++, j--) {\n    temp = str[i];\n    str[i] = str[j];\n    str[j] = temp;\n  }\n\n  return str;\n}","pass":0,"source_file":"C_COMPILE/f1730/main_1730.c"}
{"compilable":1,"function":"wchar_t *(_win_wcscpy)(wchar_t *dest, const wchar_t *src) {\n    wchar_t *d = dest;\n    while ((*d++ = *src++))\n        ;\n    return dest;\n}\n","function_prediction":"wchar_t *_win_wcscpy_name_conflict(wchar_t *dst, const wchar_t *src) {\n  wchar_t *dst0 = dst;\n  do {\n    *dst++ = *src++;\n  } while (*(dst - 1));\n  return dst0;\n}","pass":1,"source_file":"C_COMPILE/f886/main_886.c"}
{"compilable":1,"function":"int findi(int *vec, int n_vec, int search_value, int *index) {\n    int i;\n    int n;\n    n = 0;\n    for (i = 1; i <= n_vec; i++) {\n        if (vec[i] == search_value) {\n            n++;\n            index[n] = i;\n        }\n    }\n    return n;\n}\n","function_prediction":"int findi_name_conflict(int *a, int n, int x, int *b) {\n  int i, j;\n  j = 0;\n  for (i = 1; i <= n; i++)\n    if (a[i] == x) {\n      j++;\n      b[j] = i;\n    }\n  return j;\n}","pass":1,"source_file":"C_COMPILE/f1522/main_1522.c"}
{"compilable":0,"function":"int readpng(char *name, int *xres, int *yres, unsigned char **imgdata) {\n    return 2;\n}\n","function_prediction":"int readpng_name_conflict(char *filename) { return 2; }","pass":0,"source_file":"C_COMPILE/f987/main_987.c"}
{"compilable":0,"function":"static inline int _inverse_scale(const int *m, int *o) {\n    if (m[0] == 0 || m[3] == 0)\n        return 1;\n    o[0] = (1024 * 1024) / m[0];\n    o[1] = 0;\n    o[2] = 0;\n    o[3] = (1024 * 1024) / m[3];\n    o[4] = -(m[4] * o[0]) / 1024;\n    o[5] = -(m[5] * o[3]) / 1024;\n    return 0;\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f102/main_102.c"}
{"compilable":1,"function":"int decode_hex(const char *p, int len, int *pvalid) {\n    int valid = 1;\n    int value = 0;\n    int ii;\n    for (ii = 0; ii < len; ++ii) {\n        int ch = p[ii];\n        if (ch >= '0' && ch <= '9') {\n            ch -= '0';\n        } else {\n            ch &= ~20;\n            if (ch < 'A' || ch > 'F') {\n                valid = 0;\n                break;\n            }\n            ch = ch - 'A' + 10;\n        }\n        value = (value << 4) + ch;\n    }\n    if (pvalid)\n        *pvalid = valid;\n    return value;\n}\n","function_prediction":"int decode_hex_name_conflict(const char *str, int len, int *ok) {\n  int i, v, r = 0;\n  int ok_ = 1;\n\n  for (i = 0; i < len; i++) {\n    if (str[i] >= '0' && str[i] <= '9') {\n      v = str[i] - '0';\n    } else if (str[i] >= 'A' && str[i] <= 'F') {\n      v = str[i] - 'A' + 10;\n    } else if (str[i] >= 'a' && str[i] <= 'f') {\n      v = str[i] - 'a' + 10;\n    } else {\n      ok_ = 0;\n      break;\n    }\n    r = (r << 4) + v;\n  }\n\n  if (ok) {\n    *ok = ok_;\n  }\n\n  return r;\n}","pass":0,"source_file":"C_COMPILE/f612/main_612.c"}
{"compilable":1,"function":"char *ltoa(long value, char *str, int base) {\n    char *rc;\n    char *ptr;\n    char *low;\n    if (base < 2 || base > 36) {\n        *str = '\\x00';\n        return str;\n    }\n    rc = ptr = str;\n    if (value < 0 && base == 10) {\n        *ptr++ = '-';\n    }\n    low = ptr;\n    do {\n        *ptr++ = \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\"[35 + value % base];\n        value /= base;\n    } while (value);\n    *ptr-- = '\\x00';\n    while (low < ptr)\n        {\n            char tmp = *low;\n            *low++ = *ptr;\n            *ptr-- = tmp;\n        }\n    return rc;\n}\n","function_prediction":"char *ltoa_name_conflict(long num, char *buf, int radix) {\n  char *p1, *p2;\n  unsigned long val;\n  static char digits[] =\n      \"zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz\";\n\n  if (radix > 36 || radix < 2) {\n    buf[0] = '\\0';\n    return buf;\n  }\n\n  p1 = buf;\n  p2 = buf;\n\n  if (num < 0 && radix == 10) {\n    *p1++ = '-';\n  }\n\n  val = num;\n  do {\n    *p1++ = digits[val % radix];\n    val /= radix;\n  } while (val);\n\n  *p1-- = '\\0';\n\n  while (p2 < p1) {\n    char tmp = *p1;\n    *p1-- = *p2;\n    *p2++ = tmp;\n  }\n\n  return buf;\n}","pass":0,"source_file":"C_COMPILE/f215/main_215.c"}
{"compilable":0,"function":"int FMOVQ(unsigned long *rd, unsigned long *rs2) {\n    rd[0] = rs2[0];\n    rd[1] = rs2[1];\n    return 0;\n}\n","function_prediction":"int FMOVQ_name_conflict(AMD64ExecutionContext *r, AMD64Instruction *inst) {\n  r->RIP = inst->RIP;\n  r->RIP += (8);\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f180/main_180.c"}
{"compilable":1,"function":"char *itos(int n, char ret[]) {\n    const char digit[] = \"0123456789\";\n    char *retstring = ret;\n    if (n < 0) {\n        *retstring++ = '-';\n        n *= -1;\n    }\n    int shifter = n;\n    do {\n        ++retstring;\n        shifter = shifter / 10;\n    } while (shifter);\n    *retstring = '\\x00';\n    do {\n        *--retstring = digit[n % 10];\n        n = n / 10;\n    } while (n);\n    return ret;\n}\n","function_prediction":"char *itos_name_conflict(int n, char *s) {\n  char *s1 = s;\n  char *s2 = \"0123456789\";\n  if (n < 0) {\n    *s1++ = '-';\n    n = -n;\n  }\n  int n1 = n;\n  do {\n    n1 /= 10;\n    s1++;\n  } while (n1);\n  *s1 = '\\0';\n  do {\n    *--s1 = s2[n % 10];\n    n /= 10;\n  } while (n);\n  return s;\n}","pass":1,"source_file":"C_COMPILE/f255/main_255.c"}
{"compilable":1,"function":"unsigned int btrl_reg(unsigned int reg_in, int bitno, unsigned int *reg_out_p) {\n    unsigned char res;\n    unsigned int reg_out;\n    asm volatile (\"movl\\t%3, %%eax\\n\\tbtrl\\t%2, %%eax\\n\\tmovl\\t%%eax, %1\\n\\tsetc\\t%0\" : \"=q\" (res), \"=r\" (reg_out) : \"r\" (bitno), \"r\" (reg_in) : \"cc\", \"eax\");\n    *reg_out_p = reg_out;\n    return res;\n}\n","function_prediction":"int btrl_reg_name_conflict(uint32_t reg, uint32_t bit, uint32_t *out) {\n  *out = reg & ~(1 << bit);\n  return (reg >> bit) & 1;\n}","pass":1,"source_file":"C_COMPILE/f172/main_172.c"}
{"compilable":0,"function":"static inline int atomic_add(volatile int *i, int j) {\n    return __sync_fetch_and_add_4(i, j);\n}\n","function_prediction":"void __attribute__((noinline)) __attribute__((regparm(3)))\nfoo(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k,\n    int l, int m, int n, int o, int p, int q, int r, int s, int t, int u, int v,\n    int w, int x, int y, int z) {\n  int x1 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x2 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x3 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x4 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x5 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x6 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int x7 = a + b + c + d + e + f + g + h + i + j + k + l + m + n + o + p + q +\n           r + s + t + u + v + w + x + y + z;\n  int","pass":0,"source_file":"C_COMPILE/f1138/main_1138.c"}
{"compilable":1,"function":"static char *choice_one(char *s_history, int *i, char *result) {\n    if (*i >= 0) {\n        result = s_history;\n        if (*i > 0)\n            --*i;\n    }\n    return (result);\n}\n","function_prediction":"char *choice_one_name_conflict(char *s, int *n, char *t) {\n  if (*n >= 0) {\n    if (*n > 0)\n      --*n;\n    return s;\n  }\n  return t;\n}","pass":1,"source_file":"C_COMPILE/f946/main_946.c"}
{"compilable":1,"function":"char *ft_strrev(char *str) {\n    char x;\n    int a;\n    int b;\n    a = 0;\n    b = 0;\n    while (str[a] != '\\x00')\n        {\n            a++;\n        }\n    a--;\n    while (a >= b)\n        {\n            x = str[a];\n            str[a] = str[b];\n            str[b] = x;\n            a--;\n            b++;\n        }\n    return (str);\n}\n","function_prediction":"char *ft_strrev_name_conflict(char *str) {\n  int i;\n  int j;\n  char c;\n\n  i = 0;\n  j = 0;\n  while (str[j] != '\\0')\n    j++;\n  j--;\n  while (i <= j) {\n    c = str[j];\n    str[j] = str[i];\n    str[i] = c;\n    i++;\n    j--;\n  }\n  return (str);\n}","pass":0,"source_file":"C_COMPILE/f1962/main_1962.c"}
{"compilable":0,"function":"short goertzel_output_power_v0(short *delay, short coefficient) {\n    long product1, product2, product3;\n    int goertzel_power;\n    product1 = ((long)delay[1] * delay[1]);\n    product2 = ((long)delay[2] * delay[2]);\n    product3 = (((long)delay[1] * coefficient) >> 14);\n    product3 = (product3 * delay[2]);\n    goertzel_power = (short)((product1 + product2 - product3) >> 14 - 5);\n    delay[1] = 0;\n    delay[2] = 0;\n    return goertzel_power;\n}\n","function_prediction":"int goertzel_output_power_v0_name_conflict(goertzel_state_t *state, short input) {\n  int output;\n  int real;\n  int imag;\n\n  real = state->real;\n  imag = state->imag;\n\n  state->real = (short)((real + (input * state->coeff_real)) -\n                        (imag * state->coeff_imag));\n  state->imag = (short)((imag + (input * state->coeff_real)) -\n                        (real * state->coeff_imag));\n\n  output = (state->real * state->real) + (state->imag * state->imag);\n\n  return output >> 9;\n}","pass":0,"source_file":"C_COMPILE/f1046/main_1046.c"}
{"compilable":1,"function":"static unsigned int uInt32Number(unsigned char buf[4]) {\n    unsigned int numb = buf[3];\n    numb = (numb << 8) | buf[2];\n    numb = (numb << 8) | buf[1];\n    numb = (numb << 8) | buf[0];\n    return numb;\n}\n","function_prediction":"uint32_t uInt32Number_name_conflict(const void *p) { return *(uint32_t *)p; }","pass":1,"source_file":"C_COMPILE/f1109/main_1109.c"}
{"compilable":0,"function":"int comparer(const char lettre, const char motSecret[], char motEssai[], const int tailleMotSecret) {\n    int i = 0;\n    int succes = 0;\n    for (i = 0; i < tailleMotSecret; i++) {\n        if (motSecret[i] == lettre) {\n            motEssai[i] = lettre;\n            succes++;\n        }\n    }\n    if (succes == 0)\n        return 0;\n    else\n        return 1;\n}\n","function_prediction":"int comparer_name_conflict(char c, char *s, char *p, int len) {\n  int i, j;\n\n  j = 0;\n  for (i = 0; i < len; i++) {\n    if (c == s[i]) {\n      p[j] = c;\n      j++;\n    }\n  }\n  if (j)\n    return (1);\n  return (0);\n}","pass":0,"source_file":"C_COMPILE/f707/main_707.c"}
{"compilable":1,"function":"const char *f(int *pb, int *pa) {\n    *pb = 5;\n    *pa = 8;\n    return \"hi\";\n}\n","function_prediction":"char *f_name_conflict(int *a, int *b) {\n  *a = 5;\n  *b = 8;\n  return \"f_name_conflictoo\";\n}","pass":0,"source_file":"C_COMPILE/f456/main_456.c"}
{"compilable":0,"function":"int iter_mgr(int last_result, long *next_try, long max_step, int *restart) {\n    static long last_bad, last_good;\n    static int stage;\n    long step;\n    if (*restart) {\n        *restart = 0;\n        stage = 0;\n    }\n    switch (stage) {\n      case 0:\n        stage = 1;\n        *next_try = 0L;\n        return 0;\n      case 1:\n        stage = 2;\n        if (last_result < 0) {\n            last_bad = 0L;\n            *next_try = 1L;\n            return 0;\n        } else {\n            return 1;\n        }\n      case 2:\n        if (last_result < 0) {\n            last_bad = *next_try;\n            step = ((*next_try + 1L) < (max_step) ? (*next_try + 1L) : (max_step));\n            *next_try += step;\n            return 0;\n        } else {\n            last_good = *next_try;\n            if (last_result == 0 || (last_good - last_bad) == 1L)\n                return 1;\n            else {\n                stage = 3;\n                *next_try = (last_bad + last_good) / 2L;\n                return 0;\n            }\n        }\n      case 3:\n        if (last_result < 0) {\n            last_bad = *next_try;\n            *next_try = (((last_bad + last_good) / 2L) > (last_bad + 1L) ? ((last_bad + last_good) / 2L) : (last_bad + 1L));\n            return 0;\n        } else {\n            if (last_result == 0L || (last_good - last_bad) == 1L)\n                return 1;\n            last_good = *next_try;\n            *next_try = (((last_bad + last_good) / 2L) > (last_bad + 1L) ? ((last_bad + last_good) / 2L) : (last_bad + 1L));\n            return 0;\n        }\n    }\n    return 0;\n}\n","function_prediction":"int iter_mgr_name_conflict(int result, long *iter, long max_iter, int *reset) {\n  if (*reset) {\n    *reset = 0;\n    stage_2 = 0;\n  }\n\n  switch (stage_2) {\n  case 0:\n    stage_2 = 1;\n    *iter = 0;\n    break;\n  case 1:\n    if (result < 0) {\n      stage_2 = 2;\n      last_bad_1 = 0;\n      *iter = 1;\n    } else {\n      stage_2 = 2;\n      return 1;\n    }\n    break;\n  case 2:\n    if (result < 0) {\n      last_bad_1 = *iter;\n      *iter = ((*iter) + 1 < (max_iter) ? (*iter) + 1 : (max_iter));\n    } else {\n      last_good_0 = *iter;\n      if (result == 0 || last_good_0 - last_bad_1 == 1)\n        return 1;\n      stage_2 = 3;\n      *iter = (last_good_0 + last_bad_1) / 2;\n    }\n    break;\n  case 3:\n    if (result < 0) {\n      last_bad_1 = *iter;\n      *iter = ((last_good_0 + last_bad_1 + 1) > (last_good_0 + last_bad_1 + 1)\n                   ? (last_good_0 + last_bad_1 + 1)\n                   : (last_good_0 + last_bad_1 + 1));\n    } else if (result == 0 || last_good_0 - last_bad_1 == 1)\n      return 1;\n    else {\n      last_good_0 = *iter;\n      *iter = ((last_good_0 + last_bad_1 + 1) > (last_good_0 + last_bad_1 + 1)\n                   ? (last_good_0 + last_bad_1 + 1)\n                   : (last_good_0 + last_bad_1 + 1));\n    }\n    break;\n  }\n\n  return 0;\n}","pass":0,"source_file":"C_COMPILE/f1019/main_1019.c"}
{"compilable":0,"function":"int net_write(const int sock, unsigned char *buffer, unsigned int buffer_length) {\n    return send(sock, buffer, buffer_length, 0);\n}\n","function_prediction":"int net_write_name_conflict(int sock, char *buf, int len) { return send(sock, buf, len, 0); }","pass":0,"source_file":"C_COMPILE/f1531/main_1531.c"}
{"compilable":1,"function":"int monitor_get_pid(int restarting, int *pid) {\n    if (restarting) {\n    }\n    *pid = -1;\n    return 0;\n}\n","function_prediction":"int monitor_get_pid_name_conflict(const char *name, int *pid) {\n  *pid = -1;\n  return 0;\n}","pass":1,"source_file":"C_COMPILE/f2064/main_2064.c"}
{"compilable":1,"function":"char *StrCpy(char *to, const char *from) {\n    char *_to = to;\n    char *_from = from;\n    while (*_from != '\\x00')\n        {\n            *_to++ = *_from++;\n        }\n    *_to = '\\x00';\n    return to;\n}\n","function_prediction":"char *StrCpy_name_conflict(char *s1, const char *s2) {\n  char *p = s1;\n  const char *q = s2;\n\n  while (*q)\n    *p++ = *q++;\n  *p = '\\0';\n\n  return s1;\n}","pass":1,"source_file":"C_COMPILE/f719/main_719.c"}
